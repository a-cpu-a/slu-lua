<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="description" content="Lua-unit highlighted"><title>Example</title><style>body{color:#AFAFAA;font-family:"Monaco",monospace;background:#000;margin-bottom:500px}h1{font-size:5em;text-align:center}#s{border-radius:10px;background:#222;width:800px;margin:auto;padding:12px 12px;overflow:visible}.q{overflow:hidden;border-radius:10px;background:#333;padding:7px 7px;position:relative;overflow:visible}.slua-code-box{tab-size:3;white-space-collapse:preserve;background:#151515;padding:8px;border-radius:8px;margin:4px 0px;display:block}</style></head><body><h1>Luaunit</h1><div id=s><div class=q><style>.D{color:#E44F6E}.E{color:#8D97A7}.U{color:#3C3C43}.V{color:#565662}.B{color:#ABD062}.C{color:#D7D7D7}.F{color:#7AA737}.G{color:#D77C7C}.H{color:#BEC3CB}.I{color:#5686DA}.J{color:#B47F54}.K{color:#CD4B4B}.L{color:#6481C0}.M{color:#529ABC}.N{color:#BC70C3}.A{color:#575763}.O{color:#A8AFBB}.P{color:#9BA4B1}.T{color:#6A72A0}</style><code class="slua-code-box V"><span class=U>--[[<br>        </span>luaunit.lua<br><br>Description: A unit testing framework<br>Homepage: https://github.com/bluebird75/luaunit<br>Development by Philippe Fremy &lt;phil@freehackers.org&gt;<br>Based on initial work of Ryu, Gwang (http://www.gpgstudy.com/gpgiki/LuaUnit)<br>License: BSD License, see LICENSE.txt<br><span class=U>]]--<br><br><span class=C>require<span class=E>(<span class=B>&#34;<span class=F>math</span>&#34;</span>)<br><span class=G>local </span></span>M<span class=D>=<span class=E>{}<br><br></span></span></span>-- </span>private exported functions (for testing)<br><span class=C>M<span class=H>.</span>private <span class=D>= <span class=E>{}<br><br></span></span>M<span class=H>.</span>VERSION<span class=D>=<span class=B>&#39;<span class=F>3.4</span>&#39;<br></span></span>M<span class=H>.</span>_VERSION<span class=D>=</span>M<span class=H>.</span>VERSION <span class=U>-- </span></span>For LuaUnit v2 compatibility<br><br><span class=U>-- </span>a version which distinguish between regular Lua and LuaJit<br><span class=C>M<span class=H>.</span>_LUAVERSION <span class=D>= <span class=E>(</span></span>jit <span class=I>and </span>jit<span class=H>.</span>version<span class=E>) <span class=J>or </span></span>_VERSION<br><br><span class=U>--[[ </span></span>Some people like assertEquals( actual, expected ) and some people prefer<br>assertEquals( expected, actual ).<br><span class=U>]]--<br><span class=C>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED <span class=D>= <span class=L>true<br></span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=D>= <span class=L>false<br></span></span>M<span class=H>.</span>LINE_LENGTH <span class=D>= <span class=M>80<br></span></span>M<span class=H>.</span>TABLE_DIFF_ANALYSIS_THRESHOLD <span class=D>= <span class=M>10    </span></span></span>-- </span>display deep analysis for more than 10 items<br><span class=C>M<span class=H>.</span>LIST_DIFF_ANALYSIS_THRESHOLD  <span class=D>= <span class=M>10    <span class=U>-- </span></span></span></span>display deep analysis for more than 10 items<br><br><span class=U>-- </span>this setting allow to remove entries from the stack-trace, for <br><span class=U>-- </span>example to hide a call to a framework which would be calling luaunit<br><span class=C>M<span class=H>.</span>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE <span class=D>= <span class=M>0<br><br><span class=U>--[[ </span></span></span></span>EPS is meant to help with Lua&#39;s floating point math in simple corner<br>cases like almostEquals(1.1-0.1, 1), which may not work as-is (e.g. on numbers<br>with rational binary representation) if the user doesn&#39;t provide some explicit<br>error margin.<br><br>The default margin used by almostEquals() in such cases is EPS; and since<br>Lua may be compiled with different numeric precisions (single vs. double), we<br>try to select a useful default for it dynamically. Note: If the initial value<br>is not acceptable, it can be changed by the user to better suit specific needs.<br><br>See also: https://en.wikipedia.org/wiki/Machine_epsilon<br><span class=U>]]<br><span class=C>M<span class=H>.</span>EPS <span class=D>= <span class=M>2<span class=E>^-</span>52 </span></span></span>-- </span>= machine epsilon for &#34;double&#34;, ~2.22E-16<br><span class=N>if <span class=C>math<span class=H>.</span>abs<span class=E>(<span class=M>1.1 </span>- <span class=M>1 </span>- <span class=M>0.1</span>) &gt; </span>M<span class=H>.</span>EPS </span>then<br>    <span class=U>-- </span></span>rounding error is above EPS, assume single precision<br>    <span class=C>M<span class=H>.</span>EPS <span class=D>= <span class=M>2<span class=E>^-</span>23 <span class=U>-- </span></span></span></span>= machine epsilon for &#34;float&#34;, ~1.19E-07<br><span class=N>end<br><br><span class=U>-- </span></span>set this to false to debug luaunit<br><span class=G>local <span class=C>STRIP_LUAUNIT_FROM_STACKTRACE <span class=D>= <span class=L>true<br><br></span></span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=D>= <span class=M>10<br></span></span>M<span class=H>.</span>VERBOSITY_LOW     <span class=D>= <span class=M>1<br></span></span>M<span class=H>.</span>VERBOSITY_QUIET   <span class=D>= <span class=M>0<br></span></span>M<span class=H>.</span>VERBOSITY_VERBOSE <span class=D>= <span class=M>20<br></span></span>M<span class=H>.</span>DEFAULT_DEEP_ANALYSIS <span class=D>= <span class=L>nil<br></span></span>M<span class=H>.</span>FORCE_DEEP_ANALYSIS   <span class=D>= <span class=L>true<br></span></span>M<span class=H>.</span>DISABLE_DEEP_ANALYSIS <span class=D>= <span class=L>false<br><br><span class=U>-- </span></span></span></span></span>set EXPORT_ASSERT_TO_GLOBALS to have all asserts visible as global values<br><span class=U>-- </span>EXPORT_ASSERT_TO_GLOBALS = true<br><br><span class=U>-- </span>we need to keep a copy of the script args before it is overriden<br><span class=G>local <span class=C>cmdline_argv <span class=D>= </span>rawget<span class=E>(</span>_G<span class=O>, <span class=B>&#34;<span class=F>arg</span>&#34;<span class=E>)<br><br></span></span></span>M<span class=H>.</span>FAILURE_PREFIX <span class=D>= <span class=B>&#39;<span class=F>LuaUnit test FAILURE: </span>&#39; <span class=U>-- </span></span></span></span></span>prefix string for failed tests<br><span class=C>M<span class=H>.</span>SUCCESS_PREFIX <span class=D>= <span class=B>&#39;<span class=F>LuaUnit test SUCCESS: </span>&#39; <span class=U>-- </span></span></span></span>prefix string for successful tests finished early<br><span class=C>M<span class=H>.</span>SKIP_PREFIX    <span class=D>= <span class=B>&#39;<span class=F>LuaUnit test SKIP:    </span>&#39; <span class=U>-- </span></span></span></span>prefix string for skipped tests<br><br><br><br><span class=C>M<span class=H>.</span>USAGE<span class=D>=<span class=B>[[<span class=F>Usage: lua &lt;your_test_suite.lua&gt; [options] [testname1 [testname2] ... ]<br>Options:<br>  -h, --help:             Print this help<br>  --version:              Print version information<br>  -v, --verbose:          Increase verbosity<br>  -q, --quiet:            Set verbosity to minimum<br>  -e, --error:            Stop on first error<br>  -f, --failure:          Stop on first failure or error<br>  -s, --shuffle:          Shuffle tests before running them<br>  -o, --output OUTPUT:    Set output type to OUTPUT<br>                          Possible values: text, tap, junit, nil<br>  -n, --name NAME:        For junit only, mandatory name of xml file<br>  -r, --repeat NUM:       Execute all tests NUM times, e.g. to trig the JIT<br>  -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN<br>                          May be repeated to include several patterns<br>                          Make sure you escape magic chars like +? with %<br>  -x, --exclude PATTERN:  Exclude all test names matching the Lua PATTERN<br>                          May be repeated to exclude several patterns<br>                          Make sure you escape magic chars like +? with %<br>  testname1, testname2, ... : tests to run in the form of testFunction,<br>                              TestClass or TestClass.testMethod<br><br>You may also control LuaUnit options with the following environment variables:<br>* LUAUNIT_OUTPUT: same as --output<br>* LUAUNIT_JUNIT_FNAME: same as --name </span>]]<br><br><span class=U>--</span></span></span></span>--------------------------------------------------------------<br><span class=U>--<br>--                 </span>general utility functions<br><span class=U>--<br>--</span>--------------------------------------------------------------<br><br><span class=U>--[[ </span>Note on catching exit<br><br>I have seen the case where running a big suite of test cases and one of them would<br>perform a os.exit(0), making the outside world think that the full test suite was executed<br>successfully.<br><br>This is an attempt to mitigate this problem: we override os.exit() to now let a test<br>exit the framework while we are running. When we are not running, it behaves normally.<br><span class=U>]]<br><br><span class=C>M<span class=H>.</span>oldOsExit <span class=D>= </span>os<span class=H>.</span>exit<br>os<span class=H>.</span>exit <span class=D>= <span class=K>function<span class=E>(<span class=O>...</span>) <br>    <span class=N>if </span></span></span></span>M<span class=H>.</span>LuaUnit <span class=I>and <span class=E>#</span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances <span class=E>~= <span class=M>0 <span class=N>then<br>        <span class=G>local </span></span></span></span>msg <span class=D>= <span class=B>[[<span class=F>You are trying to exit but there is still a running instance of LuaUnit.<br>LuaUnit expects to run until the end before exiting with a complete status of successful/failed tests.<br><br>To force exit LuaUnit while running, please call before os.exit (assuming lu is the luaunit module loaded):<br><br>    lu.unregisterCurrentSuite() <br><br></span>]]<br>        </span></span>M<span class=H>.</span>private<span class=H>.</span>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>msg<span class=E>)<br>    <span class=N>end<br>    </span></span>M<span class=H>.</span>oldOsExit<span class=E>(<span class=O>...</span>)<br><span class=K>end<br><br>local function </span></span>pcall_or_abort<span class=E>(</span>func<span class=O>, ...<span class=E>)<br>    </span></span></span>-- </span>unpack is a global function for Lua 5.1, otherwise use table.unpack<br>    <span class=G>local <span class=C>unpack <span class=D>= </span>rawget<span class=E>(</span>_G<span class=O>, <span class=B>&#34;<span class=F>unpack</span>&#34;<span class=E>) <span class=J>or </span></span></span></span>table<span class=H>.</span>unpack<br>    </span>local <span class=C>result <span class=D>= <span class=E>{</span></span>pcall<span class=E>(</span>func<span class=O>, ...<span class=E>)}<br>    <span class=N>if </span>not </span></span>result<span class=E>[<span class=M>1</span>] <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>an error occurred<br>        <span class=C>print<span class=E>(</span>result<span class=E>[<span class=M>2</span>]) <span class=U>-- </span></span></span>error message<br>        <span class=C>print<span class=E>()<br>        </span>print<span class=E>(</span>M<span class=H>.</span>USAGE<span class=E>)<br>        </span>os<span class=H>.</span>exit<span class=E>(-<span class=M>1</span>)<br>    <span class=N>end<br>    <span class=K>return </span></span></span>unpack<span class=E>(</span>result<span class=O>, <span class=M>2<span class=E>)<br><span class=K>end<br><br><span class=G>local </span></span></span></span></span>crossTypeOrdering <span class=D>= <span class=E>{<br>    <span class=P>number </span></span>= <span class=M>1<span class=O>, <span class=P>boolean </span></span></span>= <span class=M>2<span class=O>, <span class=P>string </span></span></span>= <span class=M>3<span class=O>, <span class=P>table </span></span></span>= <span class=M>4<span class=O>, <span class=P>other </span></span></span>= <span class=M>5<br><span class=E>}<br><span class=G>local </span></span></span></span>crossTypeComparison <span class=D>= <span class=E>{<br>    <span class=P>number </span></span>= <span class=K>function<span class=E>(</span></span></span>a<span class=O>, </span>b<span class=E>) <span class=K>return </span></span>a <span class=E>&lt; </span>b <span class=K>end<span class=O>,<br>    <span class=P>string <span class=D>= </span></span></span>function<span class=E>(</span></span>a<span class=O>, </span>b<span class=E>) <span class=K>return </span></span>a <span class=E>&lt; </span>b <span class=K>end<span class=O>,<br>    <span class=P>other <span class=D>= </span></span></span>function<span class=E>(</span></span>a<span class=O>, </span>b<span class=E>) <span class=K>return </span></span>tostring<span class=E>(</span>a<span class=E>) &lt; </span>tostring<span class=E>(</span>b<span class=E>) <span class=K>end<span class=O>,<br></span></span>}<br><br><span class=K>local function </span></span>crossTypeSort<span class=E>(</span>a<span class=O>, </span>b<span class=E>)<br>    <span class=G>local </span></span>type_a<span class=O>, </span>type_b <span class=D>= </span>type<span class=E>(</span>a<span class=E>)<span class=O>, </span></span>type<span class=E>(</span>b<span class=E>)<br>    <span class=N>if </span></span>type_a <span class=E>== </span>type_b <span class=N>then<br>        <span class=G>local </span></span>func <span class=D>= </span>crossTypeComparison<span class=E>[</span>type_a<span class=E>] <span class=J>or </span></span>crossTypeComparison<span class=H>.</span>other<br>        <span class=K>return </span>func<span class=E>(</span>a<span class=O>, </span>b<span class=E>)<br>    <span class=N>end<br>    </span></span>type_a <span class=D>= </span>crossTypeOrdering<span class=E>[</span>type_a<span class=E>] <span class=J>or </span></span>crossTypeOrdering<span class=H>.</span>other<br>    type_b <span class=D>= </span>crossTypeOrdering<span class=E>[</span>type_b<span class=E>] <span class=J>or </span></span>crossTypeOrdering<span class=H>.</span>other<br>    <span class=K>return </span>type_a <span class=E>&lt; </span>type_b<br><span class=K>end<br><br>local function </span>__genSortedIndex<span class=E>( </span>t <span class=E>)<br>    <span class=U>-- </span></span></span>Returns a sequence consisting of t&#39;s keys, sorted.<br>    <span class=G>local <span class=C>sortedIndex <span class=D>= <span class=E>{}<br><br>    <span class=N>for </span></span></span>key<span class=O>,</span>_ <span class=N>in </span>pairs<span class=E>(</span>t<span class=E>) <span class=N>do<br>        </span></span>table<span class=H>.</span>insert<span class=E>(</span>sortedIndex<span class=O>, </span>key<span class=E>)<br>    <span class=N>end<br><br>    </span></span>table<span class=H>.</span>sort<span class=E>(</span>sortedIndex<span class=O>, </span>crossTypeSort<span class=E>)<br>    <span class=K>return </span></span>sortedIndex<br><span class=K>end<br></span>M<span class=H>.</span>private<span class=H>.</span>__genSortedIndex <span class=D>= </span>__genSortedIndex<br><br><span class=K>local function </span>sortedNext<span class=E>(</span>state<span class=O>, </span>control<span class=E>)<br>    <span class=U>-- </span></span></span></span>Equivalent of the next() function of table iteration, but returns the<br>    <span class=U>-- </span>keys in sorted order (see __genSortedIndex and crossTypeSort).<br>    <span class=U>-- </span>The state is a temporary variable during iteration and contains the<br>    <span class=U>-- </span>sorted key table (state.sortedIdx). It also stores the last index (into<br>    <span class=U>-- </span>the keys) used by the iteration, to find the next one quickly.<br>    <span class=G>local <span class=C>key<br><br>    <span class=U>--</span></span></span>print(&#34;sortedNext: control = &#34;..tostring(control) )<br>    <span class=N>if <span class=C>control <span class=E>== <span class=L>nil </span></span></span>then<br>        <span class=U>-- </span></span>start of iteration<br>        <span class=C>state<span class=H>.</span>count <span class=D>= <span class=E>#</span></span>state<span class=H>.</span>sortedIdx<br>        state<span class=H>.</span>lastIdx <span class=D>= <span class=M>1<br>        </span></span>key <span class=D>= </span>state<span class=H>.</span>sortedIdx<span class=E>[<span class=M>1</span>]<br>        <span class=K>return </span></span>key<span class=O>, </span>state<span class=H>.</span>t<span class=E>[</span>key<span class=E>]<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span>normally, we expect the control variable to match the last key used<br>    <span class=N>if <span class=C>control <span class=E>~= </span>state<span class=H>.</span>sortedIdx<span class=E>[</span>state<span class=H>.</span>lastIdx<span class=E>] </span></span>then<br>        <span class=U>-- </span></span>strange, we have to find the next value by ourselves<br>        <span class=U>-- </span>the key table is sorted in crossTypeSort() order! -&gt; use bisection<br>        <span class=G>local <span class=C>lower<span class=O>, </span>upper <span class=D>= <span class=M>1<span class=O>, </span></span></span>state<span class=H>.</span>count<br>        <span class=N>repeat<br>            </span>state<span class=H>.</span>lastIdx <span class=D>= </span>math<span class=H>.</span>modf<span class=E>((</span>lower <span class=E>+ </span>upper<span class=E>) / <span class=M>2</span>)<br>            </span>key <span class=D>= </span>state<span class=H>.</span>sortedIdx<span class=E>[</span>state<span class=H>.</span>lastIdx<span class=E>]<br>            <span class=N>if </span></span>key <span class=E>== </span>control <span class=N>then<br>                break <span class=U>-- </span></span></span></span>key found (and thus prev index)<br>            <span class=N>end<br>            if <span class=C>crossTypeSort<span class=E>(</span>key<span class=O>, </span>control<span class=E>) </span></span>then<br>                <span class=U>-- </span></span>key &lt; control, continue search &#34;right&#34; (towards upper bound)<br>                <span class=C>lower <span class=D>= </span>state<span class=H>.</span>lastIdx <span class=E>+ <span class=M>1<br>            <span class=N>else<br>                <span class=U>-- </span></span></span></span></span>key &gt; control, continue search &#34;left&#34; (towards lower bound)<br>                <span class=C>upper <span class=D>= </span>state<span class=H>.</span>lastIdx <span class=E>- <span class=M>1<br>            <span class=N>end<br>        until </span></span></span>lower <span class=E>&gt; </span>upper<br>        <span class=N>if </span>lower <span class=E>&gt; </span>upper <span class=N>then <span class=U>-- </span></span></span>only true if the key wasn&#39;t found, ...<br>            <span class=C>state<span class=H>.</span>lastIdx <span class=D>= </span>state<span class=H>.</span>count <span class=U>-- </span></span>... so ensure no match in code below<br>        <span class=N>end<br>    end<br><br>    <span class=U>-- </span></span>proceed by retrieving the next value (or nil) from the sorted keys<br>    <span class=C>state<span class=H>.</span>lastIdx <span class=D>= </span>state<span class=H>.</span>lastIdx <span class=E>+ <span class=M>1<br>    </span></span>key <span class=D>= </span>state<span class=H>.</span>sortedIdx<span class=E>[</span>state<span class=H>.</span>lastIdx<span class=E>]<br>    <span class=N>if </span></span>key <span class=N>then<br>        <span class=K>return </span></span>key<span class=O>, </span>state<span class=H>.</span>t<span class=E>[</span>key<span class=E>]<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span>getting here means returning `nil`, which will end the iteration<br><span class=K>end<br><br>local function <span class=C>sortedPairs<span class=E>(</span>tbl<span class=E>)<br>    <span class=U>-- </span></span></span></span>Equivalent of the pairs() function on tables. Allows to iterate in<br>    <span class=U>-- </span>sorted order. As required by &#34;generic for&#34; loops, this will return the<br>    <span class=U>-- </span>iterator (function), an &#34;invariant state&#34;, and the initial control value.<br>    <span class=U>-- </span>(see http://www.lua.org/pil/7.2.html)<br>    <span class=K>return <span class=C>sortedNext<span class=O>, <span class=E>{<span class=P>t <span class=D>= </span></span></span></span>tbl<span class=O>, <span class=P>sortedIdx <span class=D>= </span></span></span>__genSortedIndex<span class=E>(</span>tbl<span class=E>)}<span class=O>, <span class=L>nil<br></span></span></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>sortedPairs <span class=D>= </span>sortedPairs<br><br><span class=U>-- </span></span></span>seed the random with a strongly varying seed<br><span class=C>math<span class=H>.</span>randomseed<span class=E>(</span>math<span class=H>.</span>floor<span class=E>(</span>os<span class=H>.</span>clock<span class=E>()*<span class=M>1<span class=T>E</span>11</span>))<br><br><span class=K>local function </span></span>randomizeTable<span class=E>( </span>t <span class=E>)<br>    <span class=U>-- </span></span></span>randomize the item orders of the table t<br>    <span class=N>for <span class=C>i <span class=D>= <span class=E>#</span></span>t<span class=O>, <span class=M>2</span>, <span class=E>-<span class=M>1 </span></span></span></span>do<br>        <span class=G>local <span class=C>j <span class=D>= </span>math<span class=H>.</span>random<span class=E>(</span>i<span class=E>)<br>        </span></span></span>if <span class=C>i <span class=E>~= </span>j </span>then<br>            <span class=C>t<span class=E>[</span>i<span class=E>]<span class=O>, </span></span>t<span class=E>[</span>j<span class=E>] <span class=D>= </span></span>t<span class=E>[</span>j<span class=E>]<span class=O>, </span></span>t<span class=E>[</span>i<span class=E>]<br>        </span></span>end<br>    end<br><span class=K>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>randomizeTable <span class=D>= </span>randomizeTable<br><br></span>local function <span class=C>strsplit<span class=E>(</span>delimiter<span class=O>, </span>text<span class=E>)<br><span class=U>-- </span></span></span></span></span>Split text into a list consisting of the strings in text, separated<br><span class=U>-- </span>by strings matching delimiter (which may _NOT_ be a pattern).<br><span class=U>-- </span>Example: strsplit(&#34;, &#34;, &#34;Anna, Bob, Charlie, Dolores&#34;)<br>    <span class=N>if <span class=C>delimiter <span class=E>== <span class=B>&#34;&#34; <span class=J>or </span></span></span>delimiter <span class=E>== <span class=L>nil </span></span></span>then <span class=U>-- </span></span>this would result in endless loops<br>        <span class=C>error<span class=E>(<span class=B>&#34;<span class=F>delimiter is nil or empty string!</span>&#34;</span>)<br>    <span class=N>end<br>    if </span></span>text <span class=E>== <span class=L>nil <span class=N>then<br>        <span class=K>return </span></span>nil<br>    <span class=N>end<br><br>    <span class=G>local </span></span></span></span>list<span class=O>, </span>pos<span class=O>, </span>first<span class=O>, </span>last <span class=D>= <span class=E>{}<span class=O>, <span class=M>1<br>    <span class=N>while <span class=L>true </span>do<br>        </span></span></span></span></span>first<span class=O>, </span>last <span class=D>= </span>text<span class=H>:</span>find<span class=E>(</span>delimiter<span class=O>, </span>pos<span class=O>, <span class=L>true<span class=E>)<br>        <span class=N>if </span></span></span></span>first <span class=N>then <span class=U>-- </span></span></span>found?<br>            <span class=C>table<span class=H>.</span>insert<span class=E>(</span>list<span class=O>, </span>text<span class=H>:</span>sub<span class=E>(</span>pos<span class=O>, </span>first <span class=E>- <span class=M>1</span>))<br>            </span>pos <span class=D>= </span>last <span class=E>+ <span class=M>1<br>        <span class=N>else<br>            </span></span></span>table<span class=H>.</span>insert<span class=E>(</span>list<span class=O>, </span>text<span class=H>:</span>sub<span class=E>(</span>pos<span class=E>))<br>            <span class=N>break<br>        end<br>    end<br>    <span class=K>return </span></span></span>list<br><span class=K>end<br></span>M<span class=H>.</span>private<span class=H>.</span>strsplit <span class=D>= </span>strsplit<br><br><span class=K>local function </span>hasNewLine<span class=E>( </span>s <span class=E>)<br>    <span class=U>-- </span></span></span>return true if s has a newline<br>    <span class=K>return <span class=E>(<span class=C>string<span class=H>.</span>find</span>(<span class=C>s<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;</span>, <span class=M>1</span>, <span class=L>true</span></span></span>) ~= <span class=L>nil</span>)<br></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>hasNewLine <span class=D>= </span>hasNewLine<br><br></span>local function <span class=C>prefixString<span class=E>( </span>prefix<span class=O>, </span>s <span class=E>)<br>    <span class=U>-- </span></span></span></span>Prefix all the lines of s with prefix<br>    <span class=K>return <span class=C>prefix <span class=E>.. </span>string<span class=H>.</span>gsub<span class=E>(</span>s<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;</span>, <span class=B>&#39;<span class=F>\n</span>&#39; <span class=E>.. </span></span></span>prefix<span class=E>)<br></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>prefixString <span class=D>= </span>prefixString<br><br></span>local function <span class=C>strMatch<span class=E>(</span>s<span class=O>, </span>pattern<span class=O>, </span>start<span class=O>, </span>final <span class=E>)<br>    <span class=U>-- </span></span></span></span>return true if s matches completely the pattern from index start to index end<br>    <span class=U>-- </span>return false in every other cases<br>    <span class=U>-- </span>if start is nil, matches from the beginning of the string<br>    <span class=U>-- </span>if final is nil, matches to the end of the string<br>    <span class=C>start <span class=D>= </span>start <span class=J>or <span class=M>1<br>    </span></span>final <span class=D>= </span>final <span class=J>or </span>string<span class=H>.</span>len<span class=E>(</span>s<span class=E>)<br><br>    <span class=G>local </span></span>foundStart<span class=O>, </span>foundEnd <span class=D>= </span>string<span class=H>.</span>find<span class=E>(</span>s<span class=O>, </span>pattern<span class=O>, </span>start<span class=O>, <span class=L>false<span class=E>)<br>    <span class=K>return </span></span></span></span>foundStart <span class=E>== </span>start <span class=I>and </span>foundEnd <span class=E>== </span>final<br><span class=K>end<br></span>M<span class=H>.</span>private<span class=H>.</span>strMatch <span class=D>= </span>strMatch<br><br><span class=K>local function </span>patternFilter<span class=E>(</span>patterns<span class=O>, </span>expr<span class=E>)<br>    <span class=U>-- </span></span></span>Run `expr` through the inclusion and exclusion rules defined in patterns<br>    <span class=U>-- </span>and return true if expr shall be included, false for excluded.<br>    <span class=U>-- </span>Inclusion pattern are defined as normal patterns, exclusions <br>    <span class=U>-- </span>patterns start with `!` and are followed by a normal pattern<br><br>    <span class=U>-- </span>result: nil = UNKNOWN (not matched yet), true = ACCEPT, false = REJECT<br>    <span class=U>-- </span>default: true if no explicit &#34;include&#34; is found, set to false otherwise<br>    <span class=G>local <span class=C>default<span class=O>, </span>result <span class=D>= <span class=L>true<span class=O>, </span>nil<br><br>    <span class=N>if </span></span></span>patterns <span class=E>~= <span class=L>nil <span class=N>then<br>        for </span></span></span>_<span class=O>, </span>pattern <span class=N>in </span>ipairs<span class=E>(</span>patterns<span class=E>) <span class=N>do<br>            </span></span></span>local <span class=C>exclude <span class=D>= </span>pattern<span class=H>:</span>sub<span class=E>(<span class=M>1<span class=O>,</span>1</span>) == <span class=B>&#39;<span class=F>!</span>&#39;<br>            <span class=N>if </span></span></span>exclude <span class=N>then<br>                </span>pattern <span class=D>= </span>pattern<span class=H>:</span>sub<span class=E>(<span class=M>2</span>)<br>            <span class=N>else<br>                <span class=U>-- </span></span></span></span></span>at least one include pattern specified, a match is required<br>                <span class=C>default <span class=D>= <span class=L>false<br>            <span class=N>end<br>            <span class=U>-- </span></span></span></span></span>print(&#39;pattern: &#39;,pattern)<br>            <span class=U>-- </span>print(&#39;exclude: &#39;,exclude)<br>            <span class=U>-- </span>print(&#39;default: &#39;,default)<br><br>            <span class=N>if <span class=C>string<span class=H>.</span>find<span class=E>(</span>expr<span class=O>, </span>pattern<span class=E>) </span></span>then<br>                <span class=U>-- </span></span>set result to false when excluding, true otherwise<br>                <span class=C>result <span class=D>= <span class=E>not </span></span>exclude<br>            <span class=N>end<br>        end<br>    end<br><br>    if </span>result <span class=E>~= <span class=L>nil <span class=N>then<br>        <span class=K>return </span></span></span></span>result<br>    <span class=N>end<br>    <span class=K>return </span></span>default<br><span class=K>end<br></span>M<span class=H>.</span>private<span class=H>.</span>patternFilter <span class=D>= </span>patternFilter<br><br><span class=K>local function </span>xmlEscape<span class=E>( </span>s <span class=E>)<br>    <span class=U>-- </span></span></span>Return s escaped for XML attributes<br>    <span class=U>-- </span>escapes table:<br>    <span class=U>-- </span>&#34;   &amp;quot;<br>    <span class=U>-- </span>&#39;   &amp;apos;<br>    <span class=U>-- </span>&lt;   &amp;lt;<br>    <span class=U>-- </span>&gt;   &amp;gt;<br>    <span class=U>-- </span>&amp;   &amp;amp;<br><br>    <span class=K>return <span class=C>string<span class=H>.</span>gsub<span class=E>( </span>s<span class=O>, <span class=B>&#39;<span class=F>.</span>&#39;</span>, <span class=E>{<br>        </span>[<span class=B>&#39;<span class=F>&amp;</span>&#39;</span>] <span class=D>= <span class=B>&#34;<span class=F>&amp;amp;</span>&#34;</span></span>,<br>        [<span class=B>&#39;<span class=F>&#34;</span>&#39;</span>] <span class=D>= <span class=B>&#34;<span class=F>&amp;quot;</span>&#34;</span></span>,<br>        [<span class=B>&#34;<span class=F>&#39;</span>&#34;</span>] <span class=D>= <span class=B>&#34;<span class=F>&amp;apos;</span>&#34;</span></span>,<br>        [<span class=B>&#39;<span class=F>&lt;</span>&#39;</span>] <span class=D>= <span class=B>&#34;<span class=F>&amp;lt;</span>&#34;</span></span>,<br>        [<span class=B>&#39;<span class=F>&gt;</span>&#39;</span>] <span class=D>= <span class=B>&#34;<span class=F>&amp;gt;</span>&#34;</span></span>,<br>    <span class=E>} )<br></span></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>xmlEscape <span class=D>= </span>xmlEscape<br><br></span>local function <span class=C>xmlCDataEscape<span class=E>( </span>s <span class=E>)<br>    <span class=U>-- </span></span></span></span>Return s escaped for CData section, escapes: &#34;]]&gt;&#34;<br>    <span class=K>return <span class=C>string<span class=H>.</span>gsub<span class=E>( </span>s<span class=O>, <span class=B>&#39;<span class=F>]]&gt;</span>&#39;</span>, <span class=B>&#39;<span class=F>]]&amp;gt;</span>&#39; <span class=E>)<br></span></span></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>xmlCDataEscape <span class=D>= </span>xmlCDataEscape<br><br><br></span>local function <span class=C>lstrip<span class=E>( </span>s <span class=E>)<br>    <span class=U>--[[</span></span></span></span>Return s with all leading white spaces and tabs removed<span class=U>]]<br>    <span class=G>local <span class=C>idx <span class=D>= <span class=M>0<br>    <span class=N>while </span></span></span>idx <span class=E>&lt; </span>s<span class=H>:</span>len<span class=E>() <span class=N>do<br>        </span></span>idx <span class=D>= </span>idx <span class=E>+ <span class=M>1<br>        </span></span></span>local <span class=C>c <span class=D>= </span>s<span class=H>:</span>sub<span class=E>(</span>idx<span class=O>,</span>idx<span class=E>)<br>        <span class=N>if </span></span>c <span class=E>~= <span class=B>&#39; &#39; <span class=I>and </span></span></span>c <span class=E>~= <span class=B>&#39;<span class=F>\t</span>&#39; <span class=N>then<br>            break<br>        end<br>    end<br>    <span class=K>return </span></span></span></span>s<span class=H>:</span>sub<span class=E>(</span>idx<span class=E>)<br><span class=K>end<br></span></span>M<span class=H>.</span>private<span class=H>.</span>lstrip <span class=D>= </span>lstrip<br><br><span class=K>local function </span>extractFileLineInfo<span class=E>( </span>s <span class=E>)<br>    </span></span></span>--[[ </span>From a string in the form &#34;(leading spaces) dir1/dir2\dir3\file.lua:linenb: msg&#34;<br><br>    Return the &#34;file.lua:linenb&#34; information<br>    <span class=U>]]<br>    <span class=G>local <span class=C>s2 <span class=D>= </span>lstrip<span class=E>(</span>s<span class=E>)<br>    </span></span>local <span class=C>firstColon <span class=D>= </span>s2<span class=H>:</span>find<span class=E>(<span class=B>&#39;<span class=F>:</span>&#39;<span class=O>, <span class=M>1</span>, <span class=L>true</span></span></span>)<br>    <span class=N>if </span></span>firstColon <span class=E>== <span class=L>nil <span class=N>then<br>        </span></span></span></span></span>-- </span>string is not in the format file:line:<br>        <span class=K>return <span class=C>s<br>    <span class=N>end<br>    <span class=G>local </span></span>secondColon <span class=D>= </span>s2<span class=H>:</span>find<span class=E>(<span class=B>&#39;<span class=F>:</span>&#39;<span class=O>, </span></span></span>firstColon<span class=E>+<span class=M>1<span class=O>, <span class=L>true</span></span></span>)<br>    <span class=N>if </span></span>secondColon <span class=E>== <span class=L>nil <span class=N>then<br>        <span class=U>-- </span></span></span></span></span></span>string is not in the format file:line:<br>        <span class=K>return <span class=C>s<br>    <span class=N>end<br><br>    </span></span>return <span class=C>s2<span class=H>:</span>sub<span class=E>(<span class=M>1<span class=O>, </span></span></span>secondColon<span class=E>-<span class=M>1</span>) <br></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>extractFileLineInfo <span class=D>= </span>extractFileLineInfo<br><br><br></span>local function <span class=C>stripLuaunitTrace2<span class=E>( </span>stackTrace<span class=O>, </span>errMsg <span class=E>)<br>    <span class=U>--[[<br>    </span></span></span></span>-- Example of  a traceback:<br>    &lt;&lt;stack traceback:<br>        example_with_luaunit.lua:130: in function &#39;test2_withFailure&#39;<br>        ./luaunit.lua:1449: in function &lt;./luaunit.lua:1449&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        ./luaunit.lua:1449: in function &#39;protectedCall&#39;<br>        ./luaunit.lua:1508: in function &#39;execOneFunction&#39;<br>        ./luaunit.lua:1596: in function &#39;runSuiteByInstances&#39;<br>        ./luaunit.lua:1660: in function &#39;runSuiteByNames&#39;<br>        ./luaunit.lua:1736: in function &#39;runSuite&#39;<br>        example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;example_with_luaunit.lua:130: expected 2, got 1&gt;&gt;<br><br>        Other example:<br>    &lt;&lt;stack traceback:<br>        ./luaunit.lua:545: in function &#39;assertEquals&#39;<br>        example_with_luaunit.lua:58: in function &#39;TestToto.test7&#39;<br>        ./luaunit.lua:1517: in function &lt;./luaunit.lua:1517&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        ./luaunit.lua:1517: in function &#39;protectedCall&#39;<br>        ./luaunit.lua:1578: in function &#39;execOneFunction&#39;<br>        ./luaunit.lua:1677: in function &#39;runSuiteByInstances&#39;<br>        ./luaunit.lua:1730: in function &#39;runSuiteByNames&#39;<br>        ./luaunit.lua:1806: in function &#39;runSuite&#39;<br>        example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;example_with_luaunit.lua:58:  expected 2, got 1&gt;&gt;<br><br>    &lt;&lt;stack traceback:<br>        luaunit2/example_with_luaunit.lua:124: in function &#39;test1_withFailure&#39;<br>        luaunit2/luaunit.lua:1532: in function &lt;luaunit2/luaunit.lua:1532&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        luaunit2/luaunit.lua:1532: in function &#39;protectedCall&#39;<br>        luaunit2/luaunit.lua:1591: in function &#39;execOneFunction&#39;<br>        luaunit2/luaunit.lua:1679: in function &#39;runSuiteByInstances&#39;<br>        luaunit2/luaunit.lua:1743: in function &#39;runSuiteByNames&#39;<br>        luaunit2/luaunit.lua:1819: in function &#39;runSuite&#39;<br>        luaunit2/example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;luaunit2/example_with_luaunit.lua:124:  expected 2, got 1&gt;&gt;<br><br><br>    -- first line is &#34;stack traceback&#34;: KEEP<br>    -- next line may be luaunit line: REMOVE<br>    -- next lines are call in the program under testOk: REMOVE<br>    -- next lines are calls from luaunit to call the program under test: KEEP<br><br>    -- Strategy:<br>    -- keep first line<br>    -- remove lines that are part of luaunit<br>    -- kepp lines until we hit a luaunit line<br><br>    The strategy for stripping is:<br>    * keep first line &#34;stack traceback:&#34;<br>    * part1:<br>        * analyse all lines of the stack from bottom to top of the stack (first line to last line)<br>        * extract the &#34;file:line:&#34; part of the line<br>        * compare it with the &#34;file:line&#34; part of the error message<br>        * if it does not match strip the line<br>        * if it matches, keep the line and move to part 2<br>    * part2:<br>        * anything NOT starting with luaunit.lua is the interesting part of the stack trace<br>        * anything starting again with luaunit.lua is part of the test launcher and should be stripped out<br>    <span class=U>]]<br><br>    <span class=K>local function <span class=C>isLuaunitInternalLine<span class=E>( </span>s <span class=E>)<br>        </span></span></span>-- </span>return true if line of stack trace comes from inside luaunit<br>        <span class=K>return <span class=C>s<span class=H>:</span>find<span class=E>(<span class=B>&#39;<span class=F>[/\\]luaunit%.lua:%d+: </span>&#39;</span>) ~= <span class=L>nil<br>    </span></span></span>end<br><br>    <span class=U>-- </span></span>print( &#39;&lt;&lt;&#39;..stackTrace..&#39;&gt;&gt;&#39; )<br><br>    <span class=G>local <span class=C>t <span class=D>= </span>strsplit<span class=E>( <span class=B>&#39;<span class=F>\n</span>&#39;<span class=O>, </span></span></span>stackTrace <span class=E>)<br>    <span class=U>-- </span></span></span></span>print( prettystr(t) )<br><br>    <span class=G>local <span class=C>idx <span class=D>= <span class=M>2<br><br>    </span></span></span>local <span class=C>errMsgFileLine <span class=D>= </span>extractFileLineInfo<span class=E>(</span>errMsg<span class=E>)<br>    <span class=U>-- </span></span></span></span>print(&#39;emfi=&#34;&#39;..errMsgFileLine..&#39;&#34;&#39;)<br><br>    <span class=U>-- </span>remove lines that are still part of luaunit<br>    <span class=N>while <span class=C>t<span class=E>[</span>idx<span class=E>] <span class=I>and </span></span>extractFileLineInfo<span class=E>(</span>t<span class=E>[</span>idx<span class=E>]) ~= </span>errMsgFileLine </span>do<br>        <span class=U>-- </span></span>print(&#39;Removing : &#39;..t[idx] )<br>        <span class=C>table<span class=H>.</span>remove<span class=E>(</span>t<span class=O>, </span>idx<span class=E>)<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span>keep lines until we hit luaunit again<br>    <span class=N>while <span class=C>t<span class=E>[</span>idx<span class=E>] <span class=I>and </span>(not </span>isLuaunitInternalLine<span class=E>(</span>t<span class=E>[</span>idx<span class=E>])) </span></span>do<br>        <span class=U>-- </span></span>print(&#39;Keeping : &#39;..t[idx] )<br>        <span class=C>idx <span class=D>= </span>idx <span class=E>+ <span class=M>1<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span></span>remove remaining luaunit lines<br>    <span class=N>while <span class=C>t<span class=E>[</span>idx<span class=E>] </span></span>do<br>        <span class=U>-- </span></span>print(&#39;Removing2 : &#39;..t[idx] )<br>        <span class=C>table<span class=H>.</span>remove<span class=E>(</span>t<span class=O>, </span>idx<span class=E>)<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span>print( prettystr(t) )<br>    <span class=K>return <span class=C>table<span class=H>.</span>concat<span class=E>( </span>t<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br><br></span></span></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>stripLuaunitTrace2 <span class=D>= </span>stripLuaunitTrace2<br><br><br></span>local function <span class=C>prettystr_sub<span class=E>(</span>v<span class=O>, </span>indentLevel<span class=O>, </span>printTableRefs<span class=O>, </span>cycleDetectTable <span class=E>)<br>    <span class=G>local </span></span>type_v <span class=D>= </span>type<span class=E>(</span>v<span class=E>)<br>    <span class=N>if <span class=B>&#34;<span class=F>string</span>&#34; </span></span>== </span>type_v  <span class=N>then<br>        <span class=U>-- </span></span></span></span>use clever delimiters according to content:<br>        <span class=U>-- </span>enclose with single quotes if string contains &#34;, but no &#39;<br>        <span class=N>if <span class=C>v<span class=H>:</span>find<span class=E>(<span class=B>&#39;<span class=F>&#34;</span>&#39;<span class=O>, <span class=M>1</span>, <span class=L>true</span></span></span>) <span class=I>and </span>not </span>v<span class=H>:</span>find<span class=E>(<span class=B>&#34;<span class=F>&#39;</span>&#34;<span class=O>, <span class=M>1</span>, <span class=L>true</span></span></span>) </span></span>then<br>            <span class=K>return <span class=B>&#34;<span class=F>&#39;</span>&#34; <span class=E>.. <span class=C>v </span>.. </span>&#34;<span class=F>&#39;</span>&#34;<br>        </span></span>end<br>        <span class=U>-- </span></span>use double quotes otherwise, escape embedded &#34;<br>        <span class=K>return <span class=B>&#39;<span class=F>&#34;</span>&#39; <span class=E>.. <span class=C>v<span class=H>:</span>gsub</span>(</span>&#39;<span class=F>&#34;</span>&#39;<span class=O>, </span>&#39;<span class=F>\\&#34;</span>&#39;<span class=E>) .. </span>&#39;<span class=F>&#34;</span>&#39;<br><br>    <span class=N>elseif </span>&#34;<span class=F>table</span>&#34; <span class=E>== <span class=C>type_v <span class=N>then<br>        <span class=U>--</span></span></span></span></span></span>if v.__class__ then<br>        <span class=U>--    </span>return string.gsub( tostring(v), &#39;table&#39;, v.__class__ )<br>        <span class=U>--</span>end<br>        <span class=K>return <span class=C>M<span class=H>.</span>private<span class=H>.</span>_table_tostring<span class=E>(</span>v<span class=O>, </span>indentLevel<span class=O>, </span>printTableRefs<span class=O>, </span>cycleDetectTable<span class=E>)<br><br>    <span class=N>elseif <span class=B>&#34;<span class=F>number</span>&#34; </span></span>== </span>type_v <span class=N>then<br>        <span class=U>-- </span></span></span></span>eliminate differences in formatting between various Lua versions<br>        <span class=N>if <span class=C>v <span class=E>~= </span>v </span>then<br>            <span class=K>return <span class=B>&#34;<span class=F>#NaN</span>&#34; <span class=U>-- </span></span></span></span>&#34;not a number&#34;<br>        <span class=N>end<br>        if <span class=C>v <span class=E>== </span>math<span class=H>.</span>huge </span>then<br>            <span class=K>return <span class=B>&#34;<span class=F>#Inf</span>&#34; <span class=U>-- </span></span></span></span>&#34;infinite&#34;<br>        <span class=N>end<br>        if <span class=C>v <span class=E>== -</span>math<span class=H>.</span>huge </span>then<br>            <span class=K>return <span class=B>&#34;<span class=F>-#Inf</span>&#34;<br>        </span></span>end<br>        if <span class=C>_VERSION <span class=E>== <span class=B>&#34;<span class=F>Lua 5.3</span>&#34; </span></span></span>then<br>            <span class=G>local <span class=C>i <span class=D>= </span>math<span class=H>.</span>tointeger<span class=E>(</span>v<span class=E>)<br>            </span></span></span>if <span class=C>i </span>then<br>                <span class=K>return <span class=C>tostring<span class=E>(</span>i<span class=E>)<br>            </span></span></span>end<br>        end<br>    end<br><br>    <span class=K>return <span class=C>tostring<span class=E>(</span>v<span class=E>)<br></span></span>end<br><br>local function <span class=C>prettystr<span class=E>( </span>v <span class=E>)<br>    <span class=U>--[[ </span></span></span></span></span>Pretty string conversion, to display the full content of a variable of any type.<br><br>    * string are enclosed with &#34; by default, or with &#39; if string contains a &#34;<br>    * tables are expanded to show their full content, with indentation in case of nested tables<br>    <span class=U>]]--<br>    <span class=G>local <span class=C>cycleDetectTable <span class=D>= <span class=E>{}<br>    </span></span></span>local <span class=C>s <span class=D>= </span>prettystr_sub<span class=E>(</span>v<span class=O>, <span class=M>1</span>, </span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG<span class=O>, </span>cycleDetectTable<span class=E>)<br>    <span class=N>if </span></span>cycleDetectTable<span class=H>.</span>detected <span class=I>and <span class=E>not </span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=N>then<br>        </span></span></span>-- </span>some table contain recursive references,<br>        <span class=U>-- </span>so we must recompute the value by including all table references<br>        <span class=U>-- </span>else the result looks like crap<br>        <span class=C>cycleDetectTable <span class=D>= <span class=E>{}<br>        </span></span>s <span class=D>= </span>prettystr_sub<span class=E>(</span>v<span class=O>, <span class=M>1</span>, <span class=L>true</span>, </span>cycleDetectTable<span class=E>)<br>    <span class=N>end<br>    <span class=K>return </span></span></span>s<br><span class=K>end<br></span>M<span class=H>.</span>prettystr <span class=D>= </span>prettystr<br><br><span class=K>function </span>M.adjust_err_msg_with_iter<span class=E>( </span>err_msg<span class=O>, </span>iter_msg <span class=E>)<br>    <span class=U>--[[ </span></span></span>Adjust the error message err_msg: trim the FAILURE_PREFIX or SUCCESS_PREFIX information if needed, <br>    add the iteration message if any and return the result.<br><br>    err_msg:  string, error message captured with pcall<br>    iter_msg: a string describing the current iteration (&#34;iteration N&#34;) or nil<br>              if there is no iteration in this test.<br><br>    Returns: (new_err_msg, test_status)<br>        new_err_msg: string, adjusted error message, or nil in case of success<br>        test_status: M.NodeStatus.FAIL, SUCCESS or ERROR according to the information<br>                     contained in the error message.<br>    <span class=U>]]<br>    <span class=N>if <span class=C>iter_msg </span>then<br>        <span class=C>iter_msg <span class=D>= </span>iter_msg<span class=E>..<span class=B>&#39;<span class=F>, </span>&#39;<br>    </span></span></span>else<br>        <span class=C>iter_msg <span class=D>= <span class=B>&#39;&#39;<br>    </span></span></span>end<br><br>    <span class=G>local <span class=C>RE_FILE_LINE <span class=D>= <span class=B>&#39;<span class=F>.*:%d+: </span>&#39;<br><br>    </span></span></span></span></span>-- </span>error message is not necessarily a string, <br>    <span class=U>-- </span>so convert the value to string with prettystr()<br>    <span class=N>if <span class=C>type<span class=E>( </span>err_msg <span class=E>) ~= <span class=B>&#39;<span class=F>string</span>&#39; </span></span></span>then<br>        <span class=C>err_msg <span class=D>= </span>prettystr<span class=E>( </span>err_msg <span class=E>)<br>    </span></span>end<br><br>    if <span class=E>(<span class=C>err_msg<span class=H>:</span>find</span>( <span class=C>M<span class=H>.</span>SUCCESS_PREFIX </span>) == <span class=M>1</span>) <span class=J>or <span class=C>err_msg<span class=H>:</span>match</span></span>( <span class=B>&#39;<span class=F>(</span>&#39;</span>..<span class=C>RE_FILE_LINE</span>..<span class=B>&#39;<span class=F>)</span>&#39; </span>.. <span class=C>M<span class=H>.</span>SUCCESS_PREFIX </span>.. <span class=B>&#34;<span class=F>.*</span>&#34; </span>) </span>then<br>        <span class=U>-- </span></span>test finished early with success()<br>        <span class=K>return <span class=L>nil<span class=O>, <span class=C>M<span class=H>.</span>NodeStatus<span class=H>.</span>SUCCESS<br>    <span class=N>end<br><br>    if <span class=E>(</span></span>err_msg<span class=H>:</span>find<span class=E>( </span>M<span class=H>.</span>SKIP_PREFIX <span class=E>) == <span class=M>1</span>) <span class=J>or </span>(</span>err_msg<span class=H>:</span>match<span class=E>( <span class=B>&#39;<span class=F>(</span>&#39;</span>..</span>RE_FILE_LINE<span class=E>..<span class=B>&#39;<span class=F>)</span>&#39; </span>.. </span>M<span class=H>.</span>SKIP_PREFIX <span class=E>.. <span class=B>&#34;<span class=F>.*</span>&#34; </span>) ~= </span></span></span>nil<span class=E>) <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>substitute prefix by iteration message<br>        <span class=C>err_msg <span class=D>= </span>err_msg<span class=H>:</span>gsub<span class=E>(<span class=B>&#39;<span class=F>.*</span>&#39;</span>..</span>M<span class=H>.</span>SKIP_PREFIX<span class=O>, </span>iter_msg<span class=O>, <span class=M>1<span class=E>)<br>        <span class=U>-- </span></span></span></span></span>print(&#34;failure detected&#34;)<br>        <span class=K>return <span class=C>err_msg<span class=O>, </span>M<span class=H>.</span>NodeStatus<span class=H>.</span>SKIP<br>    <span class=N>end<br><br>    if <span class=E>(</span></span>err_msg<span class=H>:</span>find<span class=E>( </span>M<span class=H>.</span>FAILURE_PREFIX <span class=E>) == <span class=M>1</span>) <span class=J>or </span>(</span>err_msg<span class=H>:</span>match<span class=E>( <span class=B>&#39;<span class=F>(</span>&#39;</span>..</span>RE_FILE_LINE<span class=E>..<span class=B>&#39;<span class=F>)</span>&#39; </span>.. </span>M<span class=H>.</span>FAILURE_PREFIX <span class=E>.. <span class=B>&#34;<span class=F>.*</span>&#34; </span>) ~= <span class=L>nil</span>) <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>substitute prefix by iteration message<br>        <span class=C>err_msg <span class=D>= </span>err_msg<span class=H>:</span>gsub<span class=E>(</span>M<span class=H>.</span>FAILURE_PREFIX<span class=O>, </span>iter_msg<span class=O>, <span class=M>1<span class=E>)<br>        <span class=U>-- </span></span></span></span></span>print(&#34;failure detected&#34;)<br>        <span class=K>return <span class=C>err_msg<span class=O>, </span>M<span class=H>.</span>NodeStatus<span class=H>.</span>FAIL<br>    <span class=N>end<br><br><br><br>    <span class=U>-- </span></span></span></span>print(&#34;error detected&#34;)<br>    <span class=U>-- </span>regular error, not a failure<br>    <span class=N>if <span class=C>iter_msg </span>then<br>        <span class=G>local <span class=C>match<br>        <span class=U>-- </span></span></span></span>&#34;./test\\test_luaunit.lua:2241: some error msg<br>        <span class=C>match <span class=D>= </span>err_msg<span class=H>:</span>match<span class=E>( <span class=B>&#39;<span class=F>(.*:%d+: ).*</span>&#39; </span>) <br>        <span class=N>if </span></span>match <span class=N>then<br>            </span>err_msg <span class=D>= </span>err_msg<span class=H>:</span>gsub<span class=E>( </span>match<span class=O>, </span>match <span class=E>.. </span>iter_msg <span class=E>)<br>        <span class=N>else<br>            <span class=U>-- </span></span></span></span>no file:line: infromation, just add the iteration info at the beginning of the line<br>            <span class=C>err_msg <span class=D>= </span>iter_msg <span class=E>.. </span>err_msg<br>        <span class=N>end<br>    end<br>    <span class=K>return </span></span>err_msg<span class=O>, </span>M<span class=H>.</span>NodeStatus<span class=H>.</span>ERROR<br><span class=K>end<br><br>local function </span>tryMismatchFormatting<span class=E>( </span>table_a<span class=O>, </span>table_b<span class=O>, </span>doDeepAnalysis<span class=O>, </span>margin <span class=E>)<br>    <span class=U>--[[<br>    </span></span></span>Prepares a nice error message when comparing tables, performing a deeper <br>    analysis.<br><br>    Arguments:<br>    * table_a, table_b: tables to be compared<br>    * doDeepAnalysis:<br>        M.DEFAULT_DEEP_ANALYSIS: (the default if not specified) perform deep analysis only for big lists and big dictionnaries<br>        M.FORCE_DEEP_ANALYSIS  : always perform deep analysis<br>        M.DISABLE_DEEP_ANALYSIS: never perform deep analysis<br>    * margin: supplied only for almost equality<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    <span class=U>]]<br><br>    -- </span>check if table_a &amp; table_b are suitable for deep analysis<br>    <span class=N>if <span class=C>type<span class=E>(</span>table_a<span class=E>) ~= <span class=B>&#39;<span class=F>table</span>&#39; <span class=J>or </span></span></span>type<span class=E>(</span>table_b<span class=E>) ~= <span class=B>&#39;<span class=F>table</span>&#39; </span></span></span>then<br>        <span class=K>return <span class=L>false<br>    </span></span>end<br><br>    if <span class=C>doDeepAnalysis <span class=E>== </span>M<span class=H>.</span>DISABLE_DEEP_ANALYSIS </span>then<br>        <span class=K>return <span class=L>false<br>    </span></span>end<br><br>    <span class=G>local <span class=C>len_a<span class=O>, </span>len_b<span class=O>, </span>isPureList <span class=D>= <span class=E>#</span></span>table_a<span class=O>, <span class=E>#</span></span>table_b<span class=O>, <span class=L>true<br><br>    </span></span></span></span>for <span class=C>k1<span class=O>, </span>v1 </span>in <span class=C>pairs<span class=E>(</span>table_a<span class=E>) </span></span>do<br>        if <span class=C>type<span class=E>(</span>k1<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>k1 <span class=E>&gt; </span>len_a </span>then<br>            <span class=U>-- </span></span>this table a mapping<br>            <span class=C>isPureList <span class=D>= <span class=L>false<br>            <span class=N>break<br>        end<br>    end<br><br>    if </span></span></span>isPureList <span class=N>then<br>        for </span>k2<span class=O>, </span>v2 <span class=N>in </span>pairs<span class=E>(</span>table_b<span class=E>) <span class=N>do<br>            if </span></span>type<span class=E>(</span>k2<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>k2 <span class=E>&gt; </span>len_b <span class=N>then<br>                <span class=U>-- </span></span></span>this table a mapping<br>                <span class=C>isPureList <span class=D>= <span class=L>false<br>                <span class=N>break<br>            end<br>        end<br>    end<br><br>    if </span></span></span>isPureList <span class=I>and </span>math<span class=H>.</span>min<span class=E>(</span>len_a<span class=O>, </span>len_b<span class=E>) &lt; </span>M<span class=H>.</span>LIST_DIFF_ANALYSIS_THRESHOLD <span class=N>then<br>        if <span class=E>not (</span></span>doDeepAnalysis <span class=E>== </span>M<span class=H>.</span>FORCE_DEEP_ANALYSIS<span class=E>) <span class=N>then<br>            <span class=K>return <span class=L>false<br>        </span></span>end<br>    end<br><br>    if </span></span>isPureList <span class=N>then<br>        <span class=K>return </span></span>M<span class=H>.</span>private<span class=H>.</span>mismatchFormattingPureList<span class=E>( </span>table_a<span class=O>, </span>table_b<span class=O>, </span>margin <span class=E>)<br>    <span class=N>else<br>        <span class=U>-- </span></span></span></span>only work on mapping for the moment<br>        <span class=U>-- </span>return M.private.mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )<br>        <span class=K>return <span class=L>false<br>    <span class=N>end<br></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>tryMismatchFormatting <span class=D>= </span>tryMismatchFormatting<br><br></span>local function <span class=C>getTaTbDescr<span class=E>()<br>    <span class=N>if </span>not </span>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED <span class=N>then<br>        </span></span>return <span class=B>&#39;<span class=F>expected</span>&#39;<span class=O>, </span>&#39;<span class=F>actual</span>&#39;<br>    <span class=N>end<br>    </span></span>return <span class=B>&#39;<span class=F>actual</span>&#39;<span class=O>, </span>&#39;<span class=F>expected</span>&#39;<br></span>end<br><br>local function <span class=C>extendWithStrFmt<span class=E>( </span>res<span class=O>, ... <span class=E>)<br>    </span></span>table<span class=H>.</span>insert<span class=E>( </span>res<span class=O>, </span>string<span class=H>.</span>format<span class=E>( <span class=O>... </span>) )<br></span></span>end<br><br>local function <span class=C>mismatchFormattingMapping<span class=E>( </span>table_a<span class=O>, </span>table_b<span class=O>, </span>doDeepAnalysis <span class=E>)<br>    <span class=U>--[[<br>    </span></span></span></span>Prepares a nice error message when comparing tables which are not pure lists, performing a deeper <br>    analysis.<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    <span class=U>]]<br><br>    -- </span>disable for the moment<br>    <span class=U>--[[<br>    </span>local result = {}<br>    local descrTa, descrTb = getTaTbDescr()<br><br>    local keysCommon = {}<br>    local keysOnlyTa = {}<br>    local keysOnlyTb = {}<br>    local keysDiffTaTb = {}<br><br>    local k, v<br><br>    for k,v in pairs( table_a ) do<br>        if is_equal( v, table_b[k] ) then<br>            table.insert( keysCommon, k )<br>        else <br>            if table_b[k] == nil then<br>                table.insert( keysOnlyTa, k )<br>            else<br>                table.insert( keysDiffTaTb, k )<br>            end<br>        end<br>    end<br><br>    for k,v in pairs( table_b ) do<br>        if not is_equal( v, table_a[k] ) and table_a[k] == nil then<br>            table.insert( keysOnlyTb, k )<br>        end<br>    end<br><br>    local len_a = #keysCommon + #keysDiffTaTb + #keysOnlyTa<br>    local len_b = #keysCommon + #keysDiffTaTb + #keysOnlyTb<br>    local limited_display = (len_a &lt; 5 or len_b &lt; 5)<br><br>    if math.min(len_a, len_b) &lt; M.TABLE_DIFF_ANALYSIS_THRESHOLD then<br>        return false<br>    end<br><br>    if not limited_display then<br>        if len_a == len_b then<br>            extendWithStrFmt( result, &#39;Table A (%s) and B (%s) both have %d items&#39;, descrTa, descrTb, len_a )<br>        else<br>            extendWithStrFmt( result, &#39;Table A (%s) has %d items and table B (%s) has %d items&#39;, descrTa, len_a, descrTb, len_b )<br>            end<br><br>        if #keysCommon == 0 and #keysDiffTaTb == 0 then<br>            table.insert( result, &#39;Table A and B have no keys in common, they are totally different&#39;)<br>        else<br>            local s_other = &#39;other &#39;<br>            if #keysCommon then<br>                extendWithStrFmt( result, &#39;Table A and B have %d identical items&#39;, #keysCommon )<br>            else<br>                table.insert( result, &#39;Table A and B have no identical items&#39; )<br>                s_other = &#39;&#39;<br>            end<br><br>            if #keysDiffTaTb ~= 0 then<br>                result[#result] = string.format( &#39;%s and %d items differing present in both tables&#39;, result[#result], #keysDiffTaTb)<br>            else<br>                result[#result] = string.format( &#39;%s and no %sitems differing present in both tables&#39;, result[#result], s_other, #keysDiffTaTb)<br>            end<br>        end<br><br>        extendWithStrFmt( result, &#39;Table A has %d keys not present in table B and table B has %d keys not present in table A&#39;, #keysOnlyTa, #keysOnlyTb ) <br>    end<br><br>    local function keytostring(k)<br>        if &#34;string&#34; == type(k) and k:match(&#34;^[_%a][_%w]*$&#34;) then<br>            return k<br>        end<br>        return prettystr(k)<br>    end<br><br>    if #keysDiffTaTb ~= 0 then<br>        table.insert( result, &#39;Items differing in A and B:&#39;)<br>        for k,v in sortedPairs( keysDiffTaTb ) do<br>            extendWithStrFmt( result, &#39;  - A[%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>            extendWithStrFmt( result, &#39;  + B[%s]: %s&#39;, keytostring(v), prettystr(table_b[v]) )<br>        end<br>    end    <br><br>    if #keysOnlyTa ~= 0 then<br>        table.insert( result, &#39;Items only in table A:&#39; )<br>        for k,v in sortedPairs( keysOnlyTa ) do<br>            extendWithStrFmt( result, &#39;  - A[%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>        end<br>    end<br><br>    if #keysOnlyTb ~= 0 then<br>        table.insert( result, &#39;Items only in table B:&#39; )<br>        for k,v in sortedPairs( keysOnlyTb ) do<br>            extendWithStrFmt( result, &#39;  + B[%s]: %s&#39;, keytostring(v), prettystr(table_b[v]) )<br>        end<br>    end<br><br>    if #keysCommon ~= 0 then<br>        table.insert( result, &#39;Items common to A and B:&#39;)<br>        for k,v in sortedPairs( keysCommon ) do<br>            extendWithStrFmt( result, &#39;  = A and B [%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>        end<br>    end    <br><br>    return true, table.concat( result, &#39;\n&#39;)<br>    <span class=U>]]<br><span class=K>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>mismatchFormattingMapping <span class=D>= </span>mismatchFormattingMapping<br><br></span>local function <span class=C>mismatchFormattingPureList<span class=E>( </span>table_a<span class=O>, </span>table_b<span class=O>, </span>margin <span class=E>)<br>    </span></span></span>--[[<br>    </span>Prepares a nice error message when comparing tables which are lists, performing a deeper <br>    analysis.<br><br>    margin is supplied only for almost equality<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    <span class=U>]]<br>    <span class=G>local <span class=C>result<span class=O>, </span>descrTa<span class=O>, </span>descrTb <span class=D>= <span class=E>{}<span class=O>, </span></span></span>getTaTbDescr<span class=E>()<br><br>    </span></span>local <span class=C>len_a<span class=O>, </span>len_b<span class=O>, </span>refa<span class=O>, </span>refb <span class=D>= <span class=E>#</span></span>table_a<span class=O>, <span class=E>#</span></span>table_b<span class=O>, <span class=B>&#39;&#39;</span>, <span class=B>&#39;&#39;<br>    <span class=N>if </span></span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=N>then<br>        </span>refa<span class=O>, </span>refb <span class=D>= </span>string<span class=H>.</span>format<span class=E>( <span class=B>&#39;<span class=F>&lt;%s&gt; </span>&#39;<span class=O>, </span></span></span>M<span class=H>.</span>private<span class=H>.</span>table_ref<span class=E>(</span>table_a<span class=E>))<span class=O>, </span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;<span class=F>&lt;%s&gt; </span>&#39;<span class=O>, </span></span></span>M<span class=H>.</span>private<span class=H>.</span>table_ref<span class=E>(</span>table_b<span class=E>) )<br>    <span class=N>end<br>    </span></span></span>local <span class=C>longest<span class=O>, </span>shortest <span class=D>= </span>math<span class=H>.</span>max<span class=E>(</span>len_a<span class=O>, </span>len_b<span class=E>)<span class=O>, </span></span>math<span class=H>.</span>min<span class=E>(</span>len_a<span class=O>, </span>len_b<span class=E>)<br>    </span></span>local <span class=C>deltalv  <span class=D>= </span>longest <span class=E>- </span>shortest<br><br>    </span>local <span class=C>commonUntil <span class=D>= </span>shortest<br>    <span class=N>for </span>i <span class=D>= <span class=M>1<span class=O>, </span></span></span>shortest <span class=N>do<br>        if <span class=E>not </span></span>M<span class=H>.</span>private<span class=H>.</span>is_table_equals<span class=E>(</span>table_a<span class=E>[</span>i<span class=E>]<span class=O>, </span></span>table_b<span class=E>[</span>i<span class=E>]<span class=O>, </span></span>margin<span class=E>) <span class=N>then<br>            </span></span>commonUntil <span class=D>= </span>i <span class=E>- <span class=M>1<br>            <span class=N>break<br>        end<br>    end<br><br>    </span></span></span></span>local <span class=C>commonBackTo <span class=D>= </span>shortest <span class=E>- <span class=M>1<br>    <span class=N>for </span></span></span>i <span class=D>= <span class=M>0<span class=O>, </span></span></span>shortest <span class=E>- <span class=M>1 <span class=N>do<br>        if </span></span>not </span>M<span class=H>.</span>private<span class=H>.</span>is_table_equals<span class=E>(</span>table_a<span class=E>[</span>len_a<span class=E>-</span>i<span class=E>]<span class=O>, </span></span>table_b<span class=E>[</span>len_b<span class=E>-</span>i<span class=E>]<span class=O>, </span></span>margin<span class=E>) <span class=N>then<br>            </span></span>commonBackTo <span class=D>= </span>i <span class=E>- <span class=M>1<br>            <span class=N>break<br>        end<br>    end<br><br><br>    </span></span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>List difference analysis:</span>&#39; <span class=E>)    <br>    <span class=N>if </span></span></span></span>len_a <span class=E>== </span>len_b <span class=N>then<br>        </span></span></span>-- </span>TODO: handle expected/actual naming<br>        <span class=C>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* lists %sA (%s) and %sB (%s) have the same size</span>&#39;</span>, </span>refa<span class=O>, </span>descrTa<span class=O>, </span>refb<span class=O>, </span>descrTb <span class=E>)<br>    <span class=N>else <br>        </span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* list sizes differ: list %sA (%s) has %d items, list %sB (%s) has %d items</span>&#39;</span>, </span>refa<span class=O>, </span>descrTa<span class=O>, </span>len_a<span class=O>, </span>refb<span class=O>, </span>descrTb<span class=O>, </span>len_b <span class=E>)<br>    <span class=N>end<br><br>    </span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* lists A and B start differing at index %d</span>&#39;</span>, </span>commonUntil<span class=E>+<span class=M>1 </span>) <br>    <span class=N>if </span></span>commonBackTo <span class=E>&gt;= <span class=M>0 <span class=N>then<br>        if </span></span></span>deltalv <span class=E>&gt; <span class=M>0 <span class=N>then<br>            </span></span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* lists A and B are equal again from index %d for A, %d for B</span>&#39;</span>, </span>len_a<span class=E>-</span>commonBackTo<span class=O>, </span>len_b<span class=E>-</span>commonBackTo <span class=E>)<br>        <span class=N>else<br>            </span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* lists A and B are equal again from index %d</span>&#39;</span>, </span>len_a<span class=E>-</span>commonBackTo <span class=E>)<br>        <span class=N>end<br>    end<br><br>    <span class=K>local function </span></span></span>insertABValue<span class=E>(</span>ai<span class=O>, </span>bi<span class=E>)<br>        </span>bi <span class=D>= </span>bi <span class=J>or </span>ai<br>        <span class=N>if </span>M<span class=H>.</span>private<span class=H>.</span>is_table_equals<span class=E>( </span>table_a<span class=E>[</span>ai<span class=E>]<span class=O>, </span></span>table_b<span class=E>[</span>bi<span class=E>]<span class=O>, </span></span>margin<span class=E>) <span class=N>then<br>            <span class=K>return </span></span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;  <span class=F>= A[%d], B[%d]: %s</span>&#39;</span>, </span>ai<span class=O>, </span>bi<span class=O>, </span>prettystr<span class=E>(</span>table_a<span class=E>[</span>ai<span class=E>]) )<br>        <span class=N>else<br>            </span></span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;  <span class=F>- A[%d]: %s</span>&#39;</span>, </span>ai<span class=O>, </span>prettystr<span class=E>(</span>table_a<span class=E>[</span>ai<span class=E>]))<br>            </span>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;  <span class=F>+ B[%d]: %s</span>&#39;</span>, </span>bi<span class=O>, </span>prettystr<span class=E>(</span>table_b<span class=E>[</span>bi<span class=E>]))<br>        <span class=N>end<br>    <span class=K>end<br><br>    <span class=U>-- </span></span></span></span></span>common parts to list A &amp; B, at the beginning<br>    <span class=N>if <span class=C>commonUntil <span class=E>&gt; <span class=M>0 </span></span></span>then<br>        <span class=C>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* Common parts:</span>&#39; <span class=E>)<br>        </span></span></span></span>for <span class=C>i <span class=D>= <span class=M>1<span class=O>, </span></span></span>commonUntil </span>do<br>            <span class=C>insertABValue<span class=E>( </span>i <span class=E>)<br>        </span></span>end<br>    end<br><br>    <span class=U>-- </span></span>diffing parts to list A &amp; B<br>    <span class=N>if <span class=C>commonUntil <span class=E>&lt; </span>shortest <span class=E>- </span>commonBackTo <span class=E>- <span class=M>1 </span></span></span>then<br>        <span class=C>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* Differing parts:</span>&#39; <span class=E>)<br>        </span></span></span></span>for <span class=C>i <span class=D>= </span>commonUntil <span class=E>+ <span class=M>1<span class=O>, </span></span></span>shortest <span class=E>- </span>commonBackTo <span class=E>- <span class=M>1 </span></span></span>do<br>            <span class=C>insertABValue<span class=E>( </span>i <span class=E>)<br>        </span></span>end<br>    end<br><br>    <span class=U>-- </span></span>display indexes of one list, with no match on other list<br>    <span class=N>if <span class=C>shortest <span class=E>- </span>commonBackTo <span class=E>&lt;= </span>longest <span class=E>- </span>commonBackTo <span class=E>- <span class=M>1 </span></span></span>then<br>        <span class=C>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* Present only in one list:</span>&#39; <span class=E>)<br>        </span></span></span></span>for <span class=C>i <span class=D>= </span>shortest <span class=E>- </span>commonBackTo<span class=O>, </span>longest <span class=E>- </span>commonBackTo <span class=E>- <span class=M>1 </span></span></span>do<br>            if <span class=C>len_a <span class=E>&gt; </span>len_b </span>then<br>                <span class=C>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;  <span class=F>- A[%d]: %s</span>&#39;</span>, </span>i<span class=O>, </span>prettystr<span class=E>(</span>table_a<span class=E>[</span>i<span class=E>]) )<br>                <span class=U>-- </span></span></span></span>table.insert( result, &#39;+ (no matching B index)&#39;)<br>            <span class=N>else<br>                <span class=U>-- </span></span>table.insert( result, &#39;- no matching A index&#39;)<br>                <span class=C>extendWithStrFmt<span class=E>( </span>result<span class=O>, <span class=B>&#39;  <span class=F>+ B[%d]: %s</span>&#39;</span>, </span>i<span class=O>, </span>prettystr<span class=E>(</span>table_b<span class=E>[</span>i<span class=E>]) )<br>            <span class=N>end<br>        end<br>    end<br><br>    <span class=U>-- </span></span></span></span>common parts to list A &amp; B, at the end<br>    <span class=N>if <span class=C>commonBackTo <span class=E>&gt;= <span class=M>0 </span></span></span>then<br>        <span class=C>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=B>&#39;<span class=F>* Common parts at the end of the lists</span>&#39; <span class=E>)<br>        </span></span></span></span>for <span class=C>i <span class=D>= </span>longest <span class=E>- </span>commonBackTo<span class=O>, </span>longest </span>do<br>            if <span class=C>len_a <span class=E>&gt; </span>len_b </span>then<br>                <span class=C>insertABValue<span class=E>( </span>i<span class=O>, </span>i<span class=E>-</span>deltalv <span class=E>)<br>            </span></span>else<br>                <span class=C>insertABValue<span class=E>( </span>i<span class=E>-</span>deltalv<span class=O>, </span>i <span class=E>)<br>            </span></span>end<br>        end<br>    end<br><br>    <span class=K>return <span class=L>true<span class=O>, <span class=C>table<span class=H>.</span>concat<span class=E>( </span>result</span>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br></span></span></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>mismatchFormattingPureList <span class=D>= </span>mismatchFormattingPureList<br><br></span>local function <span class=C>prettystrPairs<span class=E>(</span>value1<span class=O>, </span>value2<span class=O>, </span>suffix_a<span class=O>, </span>suffix_b<span class=E>)<br>    <span class=U>--[[<br>    </span></span></span></span></span>This function helps with the recurring task of constructing the &#34;expected<br>    vs. actual&#34; error messages. It takes two arbitrary values and formats<br>    corresponding strings with prettystr().<br><br>    To keep the (possibly complex) output more readable in case the resulting<br>    strings contain line breaks, they get automatically prefixed with additional<br>    newlines. Both suffixes are optional (default to empty strings), and get<br>    appended to the &#34;value1&#34; string. &#34;suffix_a&#34; is used if line breaks were<br>    encountered, &#34;suffix_b&#34; otherwise.<br><br>    Returns the two formatted strings (including padding/newlines).<br>    <span class=U>]]<br>    <span class=G>local <span class=C>str1<span class=O>, </span>str2 <span class=D>= </span>prettystr<span class=E>(</span>value1<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>value2<span class=E>)<br>    <span class=N>if </span></span>hasNewLine<span class=E>(</span>str1<span class=E>) <span class=J>or </span></span>hasNewLine<span class=E>(</span>str2<span class=E>) <span class=N>then<br>        </span></span></span></span>-- </span>line break(s) detected, add padding<br>        <span class=K>return <span class=B>&#34;<span class=F>\n</span>&#34; <span class=E>.. <span class=C>str1 </span>.. (<span class=C>suffix_a <span class=J>or </span></span></span>&#34;&#34;<span class=E>)<span class=O>, </span></span>&#34;<span class=F>\n</span>&#34; <span class=E>.. <span class=C>str2<br>    <span class=N>end<br>    </span></span></span></span>return <span class=C>str1 <span class=E>.. (</span>suffix_b <span class=J>or <span class=B>&#34;&#34;<span class=E>)<span class=O>, </span></span></span></span>str2<br></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>prettystrPairs <span class=D>= </span>prettystrPairs<br><br><span class=G>local </span>UNKNOWN_REF <span class=D>= <span class=B>&#39;<span class=F>table 00-unknown ref</span>&#39;<br><span class=G>local </span></span></span>ref_generator <span class=D>= <span class=E>{ <span class=P>value</span></span>=<span class=M>1<span class=O>, [</span></span></span>UNKNOWN_REF<span class=O>]<span class=D>=<span class=M>0 <span class=E>}<br><br></span></span></span></span></span>local function <span class=C>table_ref<span class=E>( </span>t <span class=E>)<br>    <span class=U>-- </span></span></span></span>return the default tostring() for tables, with the table ID, even if the table has a metatable<br>    <span class=U>-- </span>with the __tostring converter<br>    <span class=G>local <span class=C>ref <span class=D>= <span class=B>&#39;&#39;<br>    </span></span></span>local <span class=C>mt <span class=D>= </span>getmetatable<span class=E>( </span>t <span class=E>)<br>    <span class=N>if </span></span>mt <span class=E>== <span class=L>nil <span class=N>then<br>        </span></span></span>ref <span class=D>= </span>tostring<span class=E>(</span>t<span class=E>)<br>    <span class=N>else<br>        </span></span></span>local <span class=C>success<span class=O>, </span>result<br>        success<span class=O>, </span>result <span class=D>= </span>pcall<span class=E>(</span>setmetatable<span class=O>, </span>t<span class=O>, <span class=L>nil<span class=E>)<br>        <span class=N>if </span>not </span></span></span>success <span class=N>then<br>            <span class=U>-- </span></span></span></span>protected table, if __tostring is defined, we can<br>            <span class=U>-- </span>not get the reference. And we can not know in advance.<br>            <span class=C>ref <span class=D>= </span>tostring<span class=E>(</span>t<span class=E>) <br>            <span class=N>if </span>not </span>ref<span class=H>:</span>match<span class=E>( <span class=B>&#39;<span class=F>table: 0?x?[%x]+</span>&#39; </span>) <span class=N>then<br>                <span class=K>return </span></span></span>UNKNOWN_REF<br>            <span class=N>end<br>        else<br>            </span>ref <span class=D>= </span>tostring<span class=E>(</span>t<span class=E>)<br>            </span>setmetatable<span class=E>( </span>t<span class=O>, </span>mt <span class=E>)<br>        <span class=N>end<br>    end<br>    <span class=U>-- </span></span></span></span>strip the &#34;table: &#34; part<br>    <span class=C>ref <span class=D>= </span>ref<span class=H>:</span>sub<span class=E>(<span class=M>8</span>)<br>    <span class=N>if </span></span>ref <span class=E>~= </span>UNKNOWN_REF <span class=I>and </span>ref_generator<span class=E>[</span>ref<span class=E>] == <span class=L>nil <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>Create a new reference number<br>        <span class=C>ref_generator<span class=E>[</span>ref<span class=E>] <span class=D>= </span></span>ref_generator<span class=H>.</span>value<br>        ref_generator<span class=H>.</span>value <span class=D>= </span>ref_generator<span class=H>.</span>value<span class=E>+<span class=M>1<br>    <span class=N>end<br>    if </span></span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=N>then<br>        <span class=K>return </span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;<span class=F>table %02d-%s</span>&#39;<span class=O>, </span></span></span>ref_generator<span class=E>[</span>ref<span class=E>]<span class=O>, </span></span>ref<span class=E>)<br>    <span class=N>else<br>        <span class=K>return </span></span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;<span class=F>table %02d</span>&#39;<span class=O>, </span></span></span>ref_generator<span class=E>[</span>ref<span class=E>])<br>    <span class=N>end<br><span class=K>end<br></span></span></span>M<span class=H>.</span>private<span class=H>.</span>table_ref <span class=D>= </span>table_ref<br><br><span class=G>local </span>TABLE_TOSTRING_SEP <span class=D>= <span class=B>&#34;<span class=F>, </span>&#34;<br><span class=G>local </span></span></span>TABLE_TOSTRING_SEP_LEN <span class=D>= </span>string<span class=H>.</span>len<span class=E>(</span>TABLE_TOSTRING_SEP<span class=E>)<br><br><span class=K>local function </span></span>_table_tostring<span class=E>( </span>tbl<span class=O>, </span>indentLevel<span class=O>, </span>printTableRefs<span class=O>, </span>cycleDetectTable <span class=E>)<br>    </span>printTableRefs <span class=D>= </span>printTableRefs <span class=J>or </span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG<br>    cycleDetectTable <span class=D>= </span>cycleDetectTable <span class=J>or <span class=E>{}<br>    </span></span>cycleDetectTable<span class=E>[</span>tbl<span class=E>] <span class=D>= <span class=L>true<br><br>    <span class=G>local </span></span></span></span>result<span class=O>, </span>dispOnMultLines <span class=D>= <span class=E>{}<span class=O>, <span class=L>false<br><br>    <span class=U>-- </span></span></span></span></span></span>like prettystr but do not enclose with &#34;&#34; if the string is just alphanumerical<br>    <span class=U>-- </span>this is better for displaying table keys who are often simple strings<br>    <span class=K>local function <span class=C>keytostring<span class=E>(</span>k<span class=E>)<br>        <span class=N>if <span class=B>&#34;<span class=F>string</span>&#34; </span></span>== </span>type<span class=E>(</span>k<span class=E>) <span class=I>and </span></span>k<span class=H>:</span>match<span class=E>(<span class=B>&#34;<span class=F>^[_%a][_%w]*$</span>&#34;</span>) <span class=N>then<br>            </span></span></span>return <span class=C>k<br>        <span class=N>end<br>        </span></span>return <span class=C>prettystr_sub<span class=E>(</span>k<span class=O>, </span>indentLevel<span class=E>+<span class=M>1<span class=O>, </span></span></span>printTableRefs<span class=O>, </span>cycleDetectTable<span class=E>)<br>    </span></span>end<br><br>    <span class=G>local <span class=C>mt <span class=D>= </span>getmetatable<span class=E>( </span>tbl <span class=E>)<br><br>    <span class=N>if </span></span>mt <span class=I>and </span>mt<span class=H>.</span>__tostring <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>if table has a __tostring() function in its metatable, use it to display the table<br>        <span class=U>-- </span>else, compute a regular table<br>        <span class=C>result <span class=D>= </span>tostring<span class=E>(</span>tbl<span class=E>)<br>        <span class=N>if </span></span>type<span class=E>(</span>result<span class=E>) ~= <span class=B>&#39;<span class=F>string</span>&#39; <span class=N>then<br>            <span class=K>return </span></span></span></span>string<span class=H>.</span>format<span class=E>( <span class=B>&#39;<span class=F>&lt;invalid tostring() result: &#34;%s&#34; &gt;</span>&#39;<span class=O>, </span></span></span>prettystr<span class=E>(</span>result<span class=E>) )<br>        <span class=N>end<br>        </span></span>result <span class=D>= </span>strsplit<span class=E>( <span class=B>&#39;<span class=F>\n</span>&#39;<span class=O>, </span></span></span>result <span class=E>)<br>        <span class=K>return </span></span>M<span class=H>.</span>private<span class=H>.</span>_table_tostring_format_multiline_string<span class=E>( </span>result<span class=O>, </span>indentLevel <span class=E>)<br><br>    <span class=N>else<br>        <span class=U>-- </span></span></span></span>no metatable, compute the table representation<br><br>        <span class=G>local <span class=C>entry<span class=O>, </span>count<span class=O>, </span>seq_index <span class=D>= <span class=L>nil<span class=O>, <span class=M>0</span>, <span class=M>1<br>        <span class=N>for </span></span></span></span></span>k<span class=O>, </span>v <span class=N>in </span>sortedPairs<span class=E>( </span>tbl <span class=E>) <span class=N>do<br><br>            <span class=U>-- </span></span></span></span></span>key part<br>            <span class=N>if <span class=C>k <span class=E>== </span>seq_index </span>then<br>                <span class=U>-- </span></span>for the sequential part of tables, we&#39;ll skip the &#34;&lt;key&gt;=&#34; output<br>                <span class=C>entry <span class=D>= <span class=B>&#39;&#39;<br>                </span></span>seq_index <span class=D>= </span>seq_index <span class=E>+ <span class=M>1<br>            <span class=N>elseif </span></span></span>cycleDetectTable<span class=E>[</span>k<span class=E>] <span class=N>then<br>                <span class=U>-- </span></span></span></span>recursion in the key detected<br>                <span class=C>cycleDetectTable<span class=H>.</span>detected <span class=D>= <span class=L>true<br>                </span></span>entry <span class=D>= <span class=B>&#34;<span class=F>&lt;</span>&#34;<span class=E>..</span></span></span>table_ref<span class=E>(</span>k<span class=E>)..<span class=B>&#34;<span class=F>&gt;=</span>&#34;<br>            <span class=N>else<br>                </span></span></span>entry <span class=D>= </span>keytostring<span class=E>(</span>k<span class=E>) .. <span class=B>&#34;<span class=F>=</span>&#34;<br>            <span class=N>end<br><br>            <span class=U>-- </span></span></span></span></span>value part <br>            <span class=N>if <span class=C>cycleDetectTable<span class=E>[</span>v<span class=E>] </span></span>then<br>                <span class=U>-- </span></span>recursion in the value detected!<br>                <span class=C>cycleDetectTable<span class=H>.</span>detected <span class=D>= <span class=L>true<br>                </span></span>entry <span class=D>= </span>entry <span class=E>.. <span class=B>&#34;<span class=F>&lt;</span>&#34;</span>..</span>table_ref<span class=E>(</span>v<span class=E>)..<span class=B>&#34;<span class=F>&gt;</span>&#34;<br>            <span class=N>else<br>                </span></span></span>entry <span class=D>= </span>entry <span class=E>..<br>                    </span>prettystr_sub<span class=E>( </span>v<span class=O>, </span>indentLevel<span class=E>+<span class=M>1<span class=O>, </span></span></span>printTableRefs<span class=O>, </span>cycleDetectTable <span class=E>)<br>            <span class=N>end<br>            </span></span>count <span class=D>= </span>count <span class=E>+ <span class=M>1<br>            </span></span>result<span class=E>[</span>count<span class=E>] <span class=D>= </span></span>entry<br>        <span class=N>end<br>        <span class=K>return </span></span>M<span class=H>.</span>private<span class=H>.</span>_table_tostring_format_result<span class=E>( </span>tbl<span class=O>, </span>result<span class=O>, </span>indentLevel<span class=O>, </span>printTableRefs <span class=E>)<br>    <span class=N>end<br><br><span class=K>end<br></span></span></span>M<span class=H>.</span>private<span class=H>.</span>_table_tostring <span class=D>= </span>_table_tostring <span class=U>-- </span></span>prettystr_sub() needs it<br><br><span class=K>local function <span class=C>_table_tostring_format_multiline_string<span class=E>( </span>tbl_str<span class=O>, </span>indentLevel <span class=E>)<br>    <span class=G>local </span></span>indentString <span class=D>= <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>..</span></span></span>string<span class=H>.</span>rep<span class=E>(<span class=B>&#34;    &#34;<span class=O>, </span></span></span>indentLevel <span class=E>- <span class=M>1</span>)<br>    </span></span>return <span class=C>table<span class=H>.</span>concat<span class=E>( </span>tbl_str<span class=O>, </span>indentString <span class=E>)<br><br></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>_table_tostring_format_multiline_string <span class=D>= </span>_table_tostring_format_multiline_string<br><br><br></span>local function <span class=C>_table_tostring_format_result<span class=E>( </span>tbl<span class=O>, </span>result<span class=O>, </span>indentLevel<span class=O>, </span>printTableRefs <span class=E>)<br>    <span class=U>-- </span></span></span></span>final function called in _table_to_string() to format the resulting list of <br>    <span class=U>-- </span>string describing the table.<br><br>    <span class=G>local <span class=C>dispOnMultLines <span class=D>= <span class=L>false<br><br>    <span class=U>-- </span></span></span></span></span>set dispOnMultLines to true if the maximum LINE_LENGTH would be exceeded with the values<br>    <span class=G>local <span class=C>totalLength <span class=D>= <span class=M>0<br>    <span class=N>for </span></span></span>k<span class=O>, </span>v <span class=N>in </span>ipairs<span class=E>( </span>result <span class=E>) <span class=N>do<br>        </span></span>totalLength <span class=D>= </span>totalLength <span class=E>+ </span>string<span class=H>.</span>len<span class=E>( </span>v <span class=E>)<br>        <span class=N>if </span></span>totalLength <span class=E>&gt;= </span>M<span class=H>.</span>LINE_LENGTH <span class=N>then<br>            </span>dispOnMultLines <span class=D>= <span class=L>true<br>            <span class=N>break<br>        end<br>    end<br><br>    <span class=U>-- </span></span></span></span></span></span>set dispOnMultLines to true if the max LINE_LENGTH would be exceeded<br>    <span class=U>-- </span>with the values and the separators.<br>    <span class=N>if <span class=E>not <span class=C>dispOnMultLines </span></span>then<br>        <span class=U>-- </span></span>adjust with length of separator(s):<br>        <span class=U>-- </span>two items need 1 sep, three items two seps, ... plus len of &#39;{}&#39;<br>        <span class=N>if <span class=E>#<span class=C>result </span>&gt; <span class=M>0 </span></span>then<br>            <span class=C>totalLength <span class=D>= </span>totalLength <span class=E>+ </span>TABLE_TOSTRING_SEP_LEN <span class=E>* (#</span>result <span class=E>- <span class=M>1</span>)<br>        </span></span>end<br>        <span class=C>dispOnMultLines <span class=D>= <span class=E>(</span></span>totalLength <span class=E>+ <span class=M>2 </span>&gt;= </span>M<span class=H>.</span>LINE_LENGTH<span class=E>)<br>    </span></span>end<br><br>    <span class=U>-- </span></span>now reformat the result table (currently holding element strings)<br>    <span class=N>if <span class=C>dispOnMultLines </span>then<br>        <span class=G>local <span class=C>indentString <span class=D>= </span>string<span class=H>.</span>rep<span class=E>(<span class=B>&#34;    &#34;<span class=O>, </span></span></span>indentLevel <span class=E>- <span class=M>1</span>)<br>        </span>result <span class=D>= <span class=E>{  <br>                    <span class=B>&#34;<span class=F>{\n    </span>&#34;<span class=O>, <br>                    </span></span></span></span>indentString<span class=O>,<br>                    </span>table<span class=H>.</span>concat<span class=E>(</span>result<span class=O>, <span class=B>&#34;<span class=F>,\n    </span>&#34; <span class=E>.. </span></span></span>indentString<span class=E>)<span class=O>, <br>                    <span class=B>&#34;<span class=F>\n</span>&#34;</span>,<br>                    </span></span>indentString<span class=O>, <br>                    <span class=B>&#34;<span class=F>}</span>&#34;<br>                <span class=E>}<br>    </span></span></span></span></span>else<br>        <span class=C>result <span class=D>= <span class=E>{<span class=B>&#34;<span class=F>{</span>&#34;<span class=O>, </span></span></span></span>table<span class=H>.</span>concat<span class=E>(</span>result<span class=O>, </span>TABLE_TOSTRING_SEP<span class=E>)<span class=O>, <span class=B>&#34;<span class=F>}</span>&#34;</span></span>}<br>    </span></span>end<br>    if <span class=C>printTableRefs </span>then<br>        <span class=C>table<span class=H>.</span>insert<span class=E>(</span>result<span class=O>, <span class=M>1</span>, <span class=B>&#34;<span class=F>&lt;</span>&#34;<span class=E>..</span></span></span>table_ref<span class=E>(</span>tbl<span class=E>)..<span class=B>&#34;<span class=F>&gt; </span>&#34;</span>) <span class=U>-- </span></span></span></span>prepend table ref<br>    <span class=N>end<br>    <span class=K>return <span class=C>table<span class=H>.</span>concat<span class=E>(</span>result<span class=E>)<br></span></span>end<br><span class=C>M<span class=H>.</span>private<span class=H>.</span>_table_tostring_format_result <span class=D>= </span>_table_tostring_format_result <span class=U>-- </span></span></span></span>prettystr_sub() needs it<br><br><span class=K>local function <span class=C>table_findkeyof<span class=E>(</span>t<span class=O>, </span>element<span class=E>)<br>    <span class=U>-- </span></span></span></span>Return the key k of the given element in table t, so that t[k] == element<br>    <span class=U>-- </span>(or `nil` if element is not present within t). Note that we use our<br>    <span class=U>-- </span>&#39;general&#39; is_equal comparison for matching, so this function should<br>    <span class=U>-- </span>handle table-type elements gracefully and consistently.<br>    <span class=N>if <span class=C>type<span class=E>(</span>t<span class=E>) == <span class=B>&#34;<span class=F>table</span>&#34; </span></span></span>then<br>        for <span class=C>k<span class=O>, </span>v </span>in <span class=C>pairs<span class=E>(</span>t<span class=E>) </span></span>do<br>            if <span class=C>M<span class=H>.</span>private<span class=H>.</span>is_table_equals<span class=E>(</span>v<span class=O>, </span>element<span class=E>) </span></span>then<br>                <span class=K>return <span class=C>k<br>            </span></span>end<br>        end<br>    end<br>    <span class=K>return <span class=L>nil<br></span>end<br><br>local function <span class=C>_is_table_items_equals<span class=E>(</span>actual<span class=O>, </span>expected <span class=E>)<br>    <span class=G>local </span></span>type_a<span class=O>, </span>type_e <span class=D>= </span>type<span class=E>(</span>actual<span class=E>)<span class=O>, </span></span>type<span class=E>(</span>expected<span class=E>)<br><br>    </span></span></span>if <span class=C>type_a <span class=E>~= </span>type_e </span>then<br>        <span class=K>return <span class=L>false<br><br>    </span></span>elseif <span class=E>(<span class=C>type_a </span>== <span class=B>&#39;<span class=F>table</span>&#39;</span>) <span class=U>--[[</span></span></span>and (type_e == &#39;table&#39;)<span class=U>]] <span class=N>then<br>        for <span class=C>k<span class=O>, </span>v </span>in <span class=C>pairs<span class=E>(</span>actual<span class=E>) </span></span>do<br>            if <span class=C>table_findkeyof<span class=E>(</span>expected<span class=O>, </span>v<span class=E>) == <span class=L>nil </span></span></span>then<br>                <span class=K>return <span class=L>false </span></span></span>-- </span>v not contained in expected<br>            <span class=N>end<br>        end<br>        for <span class=C>k<span class=O>, </span>v </span>in <span class=C>pairs<span class=E>(</span>expected<span class=E>) </span></span>do<br>            if <span class=C>table_findkeyof<span class=E>(</span>actual<span class=O>, </span>v<span class=E>) == <span class=L>nil </span></span></span>then<br>                <span class=K>return <span class=L>false <span class=U>-- </span></span></span></span>v not contained in actual<br>            <span class=N>end<br>        end<br>        <span class=K>return <span class=L>true<br><br>    </span></span>elseif <span class=C>actual <span class=E>~= </span>expected </span>then<br>        <span class=K>return <span class=L>false<br>    </span></span>end<br><br>    <span class=K>return <span class=L>true<br></span>end<br><br><span class=U>--[[<br></span></span></span>This is a specialized metatable to help with the bookkeeping of recursions<br>in _is_table_equals(). It provides an __index table that implements utility<br>functions for easier management of the table. The &#34;cached&#34; method queries<br>the state of a specific (actual,expected) pair; and the &#34;store&#34; method sets<br>this state to the given value. The state of pairs not &#34;seen&#34; / visited is<br>assumed to be `nil`.<br><span class=U>]]<br><span class=G>local <span class=C>_recursion_cache_MT <span class=D>= <span class=E>{<br>    <span class=P>__index </span></span>= <span class=E>{<br>        </span></span></span></span>-- </span>Return the cached value for an (actual,expected) pair (or `nil`)<br>        <span class=P>cached <span class=D>= <span class=K>function<span class=E>(<span class=C>t<span class=O>, </span>actual<span class=O>, </span>expected</span>)<br>            <span class=G>local <span class=C>subtable </span></span></span></span>= <span class=C>t<span class=E>[</span>actual<span class=E>] <span class=J>or </span>{}<br>            <span class=K>return </span></span>subtable<span class=E>[</span>expected<span class=E>]<br>        <span class=K>end<span class=O>,<br><br>        <span class=U>-- </span></span></span></span></span></span></span>Store cached value for a specific (actual,expected) pair.<br>        <span class=U>-- </span>Returns the value, so it&#39;s easy to use for a &#34;tailcall&#34; (return ...).<br>        <span class=P>store <span class=D>= <span class=K>function<span class=E>(<span class=C>t<span class=O>, </span>actual<span class=O>, </span>expected<span class=O>, </span>value<span class=O>, </span>asymmetric</span>)<br>            <span class=G>local <span class=C>subtable </span></span></span></span>= <span class=C>t<span class=E>[</span>actual<span class=E>]<br>            <span class=N>if </span>not </span>subtable <span class=N>then<br>                </span>subtable </span>= <span class=E>{}<br>                <span class=C>t</span>[<span class=C>actual</span>] </span>= <span class=C>subtable<br>            <span class=N>end<br>            </span>subtable<span class=E>[</span>expected<span class=E>] </span></span>= <span class=C>value<br><br>            <span class=U>-- </span></span></span></span>Unless explicitly marked &#34;asymmetric&#34;: Consider the recursion<br>            <span class=U>-- </span>on (expected,actual) to be equivalent to (actual,expected) by<br>            <span class=U>-- </span>default, and thus cache the value for both.<br>            <span class=N>if <span class=E>not <span class=C>asymmetric </span></span>then<br>                <span class=C>t<span class=H>:</span>store<span class=E>(</span>expected<span class=O>, </span>actual<span class=O>, </span>value<span class=O>, <span class=L>true<span class=E>)<br>            </span></span></span></span>end<br><br>            <span class=K>return <span class=C>value<br>        </span>end<br>    <span class=E>}<br>}<br><br></span>local function <span class=C>_is_table_equals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>cycleDetectTable<span class=O>, </span>marginForAlmostEqual<span class=E>)<br>    <span class=U>--[[</span></span></span></span></span>Returns true if both table are equal.<br><br>    If argument marginForAlmostEqual is suppied, number comparison is done using alomstEqual instead <br>    of strict equality.<br><br>    cycleDetectTable is an internal argument used during recursion on tables.<br>    <span class=U>]]<br>    --</span>print(&#39;_is_table_equals( \n     &#39;..prettystr(actual)..&#39;\n      , &#39;..prettystr(expected)..<br>    <span class=U>--                        </span>&#39;\n     , &#39;..prettystr(cycleDetectTable)..&#39;\n    , &#39;..prettystr(marginForAlmostEqual)..&#39; )&#39;)<br><br>    <span class=G>local <span class=C>type_a<span class=O>, </span>type_e <span class=D>= </span>type<span class=E>(</span>actual<span class=E>)<span class=O>, </span></span>type<span class=E>(</span>expected<span class=E>)<br><br>    <span class=N>if </span></span>type_a <span class=E>~= </span>type_e <span class=N>then<br>        <span class=K>return <span class=L>false <span class=U>-- </span></span></span></span></span></span>different types won&#39;t match<br>    <span class=N>end<br><br>    if <span class=C>type_a <span class=E>== <span class=B>&#39;<span class=F>number</span>&#39; </span></span></span>then<br>        if <span class=C>marginForAlmostEqual <span class=E>~= <span class=L>nil </span></span></span>then<br>            <span class=K>return <span class=C>M<span class=H>.</span>almostEquals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>marginForAlmostEqual<span class=E>)<br>        </span></span></span>else<br>            <span class=K>return <span class=C>actual <span class=E>== </span>expected<br>        </span></span>end<br>    elseif <span class=C>type_a <span class=E>~= <span class=B>&#39;<span class=F>table</span>&#39; </span></span></span>then<br>        <span class=U>-- </span></span>other types compare directly<br>        <span class=K>return <span class=C>actual <span class=E>== </span>expected<br>    <span class=N>end<br><br>    </span>cycleDetectTable <span class=D>= </span>cycleDetectTable <span class=J>or <span class=E>{ <span class=P>actual<span class=D>=</span></span>{}<span class=O>, <span class=P>expected<span class=D>=</span></span></span>{} }<br>    <span class=N>if </span></span></span>cycleDetectTable<span class=H>.</span>actual<span class=E>[ </span>actual <span class=E>] <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>oh, we hit a cycle in actual<br>        <span class=N>if <span class=C>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] </span></span>then<br>            <span class=U>-- </span></span>uh, we hit a cycle at the same time in expected<br>            <span class=U>-- </span>so the two tables have similar structure<br>            <span class=K>return <span class=L>true<br>        <span class=N>end<br><br>        <span class=U>-- </span></span></span></span>cycle was hit only in actual, the structure differs from expected<br>        <span class=K>return <span class=L>false<br>    <span class=N>end<br><br>    if <span class=C>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] </span></span>then<br>        <span class=U>-- </span></span></span></span>no cycle in actual, but cycle in expected<br>        <span class=U>-- </span>the structure differ<br>        <span class=K>return <span class=L>false<br>    <span class=N>end<br><br>    <span class=U>-- </span></span></span></span>at this point, no table cycle detected, we are<br>    <span class=U>-- </span>seeing this table for the first time<br><br>    <span class=U>-- </span>mark the cycle detection<br>    <span class=C>cycleDetectTable<span class=H>.</span>actual<span class=E>[ </span>actual <span class=E>] <span class=D>= <span class=L>true<br>    </span></span></span>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] <span class=D>= <span class=L>true<br><br><br>    <span class=G>local </span></span></span></span>actualKeysMatched <span class=D>= <span class=E>{}<br>    <span class=N>for </span></span></span>k<span class=O>, </span>v <span class=N>in </span>pairs<span class=E>(</span>actual<span class=E>) <span class=N>do<br>        </span></span>actualKeysMatched<span class=E>[</span>k<span class=E>] <span class=D>= <span class=L>true <span class=U>-- </span></span></span></span></span>Keep track of matched keys<br>        <span class=N>if <span class=E>not <span class=C>_is_table_equals</span>(<span class=C>v<span class=O>, </span>expected</span>[<span class=C>k</span>]<span class=O>, <span class=C>cycleDetectTable</span>, <span class=C>marginForAlmostEqual</span></span>) </span>then<br>            <span class=U>-- </span></span>table differs on this key<br>            <span class=U>-- </span>clear the cycle detection before returning<br>            <span class=C>cycleDetectTable<span class=H>.</span>actual<span class=E>[ </span>actual <span class=E>] <span class=D>= <span class=L>nil<br>            </span></span></span>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] <span class=D>= <span class=L>nil<br>            <span class=K>return </span>false<br>        <span class=N>end<br>    end<br><br>    for </span></span></span></span>k<span class=O>, </span>v <span class=N>in </span>pairs<span class=E>(</span>expected<span class=E>) <span class=N>do<br>        if </span>not </span>actualKeysMatched<span class=E>[</span>k<span class=E>] <span class=N>then<br>            <span class=U>-- </span></span></span></span>Found a key that we did not see in &#34;actual&#34; -&gt; mismatch<br>            <span class=U>-- </span>clear the cycle detection before returning<br>            <span class=C>cycleDetectTable<span class=H>.</span>actual<span class=E>[ </span>actual <span class=E>] <span class=D>= <span class=L>nil<br>            </span></span></span>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] <span class=D>= <span class=L>nil<br>            <span class=K>return </span>false<br>        <span class=N>end<br>        <span class=U>-- </span></span></span></span></span></span>Otherwise actual[k] was already matched against v = expected[k].<br>    <span class=N>end<br><br>    <span class=U>-- </span></span>all key match, we have a match !<br>    <span class=C>cycleDetectTable<span class=H>.</span>actual<span class=E>[ </span>actual <span class=E>] <span class=D>= <span class=L>nil<br>    </span></span></span>cycleDetectTable<span class=H>.</span>expected<span class=E>[ </span>expected <span class=E>] <span class=D>= <span class=L>nil<br>    <span class=K>return </span>true<br><span class=K>end<br></span></span></span></span>M<span class=H>.</span>private<span class=H>.</span>_is_table_equals <span class=D>= </span>_is_table_equals<br><br><span class=K>local function </span>failure<span class=E>(</span>main_msg<span class=O>, </span>extra_msg_or_nil<span class=O>, </span>level<span class=E>)<br>    <span class=U>-- </span></span></span>raise an error indicating a test failure<br>    <span class=U>-- </span>for error() compatibility we adjust &#34;level&#34; here (by +1), to report the<br>    <span class=U>-- </span>calling context<br>    <span class=G>local <span class=C>msg<br>    <span class=N>if </span>type<span class=E>(</span>extra_msg_or_nil<span class=E>) == <span class=B>&#39;<span class=F>string</span>&#39; <span class=I>and </span></span></span>extra_msg_or_nil<span class=H>:</span>len<span class=E>() &gt; <span class=M>0 <span class=N>then<br>        </span></span></span>msg <span class=D>= </span>extra_msg_or_nil <span class=E>.. <span class=B>&#39;<span class=F>\n</span>&#39; </span>.. </span>main_msg<br>    <span class=N>else<br>        </span>msg <span class=D>= </span>main_msg<br>    <span class=N>end<br>    </span>error<span class=E>(</span>M<span class=H>.</span>FAILURE_PREFIX <span class=E>.. </span>msg<span class=O>, <span class=E>(</span></span>level <span class=J>or <span class=M>1<span class=E>) + </span>1 <span class=E>+ </span></span></span>M<span class=H>.</span>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE<span class=E>)<br><span class=K>end<br><br>local function </span></span>is_table_equals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>marginForAlmostEqual<span class=E>)<br>    <span class=K>return </span></span>_is_table_equals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, <span class=L>nil</span>, </span>marginForAlmostEqual<span class=E>)<br><span class=K>end<br></span></span>M<span class=H>.</span>private<span class=H>.</span>is_table_equals <span class=D>= </span>is_table_equals<br><br><span class=K>local function </span>fail_fmt<span class=E>(</span>level<span class=O>, </span>extra_msg_or_nil<span class=O>, ...<span class=E>)<br>     <span class=U>-- </span></span></span></span></span>failure with printf-style formatted message and given error level<br>    <span class=C>failure<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<span class=O>...</span>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=E>(</span></span>level <span class=J>or <span class=M>1<span class=E>) + </span>1<span class=E>)<br><span class=K>end<br></span></span></span></span>M<span class=H>.</span>private<span class=H>.</span>fail_fmt <span class=D>= </span>fail_fmt<br><br><span class=K>local function </span>error_fmt<span class=E>(</span>level<span class=O>, ...<span class=E>)<br>     <span class=U>-- </span></span></span></span>printf-style error()<br>    <span class=C>error<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<span class=O>...</span>)<span class=O>, </span>(</span>level <span class=J>or <span class=M>1<span class=E>) + </span>1 <span class=E>+ </span></span></span>M<span class=H>.</span>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE<span class=E>)<br><span class=K>end<br></span></span>M<span class=H>.</span>private<span class=H>.</span>error_fmt <span class=D>= </span>error_fmt<br><br><span class=U>--</span></span>--------------------------------------------------------------<br><span class=U>--<br>--                     </span>assertions<br><span class=U>--<br>--</span>--------------------------------------------------------------<br><br><span class=K>local function <span class=C>errorMsgEquality<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>doDeepAnalysis<span class=O>, </span>margin<span class=E>)<br>    <span class=U>-- </span></span></span></span>margin is supplied only for almost equal verification<br><br>    <span class=N>if <span class=E>not <span class=C>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED </span></span>then<br>        <span class=C>expected<span class=O>, </span>actual <span class=D>= </span>actual<span class=O>, </span>expected<br>    </span>end<br>    if <span class=C>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>string</span>&#39; <span class=J>or </span></span></span>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; </span></span></span>then<br>        <span class=G>local <span class=C>strExpected<span class=O>, </span>strActual <span class=D>= </span>prettystrPairs<span class=E>(</span>expected<span class=O>, </span>actual<span class=E>)<br>        </span></span>local <span class=C>result <span class=D>= </span>string<span class=H>.</span>format<span class=E>(<span class=B>&#34;<span class=F>expected: %s\nactual: %s</span>&#34;<span class=O>, </span></span></span>strExpected<span class=O>, </span>strActual<span class=E>)<br>        </span></span></span>if <span class=C>margin </span>then<br>            <span class=C>result <span class=D>= </span>result <span class=E>.. <span class=B>&#39;<span class=F>\nwere not equal by the margin of: </span>&#39;</span>..</span>prettystr<span class=E>(</span>margin<span class=E>)<br>        </span></span>end<br><br>        <span class=U>-- </span></span>extend with mismatch analysis if possible:<br>        <span class=G>local <span class=C>success<span class=O>, </span>mismatchResult<br>        success<span class=O>, </span>mismatchResult <span class=D>= </span>tryMismatchFormatting<span class=E>( </span>actual<span class=O>, </span>expected<span class=O>, </span>doDeepAnalysis<span class=O>, </span>margin <span class=E>)<br>        <span class=N>if </span></span>success <span class=N>then <br>            </span>result <span class=D>= </span>table<span class=H>.</span>concat<span class=E>( { </span>result<span class=O>, </span>mismatchResult <span class=E>}<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39; </span></span>)<br>        <span class=N>end<br>        <span class=K>return </span></span></span>result<br>    <span class=N>end<br>    <span class=K>return </span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#34;<span class=F>expected: %s, actual: %s</span>&#34;<span class=O>,<br>                         </span></span></span>prettystr<span class=E>(</span>expected<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>actual<span class=E>))<br><span class=K>end<br><br>function </span></span>M.assertError<span class=E>(</span>f<span class=O>, ...<span class=E>)<br>    <span class=U>-- </span></span></span></span></span>assert that calling f with the arguments will raise an error<br>    <span class=U>-- </span>example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    <span class=N>if <span class=C>pcall<span class=E>( </span>f<span class=O>, ... <span class=E>) </span></span></span>then<br>        <span class=C>failure<span class=E>( <span class=B>&#34;<span class=F>Expected an error when calling function but no error generated</span>&#34;<span class=O>, <span class=L>nil</span>, <span class=M>2 </span></span></span>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.fail<span class=E>( </span>msg <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>stops a test due to a failure<br>    <span class=C>failure<span class=E>( </span>msg<span class=O>, <span class=L>nil</span>, <span class=M>2 <span class=E>)<br><span class=K>end<br><br>function </span></span></span></span>M.failIf<span class=E>( </span>cond<span class=O>, </span>msg <span class=E>)<br>    <span class=U>-- </span></span></span>Fails a test with &#34;msg&#34; if condition is true<br>    <span class=N>if <span class=C>cond </span>then<br>        <span class=C>failure<span class=E>( </span>msg<span class=O>, <span class=L>nil</span>, <span class=M>2 <span class=E>)<br>    </span></span></span></span>end<br><span class=K>end<br><br>function <span class=C>M.skip<span class=E>(</span>msg<span class=E>)<br>    <span class=U>-- </span></span></span></span></span>skip a running test<br>    <span class=C>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>M<span class=H>.</span>SKIP_PREFIX <span class=E>.. </span>msg<span class=E>)<br><span class=K>end<br><br>function </span></span>M.skipIf<span class=E>( </span>cond<span class=O>, </span>msg <span class=E>)<br>    <span class=U>-- </span></span></span>skip a running test if condition is met<br>    <span class=N>if <span class=C>cond </span>then<br>        <span class=C>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>M<span class=H>.</span>SKIP_PREFIX <span class=E>.. </span>msg<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.runOnlyIf<span class=E>( </span>cond<span class=O>, </span>msg <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>continue a running test if condition is met, else skip it<br>    <span class=N>if <span class=E>not <span class=C>cond </span></span>then<br>        <span class=C>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>M<span class=H>.</span>SKIP_PREFIX <span class=E>.. </span>prettystr<span class=E>(</span>msg<span class=E>))<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.success<span class=E>()<br>    <span class=U>-- </span></span></span></span></span>stops a test with a success<br>    <span class=C>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>M<span class=H>.</span>SUCCESS_PREFIX<span class=E>)<br><span class=K>end<br><br>function </span></span>M.successIf<span class=E>( </span>cond <span class=E>)<br>    <span class=U>-- </span></span></span>stops a test with a success if condition is met<br>    <span class=N>if <span class=C>cond </span>then<br>        <span class=C>error_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>M<span class=H>.</span>SUCCESS_PREFIX<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br><br><span class=U>--</span></span></span>----------------------------------------------------------------<br><span class=U>--                  </span>Equality assertions<br><span class=U>--</span>----------------------------------------------------------------<br><br><span class=K>function <span class=C>M.assertEquals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=O>, </span>doDeepAnalysis<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>actual<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>        if </span></span>not </span>is_table_equals<span class=E>(</span>actual<span class=O>, </span>expected<span class=E>) <span class=N>then<br>            </span></span>failure<span class=E>( </span>errorMsgEquality<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>doDeepAnalysis<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2 <span class=E>)<br>        <span class=N>end<br>    elseif </span></span></span></span>type<span class=E>(</span>actual<span class=E>) ~= </span>type<span class=E>(</span>expected<span class=E>) <span class=N>then<br>        </span></span>failure<span class=E>( </span>errorMsgEquality<span class=E>(</span>actual<span class=O>, </span>expected<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2 <span class=E>)<br>    <span class=N>elseif </span></span></span></span>actual <span class=E>~= </span>expected <span class=N>then<br>        </span>failure<span class=E>( </span>errorMsgEquality<span class=E>(</span>actual<span class=O>, </span>expected<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2 <span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.almostEquals<span class=E>( </span>actual<span class=O>, </span>expected<span class=O>, </span>margin <span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>actual<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>type<span class=E>(</span>expected<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>type<span class=E>(</span>margin<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=N>then<br>        </span></span></span>error_fmt<span class=E>(<span class=M>3<span class=O>, <span class=B>&#39;<span class=F>almostEquals: must supply only number arguments.\nArguments supplied: %s, %s, %s</span>&#39;</span>,<br>            </span></span></span>prettystr<span class=E>(</span>actual<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>expected<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>margin<span class=E>))<br>    <span class=N>end<br>    if </span></span>margin <span class=E>&lt; <span class=M>0 <span class=N>then<br>        </span></span></span>error_fmt<span class=E>(<span class=M>3<span class=O>, <span class=B>&#39;<span class=F>almostEquals: margin must not be negative, current value is </span>&#39; </span></span></span>.. </span>margin<span class=E>)<br>    <span class=N>end<br>    </span></span></span>return <span class=C>math<span class=H>.</span>abs<span class=E>(</span>expected <span class=E>- </span>actual<span class=E>) &lt;= </span>margin<br></span>end<br><br>function <span class=C>M.assertAlmostEquals<span class=E>( </span>actual<span class=O>, </span>expected<span class=O>, </span>margin<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span>check that two floats are close by margin<br>    <span class=C>margin <span class=D>= </span>margin <span class=J>or </span>M<span class=H>.</span>EPS<br>    <span class=N>if </span>type<span class=E>(</span>margin<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=N>then<br>        </span></span></span>error_fmt<span class=E>(<span class=M>2<span class=O>, <span class=B>&#39;<span class=F>almostEquals: margin must be a number, not %s</span>&#39;</span>, </span></span></span>prettystr<span class=E>(</span>margin<span class=E>))<br>    <span class=N>end<br><br>    if </span></span>type<span class=E>(</span>actual<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>        <span class=U>-- </span></span></span></span></span>handle almost equals for table<br>        <span class=N>if <span class=E>not <span class=C>is_table_equals</span>(<span class=C>actual<span class=O>, </span>expected<span class=O>, </span>margin</span>) </span>then<br>            <span class=C>failure<span class=E>( </span>errorMsgEquality<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, <span class=L>nil</span>, </span>margin<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2 <span class=E>)<br>        </span></span></span></span>end<br>    elseif <span class=C>type<span class=E>(</span>actual<span class=E>) == <span class=B>&#39;<span class=F>number</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>number</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>margin<span class=E>) == <span class=B>&#39;<span class=F>number</span>&#39; </span></span></span>then<br>        if <span class=E>not <span class=C>M<span class=H>.</span>almostEquals</span>(<span class=C>actual<span class=O>, </span>expected<span class=O>, </span>margin</span>) </span>then<br>            if <span class=E>not <span class=C>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED </span></span>then<br>                <span class=C>expected<span class=O>, </span>actual <span class=D>= </span>actual<span class=O>, </span>expected<br>            </span>end<br>            <span class=G>local <span class=C>delta <span class=D>= </span>math<span class=H>.</span>abs<span class=E>(</span>actual <span class=E>- </span>expected<span class=E>) <br>            </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Values are not almost equal\n</span>&#39; <span class=E>..<br>                        </span>&#39;<span class=F>Actual: %s, expected: %s, delta %s above margin of %s</span>&#39;</span>,<br>                        </span>actual<span class=O>, </span>expected<span class=O>, </span>delta<span class=O>, </span>margin<span class=E>)<br>        </span></span></span>end<br>    else<br>        <span class=C>error_fmt<span class=E>(<span class=M>3<span class=O>, <span class=B>&#39;<span class=F>almostEquals: must supply only number or table arguments.\nArguments supplied: %s, %s, %s</span>&#39;</span>,<br>            </span></span></span>prettystr<span class=E>(</span>actual<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>expected<span class=E>)<span class=O>, </span></span>prettystr<span class=E>(</span>margin<span class=E>))<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertNotEquals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    </span></span></span>if <span class=C>type<span class=E>(</span>actual<span class=E>) ~= </span>type<span class=E>(</span>expected<span class=E>) </span></span>then<br>        <span class=K>return<br>    </span>end<br><br>    if <span class=C>type<span class=E>(</span>actual<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>expected<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; </span></span></span>then<br>        if <span class=E>not <span class=C>is_table_equals</span>(<span class=C>actual<span class=O>, </span>expected</span>) </span>then<br>            <span class=K>return<br>        </span>end<br>    elseif <span class=C>actual <span class=E>~= </span>expected </span>then<br>        <span class=K>return<br>    </span>end<br>    <span class=C>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Received the not expected value: %s</span>&#39;</span>, </span>prettystr<span class=E>(</span>actual<span class=E>))<br><span class=K>end<br><br>function </span></span>M.assertNotAlmostEquals<span class=E>( </span>actual<span class=O>, </span>expected<span class=O>, </span>margin<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span>check that two floats are not close by margin<br>    <span class=C>margin <span class=D>= </span>margin <span class=J>or </span>M<span class=H>.</span>EPS<br>    <span class=N>if </span>M<span class=H>.</span>almostEquals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>margin<span class=E>) <span class=N>then<br>        if </span>not </span>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED <span class=N>then<br>            </span>expected<span class=O>, </span>actual <span class=D>= </span>actual<span class=O>, </span>expected<br>        <span class=N>end<br>        <span class=G>local </span></span>delta <span class=D>= </span>math<span class=H>.</span>abs<span class=E>(</span>actual <span class=E>- </span>expected<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Values are almost equal\nActual: %s, expected: %s</span>&#39; <span class=E>..<br>                    </span>&#39;<span class=F>, delta %s below margin of %s</span>&#39;</span>,<br>                    </span>actual<span class=O>, </span>expected<span class=O>, </span>delta<span class=O>, </span>margin<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span>M.assertItemsEquals<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=U>-- </span></span></span>checks that the items of table expected<br>    <span class=U>-- </span>are contained in table actual. Warning, this function<br>    <span class=U>-- </span>is at least O(n^2)<br>    <span class=N>if <span class=E>not <span class=C>_is_table_items_equals</span>(<span class=C>actual<span class=O>, </span>expected </span>) </span>then<br>        <span class=C>expected<span class=O>, </span>actual <span class=D>= </span>prettystrPairs<span class=E>(</span>expected<span class=O>, </span>actual<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Content of the tables are not identical:\nExpected: %s\nActual: %s</span>&#39;</span>,<br>                 </span>expected<span class=O>, </span>actual<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br><span class=U>--</span></span></span>----------------------------------------------------------------<br><span class=U>--                  </span>String assertion<br><span class=U>--</span>----------------------------------------------------------------<br><br><span class=K>function <span class=C>M.assertStrContains<span class=E>( </span>str<span class=O>, </span>sub<span class=O>, </span>isPattern<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span>this relies on lua string.find function<br>    <span class=U>-- </span>a string always contains the empty string<br>    <span class=U>-- </span>assert( type(str) == &#39;string&#39;, &#39;Argument 1 of assertStrContains() should be a string.&#39; ) )<br>    <span class=U>-- </span>assert( type(sub) == &#39;string&#39;, &#39;Argument 2 of assertStrContains() should be a string.&#39; ) )<br>    <span class=N>if <span class=E>not <span class=C>string<span class=H>.</span>find</span>(<span class=C>str<span class=O>, </span>sub<span class=O>, <span class=M>1</span>, </span></span>not <span class=C>isPattern</span>) </span>then<br>        <span class=C>sub<span class=O>, </span>str <span class=D>= </span>prettystrPairs<span class=E>(</span>sub<span class=O>, </span>str<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br>        </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Could not find %s %s in string %s</span>&#39;</span>,<br>                 </span>isPattern <span class=I>and <span class=B>&#39;<span class=F>pattern</span>&#39; <span class=J>or </span>&#39;<span class=F>substring</span>&#39;<span class=O>, </span></span></span>sub<span class=O>, </span>str<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertStrIContains<span class=E>( </span>str<span class=O>, </span>sub<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>this relies on lua string.find function<br>    <span class=U>-- </span>a string always contains the empty string<br>    <span class=N>if <span class=E>not <span class=C>string<span class=H>.</span>find</span>(<span class=C>str<span class=H>:</span>lower</span>()<span class=O>, <span class=C>sub<span class=H>:</span>lower</span></span>()<span class=O>, <span class=M>1</span>, <span class=L>true</span></span>) </span>then<br>        <span class=C>sub<span class=O>, </span>str <span class=D>= </span>prettystrPairs<span class=E>(</span>sub<span class=O>, </span>str<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br>        </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Could not find (case insensitively) substring %s in string %s</span>&#39;</span>,<br>                 </span>sub<span class=O>, </span>str<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertNotStrContains<span class=E>( </span>str<span class=O>, </span>sub<span class=O>, </span>isPattern<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>this relies on lua string.find function<br>    <span class=U>-- </span>a string always contains the empty string<br>    <span class=N>if <span class=C>string<span class=H>.</span>find<span class=E>(</span>str<span class=O>, </span>sub<span class=O>, <span class=M>1</span>, <span class=E>not </span></span>isPattern<span class=E>) </span></span>then<br>        <span class=C>sub<span class=O>, </span>str <span class=D>= </span>prettystrPairs<span class=E>(</span>sub<span class=O>, </span>str<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br>        </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Found the not expected %s %s in string %s</span>&#39;</span>,<br>                 </span>isPattern <span class=I>and <span class=B>&#39;<span class=F>pattern</span>&#39; <span class=J>or </span>&#39;<span class=F>substring</span>&#39;<span class=O>, </span></span></span>sub<span class=O>, </span>str<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertNotStrIContains<span class=E>( </span>str<span class=O>, </span>sub<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>this relies on lua string.find function<br>    <span class=U>-- </span>a string always contains the empty string<br>    <span class=N>if <span class=C>string<span class=H>.</span>find<span class=E>(</span>str<span class=H>:</span>lower<span class=E>()<span class=O>, </span></span>sub<span class=H>:</span>lower<span class=E>()<span class=O>, <span class=M>1</span>, <span class=L>true</span></span>) </span></span>then<br>        <span class=C>sub<span class=O>, </span>str <span class=D>= </span>prettystrPairs<span class=E>(</span>sub<span class=O>, </span>str<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br>        </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Found (case insensitively) the not expected substring %s in string %s</span>&#39;</span>,<br>                 </span>sub<span class=O>, </span>str<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertStrMatches<span class=E>( </span>str<span class=O>, </span>pattern<span class=O>, </span>start<span class=O>, </span>final<span class=O>, </span>extra_msg_or_nil <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>Verify a full match for the string<br>    <span class=N>if <span class=E>not <span class=C>strMatch</span>( <span class=C>str<span class=O>, </span>pattern<span class=O>, </span>start<span class=O>, </span>final </span>) </span>then<br>        <span class=C>pattern<span class=O>, </span>str <span class=D>= </span>prettystrPairs<span class=E>(</span>pattern<span class=O>, </span>str<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;<span class=E>)<br>        </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Could not match pattern %s with string %s</span>&#39;</span>,<br>                 </span>pattern<span class=O>, </span>str<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>local function <span class=C>_assertErrorMsgEquals<span class=E>( </span>stripFileAndLine<span class=O>, </span>expectedMsg<span class=O>, </span>func<span class=O>, ... <span class=E>)<br>    <span class=G>local </span></span></span>no_error<span class=O>, </span>error_msg <span class=D>= </span>pcall<span class=E>( </span>func<span class=O>, ... <span class=E>)<br>    </span></span></span></span>if <span class=C>no_error </span>then<br>        <span class=C>failure<span class=E>( <span class=B>&#39;<span class=F>No error generated when calling function but expected error: </span>&#39;</span>..</span>M<span class=H>.</span>prettystr<span class=E>(</span>expectedMsg<span class=E>)<span class=O>, <span class=L>nil</span>, <span class=M>3 </span></span>)<br>    </span></span>end<br>    if <span class=C>type<span class=E>(</span>expectedMsg<span class=E>) == <span class=B>&#34;<span class=F>string</span>&#34; <span class=I>and </span></span></span>type<span class=E>(</span>error_msg<span class=E>) ~= <span class=B>&#34;<span class=F>string</span>&#34; </span></span></span>then<br>        <span class=U>-- </span></span>table are converted to string automatically<br>        <span class=C>error_msg <span class=D>= </span>tostring<span class=E>(</span>error_msg<span class=E>)<br>    <span class=N>end<br>    <span class=G>local </span></span></span>differ <span class=D>= <span class=L>false<br>    <span class=N>if </span></span></span>stripFileAndLine <span class=N>then<br>        if </span>error_msg<span class=H>:</span>gsub<span class=E>(<span class=B>&#34;<span class=F>^.+:%d+: </span>&#34;<span class=O>, </span>&#34;&#34;</span>) ~= </span>expectedMsg <span class=N>then<br>            </span>differ <span class=D>= <span class=L>true<br>        <span class=N>end<br>    else<br>        if </span></span></span>error_msg <span class=E>~= </span>expectedMsg <span class=N>then<br>            <span class=G>local </span></span>tr <span class=D>= </span>type<span class=E>(</span>error_msg<span class=E>)<br>            <span class=G>local </span></span>te <span class=D>= </span>type<span class=E>(</span>expectedMsg<span class=E>)<br>            <span class=N>if </span></span>te <span class=E>== <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>                if </span></span></span>tr <span class=E>~= <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>                    </span></span></span>differ <span class=D>= <span class=L>true<br>                <span class=N>else<br>                     <span class=G>local </span></span></span></span>ok <span class=D>= </span>pcall<span class=E>(</span>M<span class=H>.</span>assertItemsEquals<span class=O>, </span>error_msg<span class=O>, </span>expectedMsg<span class=E>)<br>                     <span class=N>if </span>not </span>ok <span class=N>then<br>                         </span>differ <span class=D>= <span class=L>true<br>                     <span class=N>end<br>                end<br>            else<br>               </span></span></span>differ <span class=D>= <span class=L>true<br>            <span class=N>end<br>        end<br>    end<br><br>    if </span></span></span>differ <span class=N>then<br>        </span>error_msg<span class=O>, </span>expectedMsg <span class=D>= </span>prettystrPairs<span class=E>(</span>error_msg<span class=O>, </span>expectedMsg<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>3<span class=O>, <span class=L>nil</span>, <span class=B>&#39;<span class=F>Error message expected: %s\nError message received: %s\n</span>&#39;</span>,<br>                 </span></span></span>expectedMsg<span class=O>, </span>error_msg<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span>M.assertErrorMsgEquals<span class=E>( </span>expectedMsg<span class=O>, </span>func<span class=O>, ... <span class=E>)<br>    <span class=U>-- </span></span></span></span>assert that calling f with the arguments will raise an error<br>    <span class=U>-- </span>example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    <span class=C>_assertErrorMsgEquals<span class=E>(<span class=L>false<span class=O>, </span></span></span>expectedMsg<span class=O>, </span>func<span class=O>, ...<span class=E>)<br><span class=K>end<br><br>function </span></span></span>M.assertErrorMsgContentEquals<span class=E>(</span>expectedMsg<span class=O>, </span>func<span class=O>, ...<span class=E>)<br>     </span></span>_assertErrorMsgEquals<span class=E>(<span class=L>true<span class=O>, </span></span></span>expectedMsg<span class=O>, </span>func<span class=O>, ...<span class=E>)<br><span class=K>end<br><br>function </span></span></span>M.assertErrorMsgContains<span class=E>( </span>partialMsg<span class=O>, </span>func<span class=O>, ... <span class=E>)<br>    <span class=U>-- </span></span></span></span>assert that calling f with the arguments will raise an error<br>    <span class=U>-- </span>example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    <span class=G>local <span class=C>no_error<span class=O>, </span>error_msg <span class=D>= </span>pcall<span class=E>( </span>func<span class=O>, ... <span class=E>)<br>    <span class=N>if </span></span></span>no_error <span class=N>then<br>        </span>failure<span class=E>( <span class=B>&#39;<span class=F>No error generated when calling function but expected error containing: </span>&#39;</span>..</span>prettystr<span class=E>(</span>partialMsg<span class=E>)<span class=O>, <span class=L>nil</span>, <span class=M>2 </span></span>)<br>    <span class=N>end<br>    if </span></span>type<span class=E>(</span>error_msg<span class=E>) ~= <span class=B>&#34;<span class=F>string</span>&#34; <span class=N>then<br>        </span></span></span>error_msg <span class=D>= </span>tostring<span class=E>(</span>error_msg<span class=E>)<br>    <span class=N>end<br>    if </span>not </span>string<span class=H>.</span>find<span class=E>( </span>error_msg<span class=O>, </span>partialMsg<span class=O>, <span class=L>nil</span>, <span class=L>true <span class=E>) <span class=N>then<br>        </span></span></span></span>error_msg<span class=O>, </span>partialMsg <span class=D>= </span>prettystrPairs<span class=E>(</span>error_msg<span class=O>, </span>partialMsg<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, <span class=L>nil</span>, <span class=B>&#39;<span class=F>Error message does not contain: %s\nError message received: %s\n</span>&#39;</span>,<br>                 </span></span></span>partialMsg<span class=O>, </span>error_msg<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span>M.assertErrorMsgMatches<span class=E>( </span>expectedMsg<span class=O>, </span>func<span class=O>, ... <span class=E>)<br>    <span class=U>-- </span></span></span></span></span>assert that calling f with the arguments will raise an error<br>    <span class=U>-- </span>example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    <span class=G>local <span class=C>no_error<span class=O>, </span>error_msg <span class=D>= </span>pcall<span class=E>( </span>func<span class=O>, ... <span class=E>)<br>    <span class=N>if </span></span></span>no_error <span class=N>then<br>        </span>failure<span class=E>( <span class=B>&#39;<span class=F>No error generated when calling function but expected error matching: &#34;</span>&#39;</span>..</span>expectedMsg<span class=E>..<span class=B>&#39;<span class=F>&#34;</span>&#39;<span class=O>, <span class=L>nil</span>, <span class=M>2 </span></span></span>)<br>    <span class=N>end<br>    if </span></span>type<span class=E>(</span>error_msg<span class=E>) ~= <span class=B>&#34;<span class=F>string</span>&#34; <span class=N>then<br>        </span></span></span>error_msg <span class=D>= </span>tostring<span class=E>(</span>error_msg<span class=E>)<br>    <span class=N>end<br>    if </span>not </span>strMatch<span class=E>( </span>error_msg<span class=O>, </span>expectedMsg <span class=E>) <span class=N>then<br>        </span></span>expectedMsg<span class=O>, </span>error_msg <span class=D>= </span>prettystrPairs<span class=E>(</span>expectedMsg<span class=O>, </span>error_msg<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, <span class=L>nil</span>, <span class=B>&#39;<span class=F>Error message does not match pattern: %s\nError message received: %s\n</span>&#39;</span>,<br>                 </span></span></span>expectedMsg<span class=O>, </span>error_msg<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br><span class=U>--</span></span></span></span></span></span>----------------------------------------------------------------<br><span class=U>--              </span>Type assertions<br><span class=U>--</span>----------------------------------------------------------------<br><br><span class=K>function <span class=C>M.assertEvalToTrue<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span>not </span>value <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: a value evaluating to true, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertEvalToFalse<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: false or nil, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsTrue<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>~= <span class=L>true <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: true, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsTrue<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>== <span class=L>true <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not true, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsFalse<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>~= <span class=L>false <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: false, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsFalse<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>== <span class=L>false <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not false, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsNil<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>~= <span class=L>nil <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: nil, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsNil<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>value <span class=E>== <span class=L>nil <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not nil, actual: nil</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br><span class=U>--[[<br></span></span>Add type assertion functions to the module table M. Each of these functions<br>takes a single parameter &#34;value&#34;, and checks that its Lua type matches the<br>expected string (derived from the function name):<br><br>M.assertIsXxx(value) -&gt; ensure that type(value) conforms to &#34;xxx&#34;<br><span class=U>]]<br><span class=N>for <span class=C>_<span class=O>, </span>funcName </span>in <span class=C>ipairs<span class=E>(<br>    {<span class=B>&#39;<span class=F>assertIsNumber</span>&#39;<span class=O>, </span>&#39;<span class=F>assertIsString</span>&#39;<span class=O>, </span>&#39;<span class=F>assertIsTable</span>&#39;<span class=O>, </span>&#39;<span class=F>assertIsBoolean</span>&#39;<span class=O>,<br>     </span>&#39;<span class=F>assertIsFunction</span>&#39;<span class=O>, </span>&#39;<span class=F>assertIsUserdata</span>&#39;<span class=O>, </span>&#39;<span class=F>assertIsThread</span>&#39;</span>}<br>) </span></span>do<br>    <span class=G>local <span class=C>typeExpected <span class=D>= </span>funcName<span class=H>:</span>match<span class=E>(<span class=B>&#34;<span class=F>^assertIs([A-Z]%a*)$</span>&#34;</span>)<br>    </span></span></span></span>-- </span>Lua type() always returns lowercase, also make sure the match() succeeded<br>    <span class=C>typeExpected <span class=D>= </span>typeExpected <span class=I>and </span>typeExpected<span class=H>:</span>lower<span class=E>()<br>                   <span class=J>or </span></span>error<span class=E>(<span class=B>&#34;<span class=F>bad function name &#39;</span>&#34;</span>..</span>funcName<span class=E>..<span class=B>&#34;<span class=F>&#39; for type assertion</span>&#34;</span>)<br><br>    </span>M<span class=E>[</span>funcName<span class=E>] <span class=D>= <span class=K>function</span></span>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>        <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= </span>typeExpected <span class=N>then<br>            if </span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#39;<span class=F>nil</span>&#39; <span class=N>then<br>                </span></span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>expected: a %s value, actual: nil</span>&#39;</span>,<br>                         </span>typeExpected<span class=O>, </span>type<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>prettystrPairs<span class=E>(</span>value<span class=E>))<br>            <span class=N>else<br>                </span></span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>expected: a %s value, actual: type %s, value %s</span>&#39;</span>,<br>                         </span>typeExpected<span class=O>, </span>type<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>prettystrPairs<span class=E>(</span>value<span class=E>))<br>            <span class=N>end<br>        end<br>    <span class=K>end<br></span>end<br><br><span class=U>--[[<br></span></span></span></span>Add shortcuts for verifying type of a variable, without failure (luaunit v2 compatibility)<br>M.isXxx(value) -&gt; returns true if type(value) conforms to &#34;xxx&#34;<br><span class=U>]]<br><span class=N>for <span class=C>_<span class=O>, </span>typeExpected </span>in <span class=C>ipairs<span class=E>(<br>    {<span class=B>&#39;<span class=F>Number</span>&#39;<span class=O>, </span>&#39;<span class=F>String</span>&#39;<span class=O>, </span>&#39;<span class=F>Table</span>&#39;<span class=O>, </span>&#39;<span class=F>Boolean</span>&#39;<span class=O>,<br>     </span>&#39;<span class=F>Function</span>&#39;<span class=O>, </span>&#39;<span class=F>Userdata</span>&#39;<span class=O>, </span>&#39;<span class=F>Thread</span>&#39;<span class=O>, </span>&#39;<span class=F>Nil</span>&#39; </span>}<br>) </span></span>do<br>    <span class=G>local <span class=C>typeExpectedLower <span class=D>= </span>typeExpected<span class=H>:</span>lower<span class=E>()<br>    </span></span>local <span class=C>isType <span class=D>= <span class=K>function<span class=E>(</span></span></span>value<span class=E>)<br>        <span class=K>return </span>(</span>type<span class=E>(</span>value<span class=E>) == </span>typeExpectedLower<span class=E>)<br>    <span class=K>end<br>    </span></span>M<span class=E>[<span class=B>&#39;<span class=F>is</span>&#39;</span>..</span>typeExpected<span class=E>] <span class=D>= </span></span>isType<br>    M<span class=E>[<span class=B>&#39;<span class=F>is_</span>&#39;</span>..</span>typeExpectedLower<span class=E>] <span class=D>= </span></span>isType<br></span></span>end<br><br></span>--[[<br></span>Add non-type assertion functions to the module table M. Each of these functions<br>takes a single parameter &#34;value&#34;, and checks that its Lua type differs from the<br>expected string (derived from the function name):<br><br>M.assertNotIsXxx(value) -&gt; ensure that type(value) is not &#34;xxx&#34;<br><span class=U>]]<br><span class=N>for <span class=C>_<span class=O>, </span>funcName </span>in <span class=C>ipairs<span class=E>(<br>    {<span class=B>&#39;<span class=F>assertNotIsNumber</span>&#39;<span class=O>, </span>&#39;<span class=F>assertNotIsString</span>&#39;<span class=O>, </span>&#39;<span class=F>assertNotIsTable</span>&#39;<span class=O>, </span>&#39;<span class=F>assertNotIsBoolean</span>&#39;<span class=O>,<br>     </span>&#39;<span class=F>assertNotIsFunction</span>&#39;<span class=O>, </span>&#39;<span class=F>assertNotIsUserdata</span>&#39;<span class=O>, </span>&#39;<span class=F>assertNotIsThread</span>&#39;</span>}<br>) </span></span>do<br>    <span class=G>local <span class=C>typeUnexpected <span class=D>= </span>funcName<span class=H>:</span>match<span class=E>(<span class=B>&#34;<span class=F>^assertNotIs([A-Z]%a*)$</span>&#34;</span>)<br>    </span></span></span></span>-- </span>Lua type() always returns lowercase, also make sure the match() succeeded<br>    <span class=C>typeUnexpected <span class=D>= </span>typeUnexpected <span class=I>and </span>typeUnexpected<span class=H>:</span>lower<span class=E>()<br>                   <span class=J>or </span></span>error<span class=E>(<span class=B>&#34;<span class=F>bad function name &#39;</span>&#34;</span>..</span>funcName<span class=E>..<span class=B>&#34;<span class=F>&#39; for type assertion</span>&#34;</span>)<br><br>    </span>M<span class=E>[</span>funcName<span class=E>] <span class=D>= <span class=K>function</span></span>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>        <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == </span>typeUnexpected <span class=N>then<br>            </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>expected: not a %s type, actual: value %s</span>&#39;</span>,<br>                     </span>typeUnexpected<span class=O>, </span>prettystrPairs<span class=E>(</span>value<span class=E>))<br>        <span class=N>end<br>    <span class=K>end<br></span>end<br><br><span class=K>function </span></span></span>M.assertIs<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>actual <span class=E>~= </span>expected <span class=N>then<br>        if <span class=E>not </span></span>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED <span class=N>then<br>            </span>actual<span class=O>, </span>expected <span class=D>= </span>expected<span class=O>, </span>actual<br>        <span class=N>end<br>        <span class=G>local </span></span>old_print_table_ref_in_error_msg <span class=D>= </span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG<br>        M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=D>= <span class=L>true<br>        </span></span>expected<span class=O>, </span>actual <span class=D>= </span>prettystrPairs<span class=E>(</span>expected<span class=O>, </span>actual<span class=O>, <span class=B>&#39;<span class=F>\n</span>&#39;</span>, <span class=B>&#39;&#39;<span class=E>)<br>        </span></span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=D>= </span>old_print_table_ref_in_error_msg<br>        fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>expected and actual object should not be different\nExpected: %s\nReceived: %s</span>&#39;</span>,<br>                 </span>expected<span class=O>, </span>actual<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span>M.assertNotIs<span class=E>(</span>actual<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>actual <span class=E>== </span>expected <span class=N>then<br>        <span class=G>local </span></span>old_print_table_ref_in_error_msg <span class=D>= </span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG<br>        M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=D>= <span class=L>true<br>        <span class=G>local </span></span></span>s_expected<br>        <span class=N>if <span class=E>not </span></span>M<span class=H>.</span>ORDER_ACTUAL_EXPECTED <span class=N>then<br>            </span>s_expected <span class=D>= </span>prettystrPairs<span class=E>(</span>actual<span class=E>)<br>        <span class=N>else<br>            </span></span>s_expected <span class=D>= </span>prettystrPairs<span class=E>(</span>expected<span class=E>)<br>        <span class=N>end<br>        </span></span>M<span class=H>.</span>PRINT_TABLE_REF_IN_ERROR_MSG <span class=D>= </span>old_print_table_ref_in_error_msg<br>        fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>expected and actual object should be different: %s</span>&#39;</span>, </span>s_expected <span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br><br><span class=U>--</span></span></span></span></span>----------------------------------------------------------------<br><span class=U>--              </span>Scientific assertions<br><span class=U>--</span>----------------------------------------------------------------<br><br><br><span class=K>function <span class=C>M.assertIsNaN<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#34;<span class=F>number</span>&#34; <span class=J>or </span></span></span>value <span class=E>== </span>value <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: NaN, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsNaN<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#34;<span class=F>number</span>&#34; <span class=I>and </span></span></span>value <span class=E>~= </span>value <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not NaN, actual: NaN</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#34;<span class=F>number</span>&#34; <span class=J>or </span></span></span>math<span class=H>.</span>abs<span class=E>(</span>value<span class=E>) ~= </span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: #Inf, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsPlusInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#34;<span class=F>number</span>&#34; <span class=J>or </span></span></span>value <span class=E>~= </span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: #Inf, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsMinusInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#34;<span class=F>number</span>&#34; <span class=J>or </span></span></span>value <span class=E>~= -</span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: -#Inf, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsPlusInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#34;<span class=F>number</span>&#34; <span class=I>and </span></span></span>value <span class=E>== </span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not #Inf, actual: #Inf</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsMinusInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#34;<span class=F>number</span>&#34; <span class=I>and </span></span></span>value <span class=E>== -</span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not -#Inf, actual: -#Inf</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertNotIsInf<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#34;<span class=F>number</span>&#34; <span class=I>and </span></span></span>math<span class=H>.</span>abs<span class=E>(</span>value<span class=E>) == </span>math<span class=H>.</span>huge <span class=N>then<br>        </span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not infinity, actual: </span>&#34; </span>.. </span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br></span></span></span></span></span>end<br><br>function <span class=C>M.assertIsPlusZero<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>value <span class=E>~= <span class=M>0 <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: +0.0, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>else if </span>(</span>1<span class=E>/</span></span></span>value <span class=E>== -</span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>            <span class=U>-- </span></span></span></span></span>more precise error diagnosis<br>            <span class=C>failure<span class=E>(<span class=B>&#34;<span class=F>expected: +0.0, actual: -0.0</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>        <span class=N>else if </span>(</span>1<span class=E>/</span></span></span>value <span class=E>~= </span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>                <span class=U>-- </span></span></span></span>strange, case should have already been covered<br>                <span class=C>failure<span class=E>(<span class=B>&#34;<span class=F>expected: +0.0, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>            <span class=N>end<br>        end<br>    end<br><span class=K>end<br><br>function </span></span></span></span></span>M.assertIsMinusZero<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) ~= <span class=B>&#39;<span class=F>number</span>&#39; <span class=J>or </span></span></span>value <span class=E>~= <span class=M>0 <span class=N>then<br>        </span></span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: -0.0, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>else if </span>(</span>1<span class=E>/</span></span></span>value <span class=E>== </span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>            <span class=U>-- </span></span></span></span>more precise error diagnosis<br>            <span class=C>failure<span class=E>(<span class=B>&#34;<span class=F>expected: -0.0, actual: +0.0</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>        <span class=N>else if </span>(</span>1<span class=E>/</span></span></span>value <span class=E>~= -</span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>                <span class=U>-- </span></span></span></span>strange, case should have already been covered<br>                <span class=C>failure<span class=E>(<span class=B>&#34;<span class=F>expected: -0.0, actual: </span>&#34; </span>..</span>prettystr<span class=E>(</span>value<span class=E>)<span class=O>, </span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>            <span class=N>end<br>        end<br>    end<br><span class=K>end<br><br>function </span></span></span></span></span>M.assertNotIsPlusZero<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#39;<span class=F>number</span>&#39; <span class=I>and </span></span>(<span class=M>1</span>/</span>value <span class=E>== </span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>        </span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not +0.0, actual: +0.0</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span></span></span>M.assertNotIsMinusZero<span class=E>(</span>value<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=N>if </span></span>type<span class=E>(</span>value<span class=E>) == <span class=B>&#39;<span class=F>number</span>&#39; <span class=I>and </span></span>(<span class=M>1</span>/</span>value <span class=E>== -</span>math<span class=H>.</span>huge<span class=E>) <span class=N>then<br>        </span></span>failure<span class=E>(<span class=B>&#34;<span class=F>expected: not -0.0, actual: -0.0</span>&#34;<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=M>2<span class=E>)<br>    <span class=N>end<br><span class=K>end<br><br>function </span></span></span></span></span>M.assertTableContains<span class=E>(</span>t<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=U>-- </span></span></span>checks that table t contains the expected element<br>    <span class=N>if <span class=C>table_findkeyof<span class=E>(</span>t<span class=O>, </span>expected<span class=E>) == <span class=L>nil </span></span></span>then<br>        <span class=C>t<span class=O>, </span>expected <span class=D>= </span>prettystrPairs<span class=E>(</span>t<span class=O>, </span>expected<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Table %s does NOT contain the expected element %s</span>&#39;</span>,<br>                 </span>t<span class=O>, </span>expected<span class=E>)<br>    </span></span>end<br><span class=K>end<br><br>function <span class=C>M.assertNotTableContains<span class=E>(</span>t<span class=O>, </span>expected<span class=O>, </span>extra_msg_or_nil<span class=E>)<br>    <span class=U>-- </span></span></span></span></span>checks that table t doesn&#39;t contain the expected element<br>    <span class=G>local <span class=C>k <span class=D>= </span>table_findkeyof<span class=E>(</span>t<span class=O>, </span>expected<span class=E>)<br>    <span class=N>if </span></span>k <span class=E>~= <span class=L>nil <span class=N>then<br>        </span></span></span>t<span class=O>, </span>expected <span class=D>= </span>prettystrPairs<span class=E>(</span>t<span class=O>, </span>expected<span class=E>)<br>        </span>fail_fmt<span class=E>(<span class=M>2<span class=O>, </span></span></span>extra_msg_or_nil<span class=O>, <span class=B>&#39;<span class=F>Table %s DOES contain the unwanted element %s (at key %s)</span>&#39;</span>,<br>                 </span>t<span class=O>, </span>expected<span class=O>, </span>prettystr<span class=E>(</span>k<span class=E>))<br>    <span class=N>end<br><span class=K>end<br><br><span class=U>--</span></span></span></span></span></span>--------------------------------------------------------------<br><span class=U>--                     </span>Compatibility layer<br><span class=U>--</span>--------------------------------------------------------------<br><br><span class=U>-- </span>for compatibility with LuaUnit v2.x<br><span class=K>function <span class=C>M.wrapFunctions<span class=E>()<br>    <span class=U>-- </span></span></span></span>In LuaUnit version &lt;= 2.1 , this function was necessary to include<br>    <span class=U>-- </span>a test function inside the global test suite. Nowadays, the functions<br>    <span class=U>-- </span>are simply run directly as part of the test discovery process.<br>    <span class=U>-- </span>so just do nothing !<br>    <span class=C>io<span class=H>.</span>stderr<span class=H>:</span>write<span class=B>[[<span class=F>Use of WrapFunctions() is no longer needed.<br>Just prefix your test function names with &#34;test&#34; or &#34;Test&#34; and they<br>will be picked up and run by LuaUnit.<br></span>]]<br><span class=K>end<br><br><span class=G>local </span></span></span>list_of_funcs <span class=D>= <span class=E>{<br>    <span class=A>-- { official function name , alias }<br><br>    -- general assertions<br>    </span>{ <span class=B>&#39;<span class=F>assertEquals</span>&#39;            <span class=O>, </span>&#39;<span class=F>assert_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertItemsEquals</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_items_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotEquals</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_not_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertAlmostEquals</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_almost_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotAlmostEquals</span>&#39;   <span class=O>, </span>&#39;<span class=F>assert_not_almost_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertEvalToTrue</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_eval_to_true</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertEvalToFalse</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_eval_to_false</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertStrContains</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_str_contains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertStrIContains</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_str_icontains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotStrContains</span>&#39;    <span class=O>, </span>&#39;<span class=F>assert_not_str_contains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotStrIContains</span>&#39;   <span class=O>, </span>&#39;<span class=F>assert_not_str_icontains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertStrMatches</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_str_matches</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertError</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_error</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertErrorMsgEquals</span>&#39;    <span class=O>, </span>&#39;<span class=F>assert_error_msg_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertErrorMsgContains</span>&#39;  <span class=O>, </span>&#39;<span class=F>assert_error_msg_contains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertErrorMsgMatches</span>&#39;   <span class=O>, </span>&#39;<span class=F>assert_error_msg_matches</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertErrorMsgContentEquals</span>&#39;<span class=O>, </span>&#39;<span class=F>assert_error_msg_content_equals</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIs</span>&#39;                <span class=O>, </span>&#39;<span class=F>assert_is</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIs</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_not_is</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertTableContains</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_table_contains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotTableContains</span>&#39;  <span class=O>, </span>&#39;<span class=F>assert_not_table_contains</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>wrapFunctions</span>&#39;           <span class=O>, </span>&#39;<span class=F>WrapFunctions</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>wrapFunctions</span>&#39;           <span class=O>, </span>&#39;<span class=F>wrap_functions</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertIsXXX -&gt; assert_is_xxx<br>    </span></span>{ <span class=B>&#39;<span class=F>assertIsNumber</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_is_number</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsString</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_is_string</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTable</span>&#39;           <span class=O>, </span>&#39;<span class=F>assert_is_table</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsBoolean</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_is_boolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNil</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_is_nil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTrue</span>&#39;            <span class=O>, </span>&#39;<span class=F>assert_is_true</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFalse</span>&#39;           <span class=O>, </span>&#39;<span class=F>assert_is_false</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNaN</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_is_nan</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsInf</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_is_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusInf</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_is_plus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusInf</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_is_minus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusZero</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_is_plus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusZero</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_is_minus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFunction</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_is_function</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_is_thread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsUserdata</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_is_userdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertIsXXX -&gt; assertXxx<br>    </span></span>{ <span class=B>&#39;<span class=F>assertIsNumber</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertNumber</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsString</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertString</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTable</span>&#39;           <span class=O>, </span>&#39;<span class=F>assertTable</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsBoolean</span>&#39;         <span class=O>, </span>&#39;<span class=F>assertBoolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNil</span>&#39;             <span class=O>, </span>&#39;<span class=F>assertNil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTrue</span>&#39;            <span class=O>, </span>&#39;<span class=F>assertTrue</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFalse</span>&#39;           <span class=O>, </span>&#39;<span class=F>assertFalse</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNaN</span>&#39;             <span class=O>, </span>&#39;<span class=F>assertNaN</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsInf</span>&#39;             <span class=O>, </span>&#39;<span class=F>assertInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusInf</span>&#39;         <span class=O>, </span>&#39;<span class=F>assertPlusInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusInf</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertMinusInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusZero</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertPlusZero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusZero</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertMinusZero</span>&#39;</span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFunction</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertFunction</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertThread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsUserdata</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertUserdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertIsXXX -&gt; assert_xxx (luaunit v2 compat)<br>    </span></span>{ <span class=B>&#39;<span class=F>assertIsNumber</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_number</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsString</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_string</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTable</span>&#39;           <span class=O>, </span>&#39;<span class=F>assert_table</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsBoolean</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_boolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNil</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_nil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsTrue</span>&#39;            <span class=O>, </span>&#39;<span class=F>assert_true</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFalse</span>&#39;           <span class=O>, </span>&#39;<span class=F>assert_false</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsNaN</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_nan</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsInf</span>&#39;             <span class=O>, </span>&#39;<span class=F>assert_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusInf</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_plus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusInf</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_minus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsPlusZero</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_plus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsMinusZero</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_minus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsFunction</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_function</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_thread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsUserdata</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_userdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertNotIsXXX -&gt; assert_not_is_xxx<br>    </span></span>{ <span class=B>&#39;<span class=F>assertNotIsNumber</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_is_number</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsString</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_is_string</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTable</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_not_is_table</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsBoolean</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_not_is_boolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNil</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_is_nil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTrue</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_not_is_true</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFalse</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_not_is_false</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNaN</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_is_nan</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsInf</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_is_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusInf</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_not_plus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusInf</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_minus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusZero</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_plus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusZero</span>&#39;    <span class=O>, </span>&#39;<span class=F>assert_not_minus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFunction</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_is_function</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_is_thread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsUserdata</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_is_userdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertNotIsXXX -&gt; assertNotXxx (luaunit v2 compat)<br>    </span></span>{ <span class=B>&#39;<span class=F>assertNotIsNumber</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertNotNumber</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsString</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertNotString</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTable</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertNotTable</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsBoolean</span>&#39;      <span class=O>, </span>&#39;<span class=F>assertNotBoolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNil</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertNotNil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTrue</span>&#39;         <span class=O>, </span>&#39;<span class=F>assertNotTrue</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFalse</span>&#39;        <span class=O>, </span>&#39;<span class=F>assertNotFalse</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNaN</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertNotNaN</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsInf</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertNotInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusInf</span>&#39;      <span class=O>, </span>&#39;<span class=F>assertNotPlusInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusInf</span>&#39;     <span class=O>, </span>&#39;<span class=F>assertNotMinusInf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusZero</span>&#39;     <span class=O>, </span>&#39;<span class=F>assertNotPlusZero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusZero</span>&#39;    <span class=O>, </span>&#39;<span class=F>assertNotMinusZero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFunction</span>&#39;     <span class=O>, </span>&#39;<span class=F>assertNotFunction</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertNotThread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsUserdata</span>&#39;     <span class=O>, </span>&#39;<span class=F>assertNotUserdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- type assertions: assertNotIsXXX -&gt; assert_not_xxx<br>    </span></span>{ <span class=B>&#39;<span class=F>assertNotIsNumber</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_number</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsString</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_string</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTable</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_not_table</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsBoolean</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_not_boolean</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNil</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_nil</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsTrue</span>&#39;         <span class=O>, </span>&#39;<span class=F>assert_not_true</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFalse</span>&#39;        <span class=O>, </span>&#39;<span class=F>assert_not_false</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsNaN</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_nan</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsInf</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_not_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusInf</span>&#39;      <span class=O>, </span>&#39;<span class=F>assert_not_plus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusInf</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_minus_inf</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsPlusZero</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_plus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsMinusZero</span>&#39;    <span class=O>, </span>&#39;<span class=F>assert_not_minus_zero</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsFunction</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_function</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_thread</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsUserdata</span>&#39;     <span class=O>, </span>&#39;<span class=F>assert_not_userdata</span>&#39; </span>}<span class=O>,<br><br>    <span class=A>-- all assertions with Coroutine duplicate Thread assertions<br>    </span></span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertIsCoroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assertCoroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_is_coroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertIsThread</span>&#39;          <span class=O>, </span>&#39;<span class=F>assert_coroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertNotIsCoroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assertNotCoroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_is_coroutine</span>&#39; </span>}<span class=O>,<br>    </span>{ <span class=B>&#39;<span class=F>assertNotIsThread</span>&#39;       <span class=O>, </span>&#39;<span class=F>assert_not_coroutine</span>&#39; </span>}<span class=O>,<br></span>}<br><br><span class=U>-- </span></span></span></span>Create all aliases in M<br><span class=N>for <span class=C>_<span class=O>,</span>v </span>in <span class=C>ipairs<span class=E>( </span>list_of_funcs <span class=E>) </span></span>do<br>    <span class=G>local <span class=C>funcname<span class=O>, </span>alias <span class=D>= </span>v<span class=E>[<span class=M>1</span>]<span class=O>, </span></span>v<span class=E>[<span class=M>2</span>]<br>    </span>M<span class=E>[</span>alias<span class=E>] <span class=D>= </span></span>M<span class=E>[</span>funcname<span class=E>]<br><br>    </span></span></span>if <span class=C>EXPORT_ASSERT_TO_GLOBALS </span>then<br>        <span class=C>_G<span class=E>[</span>funcname<span class=E>] <span class=D>= </span></span>M<span class=E>[</span>funcname<span class=E>]<br>        </span>_G<span class=E>[</span>alias<span class=E>] <span class=D>= </span></span>M<span class=E>[</span>funcname<span class=E>]<br>    </span></span>end<br>end<br><br><span class=U>--</span></span>--------------------------------------------------------------<br><span class=U>--<br>--                     </span>Outputters<br><span class=U>--<br>--</span>--------------------------------------------------------------<br><br><span class=U>-- </span>A common &#34;base&#34; class for outputters<br><span class=U>-- </span>For concepts involved (class inheritance) see http://www.lua.org/pil/16.2.html<br><br><span class=G>local <span class=C>genericOutput <span class=D>= <span class=E>{ <span class=P>__class__ </span></span>= <span class=B>&#39;<span class=F>genericOutput</span>&#39; <span class=E>} <span class=U>-- </span></span></span></span></span></span>class<br><span class=G>local <span class=C>genericOutput_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>genericOutput <span class=E>} <span class=U>-- </span></span></span></span>metatable<br><span class=C>M<span class=H>.</span>genericOutput <span class=D>= </span>genericOutput <span class=U>-- </span></span>publish, so that custom classes may derive from it<br><br><span class=K>function <span class=C>genericOutput.new<span class=E>(</span>runner<span class=O>, </span>default_verbosity<span class=E>)<br>    <span class=U>-- </span></span></span></span>runner is the &#34;parent&#34; object controlling the output, usually a LuaUnit instance<br>    <span class=G>local <span class=C>t <span class=D>= <span class=E>{ <span class=P>runner </span></span>= </span>runner <span class=E>}<br>    <span class=N>if </span></span>runner <span class=N>then<br>        </span>t<span class=H>.</span>result <span class=D>= </span>runner<span class=H>.</span>result<br>        t<span class=H>.</span>verbosity <span class=D>= </span>runner<span class=H>.</span>verbosity <span class=J>or </span>default_verbosity<br>        t<span class=H>.</span>fname <span class=D>= </span>runner<span class=H>.</span>fname<br>    <span class=N>else<br>        </span>t<span class=H>.</span>verbosity <span class=D>= </span>default_verbosity<br>    <span class=N>end<br>    <span class=K>return </span></span>setmetatable<span class=E>( </span>t<span class=O>, </span>genericOutput_MT<span class=E>)<br><span class=K>end<br><br><span class=U>-- </span></span></span></span></span>abstract (&#34;empty&#34;) methods<br><span class=K>function <span class=C>genericOutput:startSuite<span class=E>() <br>    <span class=U>-- </span></span></span></span>Called once, when the suite is started<br><span class=K>end<br><br>function <span class=C>genericOutput:startClass<span class=E>(</span>className<span class=E>) <br>    <span class=U>-- </span></span></span></span>Called each time a new test class is started<br><span class=K>end<br><br>function <span class=C>genericOutput:startTest<span class=E>(</span>testName<span class=E>) <br>    <span class=U>-- </span></span></span></span>called each time a new test is started, right before the setUp()<br>    <span class=U>-- </span>the current test status node is already created and available in: self.result.currentNode<br><span class=K>end<br><br>function <span class=C>genericOutput:updateStatus<span class=E>(</span>node<span class=E>) <br>    <span class=U>-- </span></span></span></span>called with status failed or error as soon as the error/failure is encountered<br>    <span class=U>-- </span>this method is NOT called for a successful test because a test is marked as successful by default<br>    <span class=U>-- </span>and does not need to be updated<br><span class=K>end<br><br>function <span class=C>genericOutput:endTest<span class=E>(</span>node<span class=E>) <br>    <span class=U>-- </span></span></span></span>called when the test is finished, after the tearDown() method<br><span class=K>end<br><br>function <span class=C>genericOutput:endClass<span class=E>() <br>    <span class=U>-- </span></span></span></span>called when executing the class is finished, before moving on to the next class of at the end of the test execution<br><span class=K>end<br><br>function <span class=C>genericOutput:endSuite<span class=E>() <br>    <span class=U>-- </span></span></span></span>called at the end of the test suite execution<br><span class=K>end<br><br><br><span class=U>--</span></span>--------------------------------------------------------------<br><span class=U>--                     </span>class TapOutput<br><span class=U>--</span>--------------------------------------------------------------<br><br><span class=G>local <span class=C>TapOutput <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>() <span class=U>-- </span></span></span></span>derived class<br><span class=G>local <span class=C>TapOutput_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>TapOutput <span class=E>} <span class=U>-- </span></span></span></span>metatable<br><span class=C>TapOutput<span class=H>.</span>__class__ <span class=D>= <span class=B>&#39;<span class=F>TapOutput</span>&#39;<br><br>    <span class=U>-- </span></span></span></span>For a good reference for TAP format, check: http://testanything.org/tap-specification.html<br><br>    <span class=K>function <span class=C>TapOutput.new<span class=E>(</span>runner<span class=E>)<br>        <span class=G>local </span></span>t <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>(</span>runner<span class=O>, </span>M<span class=H>.</span>VERBOSITY_LOW<span class=E>)<br>        </span></span>return <span class=C>setmetatable<span class=E>( </span>t<span class=O>, </span>TapOutput_MT<span class=E>)<br>    </span></span>end<br>    function <span class=C>TapOutput:startSuite<span class=E>()<br>        </span>print<span class=E>(<span class=B>&#34;<span class=F>1..</span>&#34;</span>..</span>self<span class=H>.</span>result<span class=H>.</span>selectedCount<span class=E>)<br>        </span>print<span class=E>(<span class=B>&#39;<span class=F># Started on </span>&#39;</span>..</span>self<span class=H>.</span>result<span class=H>.</span>startDate<span class=E>)<br>    </span></span>end<br>    function <span class=C>TapOutput:startClass<span class=E>(</span>className<span class=E>)<br>        <span class=N>if </span></span>className <span class=E>~= <span class=B>&#39;<span class=F>[TestFunctions]</span>&#39; <span class=N>then<br>            </span></span></span>print<span class=E>(<span class=B>&#39;<span class=F># Starting class: </span>&#39;</span>..</span>className<span class=E>)<br>        <span class=N>end<br>    </span></span></span>end<br><br>    function <span class=C>TapOutput:updateStatus<span class=E>( </span>node <span class=E>)<br>        <span class=N>if </span></span>node<span class=H>:</span>isSkipped<span class=E>() <span class=N>then<br>            </span></span>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(<span class=B>&#34;<span class=F>ok </span>&#34;<span class=O>, </span></span></span>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber<span class=O>, <span class=B>&#34;<span class=F>\t# SKIP </span>&#34;</span>, </span>node<span class=H>.</span>msg<span class=O>, <span class=B>&#34;<span class=F>\n</span>&#34; <span class=E>)<br>            </span></span></span></span>return<br>        <span class=N>end<br><br>        <span class=C>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(<span class=B>&#34;<span class=F>not ok </span>&#34;<span class=O>, </span></span></span>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber<span class=O>, <span class=B>&#34;<span class=F>\t</span>&#34;</span>, </span>node<span class=H>.</span>testName<span class=O>, <span class=B>&#34;<span class=F>\n</span>&#34;<span class=E>)<br>        </span></span></span></span>if <span class=C>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_LOW </span>then<br>           <span class=C>print<span class=E>( </span>prefixString<span class=E>( <span class=B>&#39;<span class=F>#   </span>&#39;<span class=O>, </span></span></span>node<span class=H>.</span>msg <span class=E>) )<br>        </span></span>end<br>        if <span class=E>(<span class=C>node<span class=H>:</span>isFailure</span>() <span class=J>or <span class=C>node<span class=H>:</span>isError</span></span>()) <span class=I>and <span class=C>self<span class=H>.</span>verbosity </span></span>&gt; <span class=C>M<span class=H>.</span>VERBOSITY_DEFAULT </span></span>then<br>           <span class=C>print<span class=E>( </span>prefixString<span class=E>( <span class=B>&#39;<span class=F>#   </span>&#39;<span class=O>, </span></span></span>node<span class=H>.</span>stackTrace <span class=E>) )<br>        </span></span>end<br>    </span>end<br><br>    function <span class=C>TapOutput:endTest<span class=E>( </span>node <span class=E>)<br>        <span class=N>if </span></span>node<span class=H>:</span>isSuccess<span class=E>() <span class=N>then<br>            </span></span>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(<span class=B>&#34;<span class=F>ok     </span>&#34;<span class=O>, </span></span></span>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber<span class=O>, <span class=B>&#34;<span class=F>\t</span>&#34;</span>, </span>node<span class=H>.</span>testName<span class=O>, <span class=B>&#34;<span class=F>\n</span>&#34;<span class=E>)<br>        <span class=N>end<br>    </span></span></span></span></span>end<br><br>    function <span class=C>TapOutput:endSuite<span class=E>()<br>        </span>print<span class=E>( <span class=B>&#39;<span class=F># </span>&#39;</span>..</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>statusLine<span class=E>( </span>self<span class=H>.</span>result <span class=E>) )<br>        </span></span>return <span class=C>self<span class=H>.</span>result<span class=H>.</span>notSuccessCount<br>    </span>end<br><br><br><span class=U>-- </span></span>class TapOutput end<br><br><span class=U>--</span>--------------------------------------------------------------<br><span class=U>--                     </span>class JUnitOutput<br><span class=U>--</span>--------------------------------------------------------------<br><br><span class=U>-- </span>See directory junitxml for more information about the junit format<br><span class=G>local <span class=C>JUnitOutput <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>() <span class=U>-- </span></span></span></span>derived class<br><span class=G>local <span class=C>JUnitOutput_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>JUnitOutput <span class=E>} <span class=U>-- </span></span></span></span>metatable<br><span class=C>JUnitOutput<span class=H>.</span>__class__ <span class=D>= <span class=B>&#39;<span class=F>JUnitOutput</span>&#39;<br><br>    <span class=K>function </span></span></span>JUnitOutput.new<span class=E>(</span>runner<span class=E>)<br>        <span class=G>local </span></span>t <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>(</span>runner<span class=O>, </span>M<span class=H>.</span>VERBOSITY_LOW<span class=E>)<br>        </span>t<span class=H>.</span>testList <span class=D>= <span class=E>{}<br>        <span class=K>return </span></span></span>setmetatable<span class=E>( </span>t<span class=O>, </span>JUnitOutput_MT <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>JUnitOutput:startSuite<span class=E>()<br>        <span class=U>-- </span></span></span>open xml file early to deal with errors<br>        <span class=N>if <span class=C>self<span class=H>.</span>fname <span class=E>== <span class=L>nil </span></span></span>then<br>            <span class=C>error<span class=E>(<span class=B>&#39;<span class=F>With Junit, an output filename must be supplied with --name!</span>&#39;</span>)<br>        </span></span>end<br>        if <span class=C>string<span class=H>.</span>sub<span class=E>(</span>self<span class=H>.</span>fname<span class=O>,<span class=E>-<span class=M>4</span>) ~= <span class=B>&#39;<span class=F>.xml</span>&#39; </span></span></span></span>then<br>            <span class=C>self<span class=H>.</span>fname <span class=D>= </span>self<span class=H>.</span>fname<span class=E>..<span class=B>&#39;<span class=F>.xml</span>&#39;<br>        </span></span></span>end<br>        <span class=C>self<span class=H>.</span>fd <span class=D>= </span>io<span class=H>.</span>open<span class=E>(</span>self<span class=H>.</span>fname<span class=O>, <span class=B>&#34;<span class=F>w</span>&#34;<span class=E>)<br>        </span></span></span></span>if <span class=C>self<span class=H>.</span>fd <span class=E>== <span class=L>nil </span></span></span>then<br>            <span class=C>error<span class=E>(<span class=B>&#34;<span class=F>Could not open file for writing: </span>&#34;</span>..</span>self<span class=H>.</span>fname<span class=E>)<br>        </span></span>end<br><br>        <span class=C>print<span class=E>(<span class=B>&#39;<span class=F># XML output to </span>&#39;</span>..</span>self<span class=H>.</span>fname<span class=E>)<br>        </span>print<span class=E>(<span class=B>&#39;<span class=F># Started on </span>&#39;</span>..</span>self<span class=H>.</span>result<span class=H>.</span>startDate<span class=E>)<br>    <span class=K>end<br>    function </span></span>JUnitOutput:startClass<span class=E>(</span>className<span class=E>)<br>        </span></span>if <span class=C>className <span class=E>~= <span class=B>&#39;<span class=F>[TestFunctions]</span>&#39; </span></span></span>then<br>            <span class=C>print<span class=E>(<span class=B>&#39;<span class=F># Starting class: </span>&#39;</span>..</span>className<span class=E>)<br>        </span></span>end<br>    <span class=K>end<br>    function <span class=C>JUnitOutput:startTest<span class=E>(</span>testName<span class=E>)<br>        </span>print<span class=E>(<span class=B>&#39;<span class=F># Starting test: </span>&#39;</span>..</span>testName<span class=E>)<br>    </span></span>end<br><br>    function <span class=C>JUnitOutput:updateStatus<span class=E>( </span>node <span class=E>)<br>        </span></span></span>if <span class=C>node<span class=H>:</span>isFailure<span class=E>() </span></span>then<br>            <span class=C>print<span class=E>( <span class=B>&#39;<span class=F>#   Failure: </span>&#39; </span>.. </span>prefixString<span class=E>( <span class=B>&#39;<span class=F>#   </span>&#39;<span class=O>, </span></span></span>node<span class=H>.</span>msg <span class=E>)<span class=H>:</span></span>sub<span class=E>(<span class=M>4<span class=O>, <span class=L>nil</span></span></span>) )<br>            <span class=U>-- </span></span></span></span>print(&#39;# &#39; .. node.stackTrace)<br>        <span class=N>elseif <span class=C>node<span class=H>:</span>isError<span class=E>() </span></span>then<br>            <span class=C>print<span class=E>( <span class=B>&#39;<span class=F>#   Error: </span>&#39; </span>.. </span>prefixString<span class=E>( <span class=B>&#39;<span class=F>#   </span>&#39;  <span class=O>, </span></span></span>node<span class=H>.</span>msg <span class=E>)<span class=H>:</span></span>sub<span class=E>(<span class=M>4<span class=O>, <span class=L>nil</span></span></span>) )<br>            <span class=U>-- </span></span></span></span>print(&#39;# &#39; .. node.stackTrace)<br>        <span class=N>end<br>    <span class=K>end<br><br>    function <span class=C>JUnitOutput:endSuite<span class=E>()<br>        </span>print<span class=E>( <span class=B>&#39;<span class=F># </span>&#39;</span>..</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>statusLine<span class=E>(</span>self<span class=H>.</span>result<span class=E>))<br><br>        <span class=U>-- </span></span></span></span></span>XML file writing<br>        <span class=C>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;<span class=F>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt;\n</span>&#39;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;<span class=F>&lt;testsuites&gt;\n</span>&#39;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<br>            <span class=B>&#39;    <span class=F>&lt;testsuite name=&#34;LuaUnit&#34; id=&#34;00001&#34; package=&#34;&#34; hostname=&#34;localhost&#34; tests=&#34;%d&#34; timestamp=&#34;%s&#34; time=&#34;%0.3f&#34; errors=&#34;%d&#34; failures=&#34;%d&#34; skipped=&#34;%d&#34;&gt;\n</span>&#39;<span class=O>,<br>            </span></span></span>self<span class=H>.</span>result<span class=H>.</span>runCount<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>startIsodate<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>duration<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>errorCount<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>failureCount<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>skippedCount <span class=E>))<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#34;        <span class=F>&lt;properties&gt;\n</span>&#34;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;            <span class=F>&lt;property name=&#34;Lua Version&#34; value=&#34;%s&#34;/&gt;\n</span>&#39;<span class=O>, </span></span></span>_VERSION <span class=E>) )<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;            <span class=F>&lt;property name=&#34;LuaUnit Version&#34; value=&#34;%s&#34;/&gt;\n</span>&#39;<span class=O>, </span></span></span>M<span class=H>.</span>VERSION<span class=E>) )<br>        <span class=U>-- </span></span></span>XXX please include system name and version if possible<br>        <span class=C>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#34;        <span class=F>&lt;/properties&gt;\n</span>&#34;</span>)<br><br>        <span class=N>for </span></span>i<span class=O>,</span>node <span class=N>in </span>ipairs<span class=E>(</span>self<span class=H>.</span>result<span class=H>.</span>allTests<span class=E>) <span class=N>do<br>            </span></span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(</span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;        <span class=F>&lt;testcase classname=&#34;%s&#34; name=&#34;%s&#34; time=&#34;%0.3f&#34;&gt;\n</span>&#39;<span class=O>,<br>                </span></span></span>node<span class=H>.</span>className<span class=O>, </span>node<span class=H>.</span>testName<span class=O>, </span>node<span class=H>.</span>duration <span class=E>) )<br>            <span class=N>if </span></span>node<span class=H>:</span>isNotSuccess<span class=E>() <span class=N>then<br>                </span></span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(</span>node<span class=H>:</span>statusXML<span class=E>())<br>            <span class=N>end<br>            </span></span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;        <span class=F>&lt;/testcase&gt;\n</span>&#39;</span>)<br>        <span class=N>end<br><br>        <span class=U>-- </span></span></span></span>Next two lines are needed to validate junit ANT xsd, but really not useful in general:<br>        <span class=C>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;    <span class=F>&lt;system-out/&gt;\n</span>&#39;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;    <span class=F>&lt;system-err/&gt;\n</span>&#39;</span>)<br><br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;    <span class=F>&lt;/testsuite&gt;\n</span>&#39;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>write<span class=E>(<span class=B>&#39;<span class=F>&lt;/testsuites&gt;\n</span>&#39;</span>)<br>        </span>self<span class=H>.</span>fd<span class=H>:</span>close<span class=E>()<br>        <span class=K>return </span></span>self<span class=H>.</span>result<span class=H>.</span>notSuccessCount<br>    <span class=K>end<br><br><br><span class=U>-- </span></span></span>class TapOutput end<br><br><span class=U>--</span>--------------------------------------------------------------<br><span class=U>--                     </span>class TextOutput<br><span class=U>--</span>--------------------------------------------------------------<br><br><span class=U>--[[    </span>Example of other unit-tests suite text output<br><br>-- Python Non verbose:<br><br>For each test: . or F or E<br><br>If some failed tests:<br>    ==============<br>    ERROR / FAILURE: TestName (testfile.testclass)<br>    ---------<br>    Stack trace<br><br><br>then --------------<br>then &#34;Ran x tests in 0.000s&#34;<br>then OK or FAILED (failures=1, error=1)<br><br>-- Python Verbose:<br>testname (filename.classname) ... ok<br>testname (filename.classname) ... FAIL<br>testname (filename.classname) ... ERROR<br><br>then --------------<br>then &#34;Ran x tests in 0.000s&#34;<br>then OK or FAILED (failures=1, error=1)<br><br>-- Ruby:<br>Started<br> .<br> Finished in 0.002695 seconds.<br><br> 1 tests, 2 assertions, 0 failures, 0 errors<br><br>-- Ruby:<br>&gt;&gt; ruby tc_simple_number2.rb<br>Loaded suite tc_simple_number2<br>Started<br>F..<br>Finished in 0.038617 seconds.<br><br>  1) Failure:<br>test_failure(TestSimpleNumber) [tc_simple_number2.rb:16]:<br>Adding doesn&#39;t work.<br>&lt;3&gt; expected but was<br>&lt;4&gt;.<br><br>3 tests, 4 assertions, 1 failures, 0 errors<br><br>-- Java Junit<br>.......F.<br>Time: 0,003<br>There was 1 failure:<br>1) testCapacity(junit.samples.VectorTest)junit.framework.AssertionFailedError<br>    at junit.samples.VectorTest.testCapacity(VectorTest.java:87)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br><br>FAILURES!!!<br>Tests run: 8,  Failures: 1,  Errors: 0<br><br><br>-- Maven<br><br># mvn test<br>-------------------------------------------------------<br> T E S T S<br>-------------------------------------------------------<br>Running math.AdditionTest<br>Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed:<br>0.03 sec &lt;&lt;&lt; FAILURE!<br><br>Results :<br><br>Failed tests:<br>  testLireSymbole(math.AdditionTest)<br><br>Tests run: 2, Failures: 1, Errors: 0, Skipped: 0<br><br><br>-- LuaUnit<br>---- non verbose<br>* display . or F or E when running tests<br>---- verbose<br>* display test name + ok/fail<br>----<br>* blank line<br>* number) ERROR or FAILURE: TestName<br>   Stack trace<br>* blank line<br>* number) ERROR or FAILURE: TestName<br>   Stack trace<br><br>then --------------<br>then &#34;Ran x tests in 0.000s (%d not selected, %d skipped)&#34;<br>then OK or FAILED (failures=1, error=1)<br><br><br><span class=U>]]<br><br><span class=G>local <span class=C>TextOutput <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>() </span></span></span>-- </span>derived class<br><span class=G>local <span class=C>TextOutput_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>TextOutput <span class=E>} <span class=U>-- </span></span></span></span>metatable<br><span class=C>TextOutput<span class=H>.</span>__class__ <span class=D>= <span class=B>&#39;<span class=F>TextOutput</span>&#39;<br><br>    <span class=K>function </span></span></span>TextOutput.new<span class=E>(</span>runner<span class=E>)<br>        <span class=G>local </span></span>t <span class=D>= </span>genericOutput<span class=H>.</span>new<span class=E>(</span>runner<span class=O>, </span>M<span class=H>.</span>VERBOSITY_DEFAULT<span class=E>)<br>        </span>t<span class=H>.</span>errorList <span class=D>= <span class=E>{}<br>        <span class=K>return </span></span></span>setmetatable<span class=E>( </span>t<span class=O>, </span>TextOutput_MT <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>TextOutput:startSuite<span class=E>()<br>        <span class=N>if </span></span>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=N>then<br>            </span>print<span class=E>( <span class=B>&#39;<span class=F>Started on </span>&#39;</span>.. </span>self<span class=H>.</span>result<span class=H>.</span>startDate <span class=E>)<br>        <span class=N>end<br>    <span class=K>end<br><br>    function </span></span></span>TextOutput:startTest<span class=E>(</span>testName<span class=E>)<br>        <span class=N>if </span></span>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=N>then<br>            </span>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>( <span class=B>&#34;    &#34;<span class=O>, </span></span></span>self<span class=H>.</span>result<span class=H>.</span>currentNode<span class=H>.</span>testName<span class=O>, <span class=B>&#34; <span class=F>... </span>&#34; <span class=E>)<br>        <span class=N>end<br>    <span class=K>end<br><br>    function </span></span></span></span></span>TextOutput:endTest<span class=E>( </span>node <span class=E>)<br>        <span class=N>if </span></span>node<span class=H>:</span>isSuccess<span class=E>() <span class=N>then<br>            if </span></span>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=N>then<br>                </span>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(<span class=B>&#34;<span class=F>Ok\n</span>&#34;</span>)<br>            <span class=N>else<br>                </span></span>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(<span class=B>&#34;<span class=F>.</span>&#34;</span>)<br>                </span>io<span class=H>.</span>stdout<span class=H>:</span>flush<span class=E>()<br>            <span class=N>end<br>        else<br>            if </span></span>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=N>then<br>                </span>print<span class=E>( </span>node<span class=H>.</span>status <span class=E>)<br>                </span>print<span class=E>( </span>node<span class=H>.</span>msg <span class=E>)<br>                <span class=U>--[[<br>                </span></span></span>-- find out when to do this:<br>                if self.verbosity &gt; M.VERBOSITY_DEFAULT then<br>                    print( node.stackTrace )<br>                end<br>                <span class=U>]]<br>            <span class=N>else<br>                </span>-- </span>write only the first character of status E, F or S<br>                <span class=C>io<span class=H>.</span>stdout<span class=H>:</span>write<span class=E>(</span>string<span class=H>.</span>sub<span class=E>(</span>node<span class=H>.</span>status<span class=O>, <span class=M>1</span>, <span class=M>1<span class=E>))<br>                </span></span></span>io<span class=H>.</span>stdout<span class=H>:</span>flush<span class=E>()<br>            <span class=N>end<br>        end<br>    <span class=K>end<br><br>    function </span></span></span>TextOutput:displayOneFailedTest<span class=E>( </span>index<span class=O>, </span>fail <span class=E>)<br>        </span>print<span class=E>(</span>index<span class=E>..<span class=B>&#34;<span class=F>) </span>&#34;</span>..</span>fail<span class=H>.</span>testName <span class=E>)<br>        </span>print<span class=E>( </span>fail<span class=H>.</span>msg <span class=E>)<br>        </span>print<span class=E>( </span>fail<span class=H>.</span>stackTrace <span class=E>)<br>        </span>print<span class=E>()<br>    <span class=K>end<br><br>    function </span></span>TextOutput:displayErroredTests<span class=E>()<br>        <span class=N>if </span>#</span>self<span class=H>.</span>result<span class=H>.</span>errorTests <span class=E>~= <span class=M>0 <span class=N>then<br>            </span></span></span>print<span class=E>(<span class=B>&#34;<span class=F>Tests with errors:</span>&#34;</span>)<br>            </span>print<span class=E>(<span class=B>&#34;<span class=F>------------------</span>&#34;</span>)<br>            <span class=N>for </span></span>i<span class=O>, </span>v <span class=N>in </span>ipairs<span class=E>(</span>self<span class=H>.</span>result<span class=H>.</span>errorTests<span class=E>) <span class=N>do<br>                </span></span>self<span class=H>:</span>displayOneFailedTest<span class=E>(</span>i<span class=O>, </span>v<span class=E>)<br>            <span class=N>end<br>        end<br>    <span class=K>end<br><br>    function </span></span></span>TextOutput:displayFailedTests<span class=E>()<br>        <span class=N>if </span>#</span>self<span class=H>.</span>result<span class=H>.</span>failedTests <span class=E>~= <span class=M>0 <span class=N>then<br>            </span></span></span>print<span class=E>(<span class=B>&#34;<span class=F>Failed tests:</span>&#34;</span>)<br>            </span>print<span class=E>(<span class=B>&#34;<span class=F>-------------</span>&#34;</span>)<br>            <span class=N>for </span></span>i<span class=O>, </span>v <span class=N>in </span>ipairs<span class=E>(</span>self<span class=H>.</span>result<span class=H>.</span>failedTests<span class=E>) <span class=N>do<br>                </span></span>self<span class=H>:</span>displayOneFailedTest<span class=E>(</span>i<span class=O>, </span>v<span class=E>)<br>            <span class=N>end<br>        end<br>    <span class=K>end<br><br>    function </span></span></span>TextOutput:endSuite<span class=E>()<br>        <span class=N>if </span></span>self<span class=H>.</span>verbosity <span class=E>&gt; </span>M<span class=H>.</span>VERBOSITY_DEFAULT <span class=N>then<br>            </span>print<span class=E>(<span class=B>&#34;<span class=F>=========================================================</span>&#34;</span>)<br>        <span class=N>else<br>            </span></span>print<span class=E>()<br>        <span class=N>end<br>        </span></span>self<span class=H>:</span>displayErroredTests<span class=E>()<br>        </span>self<span class=H>:</span>displayFailedTests<span class=E>()<br>        </span>print<span class=E>( </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>statusLine<span class=E>( </span>self<span class=H>.</span>result <span class=E>) )<br>        <span class=N>if </span></span>self<span class=H>.</span>result<span class=H>.</span>notSuccessCount <span class=E>== <span class=M>0 <span class=N>then<br>            </span></span></span>print<span class=E>(<span class=B>&#39;<span class=F>OK</span>&#39;</span>)<br>        <span class=N>end<br>    <span class=K>end<br><br><span class=U>-- </span></span></span></span></span>class TextOutput end<br><br><br><span class=U>--</span>--------------------------------------------------------------<br><span class=U>--                     </span>class NilOutput<br><span class=U>--</span>--------------------------------------------------------------<br><br><span class=K>local function <span class=C>nopCallable<span class=E>()<br>    <span class=U>--</span></span></span></span>print(42)<br>    <span class=K>return <span class=C>nopCallable<br></span>end<br><br><span class=G>local <span class=C>NilOutput <span class=D>= <span class=E>{ <span class=P>__class__ </span></span>= <span class=B>&#39;<span class=F>NilOuptut</span>&#39; <span class=E>} <span class=U>-- </span></span></span></span></span></span></span>class<br><span class=G>local <span class=C>NilOutput_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>nopCallable <span class=E>} <span class=U>-- </span></span></span></span>metatable<br><br><span class=K>function <span class=C>NilOutput.new<span class=E>(</span>runner<span class=E>)<br>    </span></span>return <span class=C>setmetatable<span class=E>( { <span class=P>__class__ <span class=D>= <span class=B>&#39;<span class=F>NilOutput</span>&#39; </span></span></span>}<span class=O>, </span></span>NilOutput_MT <span class=E>)<br></span></span>end<br><br><span class=U>--</span></span>--------------------------------------------------------------<br><span class=U>--<br>--                     </span>class LuaUnit<br><span class=U>--<br>--</span>--------------------------------------------------------------<br><br><span class=C>M<span class=H>.</span>LuaUnit <span class=D>= <span class=E>{<br>    <span class=P>outputType </span></span>= </span>TextOutput<span class=O>,<br>    <span class=P>verbosity <span class=D>= </span></span></span>M<span class=H>.</span>VERBOSITY_DEFAULT<span class=O>,<br>    <span class=P>__class__ <span class=D>= <span class=B>&#39;<span class=F>LuaUnit</span>&#39;</span></span></span>,<br>    <span class=P>instances <span class=D>= <span class=E>{}<br>}<br><span class=G>local </span></span></span></span></span>LuaUnit_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>M<span class=H>.</span>LuaUnit <span class=E>}<br><br><span class=N>if </span></span>EXPORT_ASSERT_TO_GLOBALS <span class=N>then<br>    </span>LuaUnit <span class=D>= </span>M<span class=H>.</span>LuaUnit<br><span class=N>end<br><br>    <span class=K>function </span></span>M.LuaUnit.new<span class=E>()<br>        <span class=G>local </span></span>newInstance <span class=D>= </span>setmetatable<span class=E>( {}<span class=O>, </span></span>LuaUnit_MT <span class=E>)<br>        <span class=K>return </span></span>newInstance<br>    <span class=K>end<br><br>    <span class=U>--</span></span></span>---------------[[ Utility methods ]]---------------------<br><br>    <span class=K>function <span class=C>M.LuaUnit.asFunction<span class=E>(</span>aObject<span class=E>)<br>        <span class=U>-- </span></span></span></span>return &#34;aObject&#34; if it is a function, and nil otherwise<br>        <span class=N>if <span class=B>&#39;<span class=F>function</span>&#39; <span class=E>== <span class=C>type</span>(<span class=C>aObject</span>) </span></span>then<br>            <span class=K>return <span class=C>aObject<br>        </span></span>end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit.splitClassMethod<span class=E>(</span>someName<span class=E>)<br>        <span class=U>--[[<br>        </span></span></span></span></span>Return a pair of className, methodName strings for a name in the form<br>        &#34;class.method&#34;. If no class part (or separator) is found, will return<br>        nil, someName instead (the latter being unchanged).<br><br>        This convention thus also replaces the older isClassMethod() test:<br>        You just have to check for a non-nil className (return) value.<br>        <span class=U>]]<br>        <span class=G>local <span class=C>separator <span class=D>= </span>string<span class=H>.</span>find<span class=E>(</span>someName<span class=O>, <span class=B>&#39;<span class=F>.</span>&#39;</span>, <span class=M>1</span>, <span class=L>true<span class=E>)<br>        <span class=N>if </span></span></span></span>separator <span class=N>then<br>            <span class=K>return </span></span>someName<span class=H>:</span>sub<span class=E>(<span class=M>1<span class=O>, </span></span></span>separator <span class=E>- <span class=M>1</span>)<span class=O>, </span></span>someName<span class=H>:</span>sub<span class=E>(</span>separator <span class=E>+ <span class=M>1</span>)<br>        <span class=N>end<br>        <span class=K>return <span class=L>nil<span class=O>, </span></span></span></span></span>someName<br>    <span class=K>end<br><br>    function </span>M.LuaUnit.isMethodTestName<span class=E>( </span>s <span class=E>)<br>        </span></span></span>-- </span>return true is the name matches the name of a test method<br>        <span class=U>-- </span>default rule is that is starts with &#39;Test&#39; or with &#39;test&#39;<br>        <span class=K>return <span class=C>string<span class=H>.</span>sub<span class=E>(</span>s<span class=O>, <span class=M>1</span>, <span class=M>4<span class=E>)<span class=H>:</span></span></span></span>lower<span class=E>() == <span class=B>&#39;<span class=F>test</span>&#39;<br>    </span></span></span>end<br><br>    function <span class=C>M.LuaUnit.isTestName<span class=E>( </span>s <span class=E>)<br>        <span class=U>-- </span></span></span></span>return true is the name matches the name of a test<br>        <span class=U>-- </span>default rule is that is starts with &#39;Test&#39; or with &#39;test&#39;<br>        <span class=K>return <span class=C>string<span class=H>.</span>sub<span class=E>(</span>s<span class=O>, <span class=M>1</span>, <span class=M>4<span class=E>)<span class=H>:</span></span></span></span>lower<span class=E>() == <span class=B>&#39;<span class=F>test</span>&#39;<br>    </span></span></span>end<br><br>    function <span class=C>M.LuaUnit.collectTests<span class=E>()<br>        <span class=U>-- </span></span></span></span>return a list of all test names in the global namespace<br>        <span class=U>-- </span>that match LuaUnit.isTestName<br><br>        <span class=G>local <span class=C>testNames <span class=D>= <span class=E>{}<br>        <span class=N>for </span></span></span>k<span class=O>, </span>_ <span class=N>in </span>pairs<span class=E>(</span>_G<span class=E>) <span class=N>do<br>            if </span></span>type<span class=E>(</span>k<span class=E>) == <span class=B>&#34;<span class=F>string</span>&#34; <span class=I>and </span></span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>isTestName<span class=E>( </span>k <span class=E>) <span class=N>then<br>                </span></span>table<span class=H>.</span>insert<span class=E>( </span>testNames <span class=O>, </span>k <span class=E>)<br>            <span class=N>end<br>        end<br>        </span></span>table<span class=H>.</span>sort<span class=E>( </span>testNames <span class=E>)<br>        <span class=K>return </span></span>testNames<br>    <span class=K>end<br><br>    function </span>M.LuaUnit.parseCmdLine<span class=E>( </span>cmdLine <span class=E>)<br>        <span class=U>-- </span></span></span></span>parse the command line<br>        <span class=U>-- </span>Supported command line parameters:<br>        <span class=U>-- </span>--verbose, -v: increase verbosity<br>        <span class=U>-- </span>--quiet, -q: silence output<br>        <span class=U>-- </span>--error, -e: treat errors as fatal (quit program)<br>        <span class=U>-- </span>--output, -o, + name: select output type<br>        <span class=U>-- </span>--pattern, -p, + pattern: run test matching pattern, may be repeated<br>        <span class=U>-- </span>--exclude, -x, + pattern: run test not matching pattern, may be repeated<br>        <span class=U>-- </span>--shuffle, -s, : shuffle tests before reunning them<br>        <span class=U>-- </span>--name, -n, + fname: name of output file for junit, default to stdout<br>        <span class=U>-- </span>--repeat, -r, + num: number of times to execute each test<br>        <span class=U>-- </span>[testnames, ...]: run selected test names<br>        <span class=U>--<br>        -- </span>Returns a table with the following fields:<br>        <span class=U>-- </span>verbosity: nil, M.VERBOSITY_DEFAULT, M.VERBOSITY_QUIET, M.VERBOSITY_VERBOSE<br>        <span class=U>-- </span>output: nil, &#39;tap&#39;, &#39;junit&#39;, &#39;text&#39;, &#39;nil&#39;<br>        <span class=U>-- </span>testNames: nil or a list of test names to run<br>        <span class=U>-- </span>exeRepeat: num or 1<br>        <span class=U>-- </span>pattern: nil or a list of patterns<br>        <span class=U>-- </span>exclude: nil or a list of patterns<br><br>        <span class=G>local <span class=C>result<span class=O>, </span>state <span class=D>= <span class=E>{}<span class=O>, <span class=L>nil<br>        </span></span></span></span></span>local <span class=C>SET_OUTPUT <span class=D>= <span class=M>1<br>        </span></span></span>local <span class=C>SET_PATTERN <span class=D>= <span class=M>2<br>        </span></span></span>local <span class=C>SET_EXCLUDE <span class=D>= <span class=M>3<br>        </span></span></span>local <span class=C>SET_FNAME <span class=D>= <span class=M>4<br>        </span></span></span>local <span class=C>SET_REPEAT <span class=D>= <span class=M>5<br><br>        <span class=N>if </span></span></span>cmdLine <span class=E>== <span class=L>nil <span class=N>then<br>            <span class=K>return </span></span></span></span>result<br>        <span class=N>end<br><br>        <span class=K>local function </span></span>parseOption<span class=E>( </span>option <span class=E>)<br>            <span class=N>if </span></span>option <span class=E>== <span class=B>&#39;<span class=F>--help</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-h</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>help</span>&#39;</span>] <span class=D>= <span class=L>true<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>--version</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>version</span>&#39;</span>] <span class=D>= <span class=L>true<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>--verbose</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-v</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>verbosity</span>&#39;</span>] <span class=D>= </span></span>M<span class=H>.</span>VERBOSITY_VERBOSE<br>                <span class=K>return<br>            <span class=N>elseif </span></span>option <span class=E>== <span class=B>&#39;<span class=F>--quiet</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-q</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>verbosity</span>&#39;</span>] <span class=D>= </span></span>M<span class=H>.</span>VERBOSITY_QUIET<br>                <span class=K>return<br>            <span class=N>elseif </span></span>option <span class=E>== <span class=B>&#39;<span class=F>--error</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-e</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>quitOnError</span>&#39;</span>] <span class=D>= <span class=L>true<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>--failure</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-f</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>quitOnFailure</span>&#39;</span>] <span class=D>= <span class=L>true<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>--shuffle</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-s</span>&#39; <span class=N>then<br>                </span></span></span>result<span class=E>[<span class=B>&#39;<span class=F>shuffle</span>&#39;</span>] <span class=D>= <span class=L>true<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>--output</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-o</span>&#39; <span class=N>then<br>                </span></span></span>state <span class=D>= </span>SET_OUTPUT<br>                <span class=K>return </span>state<br>            <span class=N>elseif </span>option <span class=E>== <span class=B>&#39;<span class=F>--name</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-n</span>&#39; <span class=N>then<br>                </span></span></span>state <span class=D>= </span>SET_FNAME<br>                <span class=K>return </span>state<br>            <span class=N>elseif </span>option <span class=E>== <span class=B>&#39;<span class=F>--repeat</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-r</span>&#39; <span class=N>then<br>                </span></span></span>state <span class=D>= </span>SET_REPEAT<br>                <span class=K>return </span>state<br>            <span class=N>elseif </span>option <span class=E>== <span class=B>&#39;<span class=F>--pattern</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-p</span>&#39; <span class=N>then<br>                </span></span></span>state <span class=D>= </span>SET_PATTERN<br>                <span class=K>return </span>state<br>            <span class=N>elseif </span>option <span class=E>== <span class=B>&#39;<span class=F>--exclude</span>&#39; <span class=J>or </span></span></span>option <span class=E>== <span class=B>&#39;<span class=F>-x</span>&#39; <span class=N>then<br>                </span></span></span>state <span class=D>= </span>SET_EXCLUDE<br>                <span class=K>return </span>state<br>            <span class=N>end<br>            </span>error<span class=E>(<span class=B>&#39;<span class=F>Unknown option: </span>&#39;</span>..</span>option<span class=O>,<span class=M>3<span class=E>)<br>        <span class=K>end<br><br>        local function </span></span></span></span>setArg<span class=E>( </span>cmdArg<span class=O>, </span>state <span class=E>)<br>            <span class=N>if </span></span>state <span class=E>== </span>SET_OUTPUT <span class=N>then<br>                </span>result<span class=E>[<span class=B>&#39;<span class=F>output</span>&#39;</span>] <span class=D>= </span></span>cmdArg<br>                <span class=K>return<br>            <span class=N>elseif </span></span>state <span class=E>== </span>SET_FNAME <span class=N>then<br>                </span>result<span class=E>[<span class=B>&#39;<span class=F>fname</span>&#39;</span>] <span class=D>= </span></span>cmdArg<br>                <span class=K>return<br>            <span class=N>elseif </span></span>state <span class=E>== </span>SET_REPEAT <span class=N>then<br>                </span>result<span class=E>[<span class=B>&#39;<span class=F>exeRepeat</span>&#39;</span>] <span class=D>= </span></span>tonumber<span class=E>(</span>cmdArg<span class=E>)<br>                                     <span class=J>or </span></span>error<span class=E>(<span class=B>&#39;<span class=F>Malformed -r argument: </span>&#39;</span>..</span>cmdArg<span class=E>)<br>                <span class=K>return<br>            <span class=N>elseif </span></span></span>state <span class=E>== </span>SET_PATTERN <span class=N>then<br>                if </span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>] <span class=N>then<br>                    </span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>]<span class=O>, </span></span>cmdArg <span class=E>)<br>                <span class=N>else<br>                    </span></span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>] <span class=D>= </span>{ </span>cmdArg <span class=E>}<br>                <span class=N>end<br>                <span class=K>return<br>            </span>elseif </span></span>state <span class=E>== </span>SET_EXCLUDE <span class=N>then<br>                </span></span>local <span class=C>notArg <span class=D>= <span class=B>&#39;<span class=F>!</span>&#39;<span class=E>..</span></span></span>cmdArg<br>                <span class=N>if </span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>] <span class=N>then<br>                    </span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>]<span class=O>,  </span></span>notArg <span class=E>)<br>                <span class=N>else<br>                    </span></span>result<span class=E>[<span class=B>&#39;<span class=F>pattern</span>&#39;</span>] <span class=D>= </span>{ </span>notArg <span class=E>}<br>                <span class=N>end<br>                <span class=K>return<br>            </span>end<br>            </span></span>error<span class=E>(<span class=B>&#39;<span class=F>Unknown parse state: </span>&#39;</span>.. </span>state<span class=E>)<br>        <span class=K>end<br><br><br>        <span class=N>for </span></span></span>i<span class=O>, </span>cmdArg <span class=N>in </span>ipairs<span class=E>(</span>cmdLine<span class=E>) <span class=N>do<br>            if </span></span>state <span class=E>~= <span class=L>nil <span class=N>then<br>                </span></span></span>setArg<span class=E>( </span>cmdArg<span class=O>, </span>state<span class=O>, </span>result <span class=E>)<br>                </span>state <span class=D>= <span class=L>nil<br>            <span class=N>else<br>                if </span></span></span>cmdArg<span class=H>:</span>sub<span class=E>(<span class=M>1<span class=O>,</span>1</span>) == <span class=B>&#39;<span class=F>-</span>&#39; <span class=N>then<br>                    </span></span></span>state <span class=D>= </span>parseOption<span class=E>( </span>cmdArg <span class=E>)<br>                <span class=N>else<br>                    if </span></span>result<span class=E>[<span class=B>&#39;<span class=F>testNames</span>&#39;</span>] <span class=N>then<br>                        </span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=E>[<span class=B>&#39;<span class=F>testNames</span>&#39;</span>]<span class=O>, </span></span>cmdArg <span class=E>)<br>                    <span class=N>else<br>                        </span></span>result<span class=E>[<span class=B>&#39;<span class=F>testNames</span>&#39;</span>] <span class=D>= </span>{ </span>cmdArg <span class=E>}<br>                    <span class=N>end<br>                end<br>            end<br>        end<br><br>        if </span></span>result<span class=E>[<span class=B>&#39;<span class=F>help</span>&#39;</span>] <span class=N>then<br>            </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>help<span class=E>()<br>        <span class=N>end<br><br>        if </span></span>result<span class=E>[<span class=B>&#39;<span class=F>version</span>&#39;</span>] <span class=N>then<br>            </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>version<span class=E>()<br>        <span class=N>end<br><br>        if </span></span>state <span class=E>~= <span class=L>nil <span class=N>then<br>            </span></span></span>error<span class=E>(<span class=B>&#39;<span class=F>Missing argument after </span>&#39;</span>..</span>cmdLine<span class=E>[ #</span>cmdLine <span class=E>]<span class=O>,<span class=M>2 </span></span>)<br>        <span class=N>end<br><br>        <span class=K>return </span></span></span>result<br>    <span class=K>end<br><br>    function </span>M.LuaUnit.help<span class=E>()<br>        </span>print<span class=E>(</span>M<span class=H>.</span>USAGE<span class=E>)<br>        </span>os<span class=H>.</span>exit<span class=E>(<span class=M>0</span>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit.version<span class=E>()<br>        </span>print<span class=E>(<span class=B>&#39;<span class=F>LuaUnit v</span>&#39;</span>..</span>M<span class=H>.</span>VERSION<span class=E>..<span class=B>&#39; <span class=F>by Philippe Fremy &lt;phil@freehackers.org&gt;</span>&#39;</span>)<br>        </span>os<span class=H>.</span>exit<span class=E>(<span class=M>0</span>)<br>    <span class=K>end<br><br><span class=U>--</span></span></span></span></span>--------------------------------------------------------------<br><span class=U>--                     </span>class NodeStatus<br><span class=U>--</span>--------------------------------------------------------------<br><br>    <span class=G>local <span class=C>NodeStatus <span class=D>= <span class=E>{ <span class=P>__class__ </span></span>= <span class=B>&#39;<span class=F>NodeStatus</span>&#39; <span class=E>} <span class=U>-- </span></span></span></span></span></span>class<br>    <span class=G>local <span class=C>NodeStatus_MT <span class=D>= <span class=E>{ <span class=P>__index </span></span>= </span>NodeStatus <span class=E>} <span class=U>-- </span></span></span></span>metatable<br>    <span class=C>M<span class=H>.</span>NodeStatus <span class=D>= </span>NodeStatus<br><br>    <span class=U>-- </span></span>values of status<br>    <span class=C>NodeStatus<span class=H>.</span>SUCCESS  <span class=D>= <span class=B>&#39;<span class=F>SUCCESS</span>&#39;<br>    </span></span>NodeStatus<span class=H>.</span>SKIP     <span class=D>= <span class=B>&#39;<span class=F>SKIP</span>&#39;<br>    </span></span>NodeStatus<span class=H>.</span>FAIL     <span class=D>= <span class=B>&#39;<span class=F>FAIL</span>&#39;<br>    </span></span>NodeStatus<span class=H>.</span>ERROR    <span class=D>= <span class=B>&#39;<span class=F>ERROR</span>&#39;<br><br>    <span class=K>function </span></span></span>NodeStatus.new<span class=E>( </span>number<span class=O>, </span>testName<span class=O>, </span>className <span class=E>)<br>        <span class=U>-- </span></span></span>default constructor, test are PASS by default<br>        <span class=G>local <span class=C>t <span class=D>= <span class=E>{ <span class=P>number </span></span>= </span>number<span class=O>, <span class=P>testName <span class=D>= </span></span></span>testName<span class=O>, <span class=P>className <span class=D>= </span></span></span>className <span class=E>}<br>        </span>setmetatable<span class=E>( </span>t<span class=O>, </span>NodeStatus_MT <span class=E>)<br>        </span>t<span class=H>:</span>success<span class=E>()<br>        <span class=K>return </span></span>t<br>    <span class=K>end<br><br>    function </span>NodeStatus:success<span class=E>()<br>        </span>self<span class=H>.</span>status <span class=D>= </span>self<span class=H>.</span>SUCCESS<br>        <span class=U>-- </span></span></span>useless because lua does this for us, but it helps me remembering the relevant field names<br>        <span class=C>self<span class=H>.</span>msg <span class=D>= <span class=L>nil<br>        </span></span>self<span class=H>.</span>stackTrace <span class=D>= <span class=L>nil<br>    <span class=K>end<br><br>    function </span></span></span>NodeStatus:skip<span class=E>(</span>msg<span class=E>)<br>        </span>self<span class=H>.</span>status <span class=D>= </span>self<span class=H>.</span>SKIP<br>        self<span class=H>.</span>msg <span class=D>= </span>msg<br>        self<span class=H>.</span>stackTrace <span class=D>= <span class=L>nil<br>    <span class=K>end<br><br>    function </span></span></span>NodeStatus:fail<span class=E>(</span>msg<span class=O>, </span>stackTrace<span class=E>)<br>        </span>self<span class=H>.</span>status <span class=D>= </span>self<span class=H>.</span>FAIL<br>        self<span class=H>.</span>msg <span class=D>= </span>msg<br>        self<span class=H>.</span>stackTrace <span class=D>= </span>stackTrace<br>    <span class=K>end<br><br>    function </span>NodeStatus:error<span class=E>(</span>msg<span class=O>, </span>stackTrace<span class=E>)<br>        </span>self<span class=H>.</span>status <span class=D>= </span>self<span class=H>.</span>ERROR<br>        self<span class=H>.</span>msg <span class=D>= </span>msg<br>        self<span class=H>.</span>stackTrace <span class=D>= </span>stackTrace<br>    <span class=K>end<br><br>    function </span>NodeStatus:isSuccess<span class=E>()<br>        <span class=K>return </span></span>self<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SUCCESS<br>    <span class=K>end<br><br>    function </span>NodeStatus:isNotSuccess<span class=E>()<br>        <span class=U>-- </span></span></span>Return true if node is either failure or error or skip<br>        <span class=K>return <span class=E>(<span class=C>self<span class=H>.</span>status </span>== <span class=C>NodeStatus<span class=H>.</span>FAIL <span class=J>or </span>self<span class=H>.</span>status </span>== <span class=C>NodeStatus<span class=H>.</span>ERROR <span class=J>or </span>self<span class=H>.</span>status </span>== <span class=C>NodeStatus<span class=H>.</span>SKIP</span>)<br>    </span>end<br><br>    function <span class=C>NodeStatus:isSkipped<span class=E>()<br>        </span></span>return <span class=C>self<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SKIP<br>    </span>end<br><br>    function <span class=C>NodeStatus:isFailure<span class=E>()<br>        </span></span>return <span class=C>self<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>FAIL<br>    </span>end<br><br>    function <span class=C>NodeStatus:isError<span class=E>()<br>        </span></span>return <span class=C>self<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>ERROR<br>    </span>end<br><br>    function <span class=C>NodeStatus:statusXML<span class=E>()<br>        <span class=N>if </span></span>self<span class=H>:</span>isError<span class=E>() <span class=N>then<br>            </span></span></span>return <span class=C>table<span class=H>.</span>concat<span class=E>(<br>                {<span class=B>&#39;            <span class=F>&lt;error type=&#34;</span>&#39;<span class=O>, </span></span></span>xmlEscape<span class=E>(</span>self<span class=H>.</span>msg<span class=E>)<span class=O>, <span class=B>&#39;<span class=F>&#34;&gt;\n</span>&#39;</span>,<br>                 <span class=B>&#39;                <span class=F>&lt;![CDATA[</span>&#39;</span>, </span></span>xmlCDataEscape<span class=E>(</span>self<span class=H>.</span>stackTrace<span class=E>)<span class=O>,<br>                 <span class=B>&#39;<span class=F>]]&gt;&lt;/error&gt;\n</span>&#39;</span></span>})<br>        <span class=N>elseif </span></span>self<span class=H>:</span>isFailure<span class=E>() <span class=N>then<br>            </span></span></span>return <span class=C>table<span class=H>.</span>concat<span class=E>(<br>                {<span class=B>&#39;            <span class=F>&lt;failure type=&#34;</span>&#39;<span class=O>, </span></span></span>xmlEscape<span class=E>(</span>self<span class=H>.</span>msg<span class=E>)<span class=O>, <span class=B>&#39;<span class=F>&#34;&gt;\n</span>&#39;</span>,<br>                 <span class=B>&#39;                <span class=F>&lt;![CDATA[</span>&#39;</span>, </span></span>xmlCDataEscape<span class=E>(</span>self<span class=H>.</span>stackTrace<span class=E>)<span class=O>,<br>                 <span class=B>&#39;<span class=F>]]&gt;&lt;/failure&gt;\n</span>&#39;</span></span>})<br>        <span class=N>elseif </span></span>self<span class=H>:</span>isSkipped<span class=E>() <span class=N>then<br>            </span></span></span>return <span class=C>table<span class=H>.</span>concat<span class=E>({<span class=B>&#39;            <span class=F>&lt;skipped&gt;</span>&#39;<span class=O>, </span></span></span>xmlEscape<span class=E>(</span>self<span class=H>.</span>msg<span class=E>)<span class=O>,<span class=B>&#39;<span class=F>&lt;/skipped&gt;\n</span>&#39; </span></span>} )<br>        <span class=N>end<br>        </span></span></span>return <span class=B>&#39;            <span class=F>&lt;passed/&gt;\n</span>&#39; <span class=U>-- </span></span></span>(not XSD-compliant! normally shouldn&#39;t get here)<br>    <span class=K>end<br><br>    <span class=U>--</span></span>------------[[ Output methods ]]-------------------------<br><br>    <span class=K>local function <span class=C>conditional_plural<span class=E>(</span>number<span class=O>, </span>singular<span class=E>)<br>        <span class=U>-- </span></span></span></span>returns a grammatically well-formed string &#34;%d &lt;singular/plural&gt;&#34;<br>        <span class=G>local <span class=C>suffix <span class=D>= <span class=B>&#39;&#39;<br>        <span class=N>if </span></span></span>number <span class=E>~= <span class=M>1 <span class=N>then <span class=U>-- </span></span></span></span></span></span>use plural<br>            <span class=C>suffix <span class=D>= <span class=E>(</span></span>singular<span class=H>:</span>sub<span class=E>(-<span class=M>2</span>) == <span class=B>&#39;<span class=F>ss</span>&#39;</span>) <span class=I>and <span class=B>&#39;<span class=F>es</span>&#39; <span class=J>or </span>&#39;<span class=F>s</span>&#39;<br>        <span class=N>end<br>        <span class=K>return </span></span></span></span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;<span class=F>%d %s%s</span>&#39;<span class=O>, </span></span></span>number<span class=O>, </span>singular<span class=O>, </span>suffix<span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit.statusLine<span class=E>(</span>result<span class=E>)<br>        <span class=U>-- </span></span></span>return status line string according to results<br>        <span class=G>local <span class=C>s <span class=D>= <span class=E>{<br>            </span></span>string<span class=H>.</span>format<span class=E>(<span class=B>&#39;<span class=F>Ran %d tests in %0.3f seconds</span>&#39;<span class=O>,<br>                          </span></span></span>result<span class=H>.</span>runCount<span class=O>, </span>result<span class=H>.</span>duration<span class=E>)<span class=O>,<br>            </span></span>conditional_plural<span class=E>(</span>result<span class=H>.</span>successCount<span class=O>, <span class=B>&#39;<span class=F>success</span>&#39;<span class=E>)</span></span>,<br>        <span class=E>}<br>        <span class=N>if </span></span></span>result<span class=H>.</span>notSuccessCount <span class=E>&gt; <span class=M>0 <span class=N>then<br>            if </span></span></span>result<span class=H>.</span>failureCount <span class=E>&gt; <span class=M>0 <span class=N>then<br>                </span></span></span>table<span class=H>.</span>insert<span class=E>(</span>s<span class=O>, </span>conditional_plural<span class=E>(</span>result<span class=H>.</span>failureCount<span class=O>, <span class=B>&#39;<span class=F>failure</span>&#39;<span class=E>))<br>            <span class=N>end<br>            if </span></span></span></span>result<span class=H>.</span>errorCount <span class=E>&gt; <span class=M>0 <span class=N>then<br>                </span></span></span>table<span class=H>.</span>insert<span class=E>(</span>s<span class=O>, </span>conditional_plural<span class=E>(</span>result<span class=H>.</span>errorCount<span class=O>, <span class=B>&#39;<span class=F>error</span>&#39;<span class=E>))<br>            <span class=N>end<br>        else<br>            </span></span></span></span>table<span class=H>.</span>insert<span class=E>(</span>s<span class=O>, <span class=B>&#39;<span class=F>0 failures</span>&#39;<span class=E>)<br>        <span class=N>end<br>        if </span></span></span></span>result<span class=H>.</span>skippedCount <span class=E>&gt; <span class=M>0 <span class=N>then<br>            </span></span></span>table<span class=H>.</span>insert<span class=E>(</span>s<span class=O>, </span>string<span class=H>.</span>format<span class=E>(<span class=B>&#34;<span class=F>%d skipped</span>&#34;<span class=O>, </span></span></span>result<span class=H>.</span>skippedCount<span class=E>))<br>        <span class=N>end<br>        if </span></span>result<span class=H>.</span>nonSelectedCount <span class=E>&gt; <span class=M>0 <span class=N>then<br>            </span></span></span>table<span class=H>.</span>insert<span class=E>(</span>s<span class=O>, </span>string<span class=H>.</span>format<span class=E>(<span class=B>&#34;<span class=F>%d non-selected</span>&#34;<span class=O>, </span></span></span>result<span class=H>.</span>nonSelectedCount<span class=E>))<br>        <span class=N>end<br>        <span class=K>return </span></span></span>table<span class=H>.</span>concat<span class=E>(</span>s<span class=O>, <span class=B>&#39;<span class=F>, </span>&#39;<span class=E>)<br>    <span class=K>end<br><br>    function </span></span></span></span>M.LuaUnit:startSuite<span class=E>(</span>selectedCount<span class=O>, </span>nonSelectedCount<span class=E>)<br>        </span>self<span class=H>.</span>result <span class=D>= <span class=E>{<br>            <span class=P>selectedCount </span></span>= </span>selectedCount<span class=O>,<br>            <span class=P>nonSelectedCount <span class=D>= </span></span></span>nonSelectedCount<span class=O>,<br>            <span class=P>successCount <span class=D>= <span class=M>0</span></span></span>,<br>            <span class=P>runCount <span class=D>= <span class=M>0</span></span></span>,<br>            <span class=P>currentTestNumber <span class=D>= <span class=M>0</span></span></span>,<br>            <span class=P>currentClassName <span class=D>= <span class=B>&#34;&#34;</span></span></span>,<br>            <span class=P>currentNode <span class=D>= <span class=L>nil</span></span></span>,<br>            <span class=P>suiteStarted <span class=D>= <span class=L>true</span></span></span>,<br>            <span class=P>startTime <span class=D>= </span></span></span>os<span class=H>.</span>clock<span class=E>()<span class=O>,<br>            <span class=P>startDate <span class=D>= </span></span></span></span>os<span class=H>.</span>date<span class=E>(</span>os<span class=H>.</span>getenv<span class=E>(<span class=B>&#39;<span class=F>LUAUNIT_DATEFMT</span>&#39;</span>))<span class=O>,<br>            <span class=P>startIsodate <span class=D>= </span></span></span></span>os<span class=H>.</span>date<span class=E>(<span class=B>&#39;<span class=F>%Y-%m-%dT%H:%M:%S</span>&#39;</span>)<span class=O>,<br>            <span class=P>patternIncludeFilter <span class=D>= </span></span></span></span>self<span class=H>.</span>patternIncludeFilter<span class=O>,<br><br>            <span class=U>-- </span></span></span></span>list of test node status<br>            <span class=P>allTests <span class=D>= <span class=E>{}<span class=O>,<br>            </span></span></span>failedTests <span class=D>= <span class=E>{}<span class=O>,<br>            </span></span></span>errorTests <span class=D>= <span class=E>{}<span class=O>,<br>            </span></span></span>skippedTests <span class=D>= <span class=E>{}<span class=O>,<br><br>            </span></span></span>failureCount <span class=D>= <span class=M>0<span class=O>,<br>            </span></span></span>errorCount <span class=D>= <span class=M>0<span class=O>,<br>            </span></span></span>notSuccessCount <span class=D>= <span class=M>0<span class=O>,<br>            </span></span></span>skippedCount <span class=D>= <span class=M>0<span class=O>,<br>        <span class=E>}<br><br>        <span class=C>self<span class=H>.</span>outputType </span></span></span></span>= <span class=C>self<span class=H>.</span>outputType <span class=J>or </span>TextOutput<br>        self<span class=H>.</span>output </span>= <span class=C>self<span class=H>.</span>outputType<span class=H>.</span>new<span class=E>(</span>self<span class=E>)<br>        </span>self<span class=H>.</span>output<span class=H>:</span>startSuite<span class=E>()<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:startClass<span class=E>( </span>className<span class=O>, </span>classInstance <span class=E>)<br>        </span>self<span class=H>.</span>result<span class=H>.</span>currentClassName </span>= <span class=C>className<br>        self<span class=H>.</span>output<span class=H>:</span>startClass<span class=E>( </span>className <span class=E>)<br>        </span>self<span class=H>:</span>setupClass<span class=E>( </span>className<span class=O>, </span>classInstance <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:startTest<span class=E>( </span>testName  <span class=E>)<br>        </span>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber </span>= <span class=C>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber <span class=E>+ <span class=M>1<br>        </span></span>self<span class=H>.</span>result<span class=H>.</span>runCount </span>= <span class=C>self<span class=H>.</span>result<span class=H>.</span>runCount <span class=E>+ <span class=M>1<br>        </span></span>self<span class=H>.</span>result<span class=H>.</span>currentNode </span>= <span class=C>NodeStatus<span class=H>.</span>new<span class=E>(<br>            </span>self<span class=H>.</span>result<span class=H>.</span>currentTestNumber<span class=O>,<br>            </span>testName<span class=O>,<br>            </span>self<span class=H>.</span>result<span class=H>.</span>currentClassName<br>        <span class=E>)<br>        </span>self<span class=H>.</span>result<span class=H>.</span>currentNode<span class=H>.</span>startTime </span>= <span class=C>os<span class=H>.</span>clock<span class=E>()<br>        </span>table<span class=H>.</span>insert<span class=E>( </span>self<span class=H>.</span>result<span class=H>.</span>allTests<span class=O>, </span>self<span class=H>.</span>result<span class=H>.</span>currentNode <span class=E>)<br>        </span>self<span class=H>.</span>output<span class=H>:</span>startTest<span class=E>( </span>testName <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:updateStatus<span class=E>( </span>err <span class=E>)<br>        <span class=U>-- </span></span></span></span></span>&#34;err&#34; is expected to be a table / result from protectedCall()<br>        <span class=N>if <span class=C>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SUCCESS </span>then<br>            <span class=K>return<br>        </span>end<br><br>        <span class=G>local <span class=C>node <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>currentNode<br><br>        <span class=U>--[[ </span></span></span></span>As a first approach, we will report only one error or one failure for one test.<br><br>        However, we can have the case where the test is in failure, and the teardown is in error.<br>        In such case, it&#39;s a good idea to report both a failure and an error in the test suite. This is<br>        what Python unittest does for example. However, it mixes up counts so need to be handled carefully: for<br>        example, there could be more (failures + errors) count that tests. What happens to the current node ?<br><br>        We will do this more intelligent version later.<br>        <span class=U>]]<br><br>        -- </span>if the node is already in failure/error, just don&#39;t report the new error (see above)<br>        <span class=N>if <span class=C>node<span class=H>.</span>status <span class=E>~= </span>NodeStatus<span class=H>.</span>SUCCESS </span>then<br>            <span class=K>return<br>        </span>end<br><br>        if <span class=C>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>FAIL </span>then<br>            <span class=C>node<span class=H>:</span>fail<span class=E>( </span>err<span class=H>.</span>msg<span class=O>, </span>err<span class=H>.</span>trace <span class=E>)<br>            </span>table<span class=H>.</span>insert<span class=E>( </span>self<span class=H>.</span>result<span class=H>.</span>failedTests<span class=O>, </span>node <span class=E>)<br>        </span></span>elseif <span class=C>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>ERROR </span>then<br>            <span class=C>node<span class=H>:</span>error<span class=E>( </span>err<span class=H>.</span>msg<span class=O>, </span>err<span class=H>.</span>trace <span class=E>)<br>            </span>table<span class=H>.</span>insert<span class=E>( </span>self<span class=H>.</span>result<span class=H>.</span>errorTests<span class=O>, </span>node <span class=E>)<br>        </span></span>elseif <span class=C>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SKIP </span>then<br>            <span class=C>node<span class=H>:</span>skip<span class=E>( </span>err<span class=H>.</span>msg <span class=E>)<br>            </span>table<span class=H>.</span>insert<span class=E>( </span>self<span class=H>.</span>result<span class=H>.</span>skippedTests<span class=O>, </span>node <span class=E>)<br>        </span></span>else<br>            <span class=C>error<span class=E>(<span class=B>&#39;<span class=F>No such status: </span>&#39; </span>.. </span>prettystr<span class=E>(</span>err<span class=H>.</span>status<span class=E>))<br>        </span></span>end<br><br>        <span class=C>self<span class=H>.</span>output<span class=H>:</span>updateStatus<span class=E>( </span>node <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:endTest<span class=E>()<br>        <span class=G>local </span></span>node <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>currentNode<br>        <span class=U>-- </span></span></span>print( &#39;endTest() &#39;..prettystr(node))<br>        <span class=U>-- </span>print( &#39;endTest() &#39;..prettystr(node:isNotSuccess()))<br>        <span class=C>node<span class=H>.</span>duration <span class=D>= </span>os<span class=H>.</span>clock<span class=E>() - </span>node<span class=H>.</span>startTime<br>        node<span class=H>.</span>startTime <span class=D>= <span class=L>nil<br>        </span></span>self<span class=H>.</span>output<span class=H>:</span>endTest<span class=E>( </span>node <span class=E>)<br><br>        <span class=N>if </span></span>node<span class=H>:</span>isSuccess<span class=E>() <span class=N>then<br>            </span></span>self<span class=H>.</span>result<span class=H>.</span>successCount <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>successCount <span class=E>+ <span class=M>1<br>        <span class=N>elseif </span></span></span>node<span class=H>:</span>isError<span class=E>() <span class=N>then<br>            if </span></span>self<span class=H>.</span>quitOnError <span class=J>or </span>self<span class=H>.</span>quitOnFailure <span class=N>then<br>                <span class=U>-- </span></span></span>Runtime error - abort test execution as requested by<br>                <span class=U>-- </span>&#34;--error&#34; option. This is done by setting a special<br>                <span class=U>-- </span>flag that gets handled in internalRunSuiteByInstances().<br>                <span class=C>print<span class=E>(<span class=B>&#34;<span class=F>\nERROR during LuaUnit test execution:\n</span>&#34; </span>.. </span>node<span class=H>.</span>msg<span class=E>)<br>                </span>self<span class=H>.</span>result<span class=H>.</span>aborted <span class=D>= <span class=L>true<br>            <span class=N>end<br>        elseif </span></span></span>node<span class=H>:</span>isFailure<span class=E>() <span class=N>then<br>            if </span></span>self<span class=H>.</span>quitOnFailure <span class=N>then<br>                <span class=U>-- </span></span></span>Failure - abort test execution as requested by<br>                <span class=U>-- </span>&#34;--failure&#34; option. This is done by setting a special<br>                <span class=U>-- </span>flag that gets handled in internalRunSuiteByInstances().<br>                <span class=C>print<span class=E>(<span class=B>&#34;<span class=F>\nFailure during LuaUnit test execution:\n</span>&#34; </span>.. </span>node<span class=H>.</span>msg<span class=E>)<br>                </span>self<span class=H>.</span>result<span class=H>.</span>aborted <span class=D>= <span class=L>true<br>            <span class=N>end<br>        elseif </span></span></span>node<span class=H>:</span>isSkipped<span class=E>() <span class=N>then<br>            </span></span>self<span class=H>.</span>result<span class=H>.</span>runCount <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>runCount <span class=E>- <span class=M>1<br>        <span class=N>else<br>            </span></span></span>error<span class=E>(<span class=B>&#39;<span class=F>No such node status: </span>&#39; </span>.. </span>prettystr<span class=E>(</span>node<span class=H>.</span>status<span class=E>))<br>        <span class=N>end<br>        </span></span>self<span class=H>.</span>result<span class=H>.</span>currentNode <span class=D>= <span class=L>nil<br>    <span class=K>end<br><br>    function </span></span></span>M.LuaUnit:endClass<span class=E>()<br>        </span>self<span class=H>:</span>teardownClass<span class=E>( </span>self<span class=H>.</span>lastClassName<span class=O>, </span>self<span class=H>.</span>lastClassInstance <span class=E>)<br>        </span>self<span class=H>.</span>output<span class=H>:</span>endClass<span class=E>()<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:endSuite<span class=E>()<br>        <span class=N>if </span></span>self<span class=H>.</span>result<span class=H>.</span>suiteStarted <span class=E>== <span class=L>false <span class=N>then<br>            </span></span></span>error<span class=E>(<span class=B>&#39;<span class=F>LuaUnit:endSuite() -- suite was already ended</span>&#39; </span>)<br>        <span class=N>end<br>        </span></span>self<span class=H>.</span>result<span class=H>.</span>duration <span class=D>= </span>os<span class=H>.</span>clock<span class=E>()-</span>self<span class=H>.</span>result<span class=H>.</span>startTime<br>        self<span class=H>.</span>result<span class=H>.</span>suiteStarted <span class=D>= <span class=L>false<br><br>        <span class=U>-- </span></span></span></span>Expose test counts for outputter&#39;s endSuite(). This could be managed<br>        <span class=U>-- </span>internally instead by using the length of the lists of failed tests<br>        <span class=U>-- </span>but unit tests rely on these fields being present.<br>        <span class=C>self<span class=H>.</span>result<span class=H>.</span>failureCount <span class=D>= <span class=E>#</span></span>self<span class=H>.</span>result<span class=H>.</span>failedTests<br>        self<span class=H>.</span>result<span class=H>.</span>errorCount <span class=D>= <span class=E>#</span></span>self<span class=H>.</span>result<span class=H>.</span>errorTests<br>        self<span class=H>.</span>result<span class=H>.</span>notSuccessCount <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>failureCount <span class=E>+ </span>self<span class=H>.</span>result<span class=H>.</span>errorCount<br>        self<span class=H>.</span>result<span class=H>.</span>skippedCount <span class=D>= <span class=E>#</span></span>self<span class=H>.</span>result<span class=H>.</span>skippedTests<br><br>        self<span class=H>.</span>output<span class=H>:</span>endSuite<span class=E>()<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:setOutputType<span class=E>(</span>outputType<span class=O>, </span>fname<span class=E>)<br>        <span class=U>-- </span></span></span>Configures LuaUnit runner output<br>        <span class=U>-- </span>outputType is one of: NIL, TAP, JUNIT, TEXT<br>        <span class=U>-- </span>when outputType is junit, the additional argument fname is used to set the name of junit output file<br>        <span class=U>-- </span>for other formats, fname is ignored<br>        <span class=N>if <span class=C>outputType<span class=H>:</span>upper<span class=E>() == <span class=B>&#34;<span class=F>NIL</span>&#34; </span></span></span>then<br>            <span class=C>self<span class=H>.</span>outputType <span class=D>= </span>NilOutput<br>            <span class=K>return<br>        </span></span>end<br>        if <span class=C>outputType<span class=H>:</span>upper<span class=E>() == <span class=B>&#34;<span class=F>TAP</span>&#34; </span></span></span>then<br>            <span class=C>self<span class=H>.</span>outputType <span class=D>= </span>TapOutput<br>            <span class=K>return<br>        </span></span>end<br>        if <span class=C>outputType<span class=H>:</span>upper<span class=E>() == <span class=B>&#34;<span class=F>JUNIT</span>&#34; </span></span></span>then<br>            <span class=C>self<span class=H>.</span>outputType <span class=D>= </span>JUnitOutput<br>            </span>if <span class=C>fname </span>then<br>                <span class=C>self<span class=H>.</span>fname <span class=D>= </span>fname<br>            </span>end<br>            <span class=K>return<br>        </span>end<br>        if <span class=C>outputType<span class=H>:</span>upper<span class=E>() == <span class=B>&#34;<span class=F>TEXT</span>&#34; </span></span></span>then<br>            <span class=C>self<span class=H>.</span>outputType <span class=D>= </span>TextOutput<br>            <span class=K>return<br>        </span></span>end<br>        <span class=C>error<span class=E>( <span class=B>&#39;<span class=F>No such format: </span>&#39;</span>..</span>outputType<span class=O>,<span class=M>2<span class=E>)<br>    <span class=K>end<br><br>    <span class=U>--</span></span></span></span></span></span></span>------------[[ Runner ]]-----------------<br><br>    <span class=K>function <span class=C>M.LuaUnit:protectedCall<span class=E>(</span>classInstance<span class=O>, </span>methodInstance<span class=O>, </span>prettyFuncName<span class=E>)<br>        <span class=U>-- </span></span></span></span>if classInstance is nil, this is just a function call<br>        <span class=U>-- </span>else, it&#39;s method of a class being called.<br><br>        <span class=K>local function <span class=C>err_handler<span class=E>(</span>e<span class=E>)<br>            <span class=U>-- </span></span></span></span>transform error into a table, adding the traceback information<br>            <span class=K>return <span class=E>{<br>                <span class=P>status <span class=D>= <span class=C>NodeStatus<span class=H>.</span>ERROR<span class=O>,<br>                </span></span></span>msg <span class=D>= <span class=C>e<span class=O>,<br>                </span></span></span>trace <span class=D>= <span class=C>string<span class=H>.</span>sub</span></span></span>(<span class=C>debug<span class=H>.</span>traceback</span>(<span class=B>&#34;&#34;<span class=O>, <span class=M>1</span></span></span>)<span class=O>, <span class=M>2</span></span>)<br>            }<br>        </span>end<br><br>        <span class=G>local <span class=C>ok<span class=O>, </span>err<br>        <span class=N>if </span>classInstance <span class=N>then<br>            <span class=U>-- </span></span></span></span></span>stupid Lua &lt; 5.2 does not allow xpcall with arguments so let&#39;s use a workaround<br>            <span class=C>ok<span class=O>, </span>err <span class=D>= </span>xpcall<span class=E>( <span class=K>function </span>() </span>methodInstance<span class=E>(</span>classInstance<span class=E>) <span class=K>end<span class=O>, </span></span></span>err_handler <span class=E>)<br>        <span class=N>else<br>            </span></span>ok<span class=O>, </span>err <span class=D>= </span>xpcall<span class=E>( <span class=K>function </span>() </span>methodInstance<span class=E>() <span class=K>end<span class=O>, </span></span></span>err_handler <span class=E>)<br>        <span class=N>end<br>        if </span></span>ok <span class=N>then<br>            <span class=K>return <span class=E>{<span class=P>status <span class=D>= </span></span></span></span></span>NodeStatus<span class=H>.</span>SUCCESS<span class=E>}<br>        <span class=N>end<br>        <span class=U>-- </span></span></span></span>print(&#39;ok=&#34;&#39;..prettystr(ok)..&#39;&#34; err=&#34;&#39;..prettystr(err)..&#39;&#34;&#39;)<br><br>        <span class=G>local <span class=C>iter_msg<br>        iter_msg <span class=D>= </span>self<span class=H>.</span>exeRepeat <span class=I>and <span class=B>&#39;<span class=F>iteration </span>&#39;<span class=E>..</span></span></span>self<span class=H>.</span>currentCount<br><br>        err<span class=H>.</span>msg<span class=O>, </span>err<span class=H>.</span>status <span class=D>= </span>M<span class=H>.</span>adjust_err_msg_with_iter<span class=E>( </span>err<span class=H>.</span>msg<span class=O>, </span>iter_msg <span class=E>)<br><br>        <span class=N>if </span></span>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SUCCESS <span class=J>or </span>err<span class=H>.</span>status <span class=E>== </span>NodeStatus<span class=H>.</span>SKIP <span class=N>then<br>            </span>err<span class=H>.</span>trace <span class=D>= <span class=L>nil<br>            <span class=K>return </span></span></span>err<br>        <span class=N>end<br><br>        <span class=U>-- </span></span></span></span>reformat / improve the stack trace<br>        <span class=N>if <span class=C>prettyFuncName </span>then <span class=U>-- </span></span>we do have the real method name<br>            <span class=C>err<span class=H>.</span>trace <span class=D>= </span>err<span class=H>.</span>trace<span class=H>:</span>gsub<span class=E>(<span class=B>&#34;<span class=F>in (%a+) &#39;methodInstance&#39;</span>&#34;<span class=O>, </span>&#34;<span class=F>in %1 &#39;</span>&#34;</span>..</span>prettyFuncName<span class=E>..<span class=B>&#34;<span class=F>&#39;</span>&#34;</span>)<br>        <span class=N>end<br>        if </span></span>STRIP_LUAUNIT_FROM_STACKTRACE <span class=N>then<br>            </span>err<span class=H>.</span>trace <span class=D>= </span>stripLuaunitTrace2<span class=E>(</span>err<span class=H>.</span>trace<span class=O>, </span>err<span class=H>.</span>msg<span class=E>)<br>        <span class=N>end<br><br>        <span class=K>return </span></span></span>err <span class=U>-- </span></span>return the error &#34;object&#34; (table)<br>    <span class=K>end<br><br><br>    function <span class=C>M.LuaUnit:execOneFunction<span class=E>(</span>className<span class=O>, </span>methodName<span class=O>, </span>classInstance<span class=O>, </span>methodInstance<span class=E>)<br>        <span class=U>-- </span></span></span></span>When executing a test function, className and classInstance must be nil<br>        <span class=U>-- </span>When executing a class method, all parameters must be set<br><br>        <span class=N>if <span class=C>type<span class=E>(</span>methodInstance<span class=E>) ~= <span class=B>&#39;<span class=F>function</span>&#39; </span></span></span>then<br>            <span class=C>self<span class=H>:</span>unregisterSuite<span class=E>()<br>            </span>error<span class=E>( </span>tostring<span class=E>(</span>methodName<span class=E>)..<span class=B>&#39; <span class=F>must be a function, not </span>&#39;</span>..</span>type<span class=E>(</span>methodInstance<span class=E>))<br>        </span></span>end<br><br>        <span class=G>local <span class=C>prettyFuncName<br>        </span></span>if <span class=C>className <span class=E>== <span class=L>nil </span></span></span>then<br>            <span class=C>className <span class=D>= <span class=B>&#39;<span class=F>[TestFunctions]</span>&#39;<br>            </span></span>prettyFuncName <span class=D>= </span>methodName<br>        </span>else<br>            <span class=C>prettyFuncName <span class=D>= </span>className<span class=E>..<span class=B>&#39;<span class=F>.</span>&#39;</span>..</span>methodName<br>        </span>end<br><br>        if <span class=C>self<span class=H>.</span>lastClassName <span class=E>~= </span>className </span>then<br>            if <span class=C>self<span class=H>.</span>lastClassName <span class=E>~= <span class=L>nil </span></span></span>then<br>                <span class=C>self<span class=H>:</span>endClass<span class=E>()<br>            </span></span>end<br>            <span class=C>self<span class=H>:</span>startClass<span class=E>( </span>className<span class=O>, </span>classInstance <span class=E>)<br>            </span>self<span class=H>.</span>lastClassName <span class=D>= </span>className<br>            self<span class=H>.</span>lastClassInstance <span class=D>= </span>classInstance<br>        </span>end<br><br>        <span class=C>self<span class=H>:</span>startTest<span class=E>(</span>prettyFuncName<span class=E>)<br><br>        <span class=G>local </span></span>node <span class=D>= </span>self<span class=H>.</span>result<span class=H>.</span>currentNode<br>        </span>for <span class=C>iter_n <span class=D>= <span class=M>1<span class=O>, </span></span></span>self<span class=H>.</span>exeRepeat <span class=J>or <span class=M>1 </span></span></span>do<br>            if <span class=C>node<span class=H>:</span>isNotSuccess<span class=E>() </span></span>then<br>                break<br>            end<br>            <span class=C>self<span class=H>.</span>currentCount <span class=D>= </span>iter_n<br><br>            <span class=U>-- </span></span></span>run setUp first (if any)<br>            <span class=N>if <span class=C>classInstance </span>then<br>                <span class=G>local <span class=C>func <span class=D>= </span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>setUp <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>Setup <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>setup <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>SetUp <span class=E>)<br>                </span></span></span>if <span class=C>func </span>then<br>                    <span class=C>self<span class=H>:</span>updateStatus<span class=E>(</span>self<span class=H>:</span>protectedCall<span class=E>(</span>classInstance<span class=O>, </span>func<span class=O>, </span>className<span class=E>..<span class=B>&#39;<span class=F>.setUp</span>&#39;</span>))<br>                </span></span>end<br>            end<br><br>            <span class=U>-- </span></span>run testMethod()<br>            <span class=N>if <span class=C>node<span class=H>:</span>isSuccess<span class=E>() </span></span>then<br>                <span class=C>self<span class=H>:</span>updateStatus<span class=E>(</span>self<span class=H>:</span>protectedCall<span class=E>(</span>classInstance<span class=O>, </span>methodInstance<span class=O>, </span>prettyFuncName<span class=E>))<br>            </span></span>end<br><br>            <span class=U>-- </span></span>lastly, run tearDown (if any)<br>            <span class=N>if <span class=C>classInstance </span>then<br>                <span class=G>local <span class=C>func <span class=D>= </span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>tearDown <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>TearDown <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>teardown <span class=E>) <span class=J>or<br>                             </span></span>self<span class=H>.</span>asFunction<span class=E>( </span>classInstance<span class=H>.</span>Teardown <span class=E>)<br>                </span></span></span>if <span class=C>func </span>then<br>                    <span class=C>self<span class=H>:</span>updateStatus<span class=E>(</span>self<span class=H>:</span>protectedCall<span class=E>(</span>classInstance<span class=O>, </span>func<span class=O>, </span>className<span class=E>..<span class=B>&#39;<span class=F>.tearDown</span>&#39;</span>))<br>                </span></span>end<br>            end<br>        end<br><br>        <span class=C>self<span class=H>:</span>endTest<span class=E>()<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit.expandOneClass<span class=E>( </span>result<span class=O>, </span>className<span class=O>, </span>classInstance <span class=E>)<br>        <span class=U>--[[<br>        </span></span></span></span>Input: a list of { name, instance }, a class name, a class instance<br>        Ouptut: modify result to add all test method instance in the form:<br>        { className.methodName, classInstance }<br>        <span class=U>]]<br>        <span class=N>for <span class=C>methodName<span class=O>, </span>methodInstance </span>in <span class=C>sortedPairs<span class=E>(</span>classInstance<span class=E>) </span></span>do<br>            if <span class=C>M<span class=H>.</span>LuaUnit<span class=H>.</span>asFunction<span class=E>(</span>methodInstance<span class=E>) <span class=I>and </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>isMethodTestName<span class=E>( </span>methodName <span class=E>) </span></span>then<br>                <span class=C>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=E>{ </span></span>className<span class=E>..<span class=B>&#39;<span class=F>.</span>&#39;</span>..</span>methodName<span class=O>, </span>classInstance <span class=E>} )<br>            </span></span>end<br>        end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit.expandClasses<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        </span></span></span></span>--[[<br>        </span>-- expand all classes (provided as {className, classInstance}) to a list of {className.methodName, classInstance}<br>        -- functions and methods remain untouched<br><br>        Input: a list of { name, instance }<br><br>        Output:<br>        * { function name, function instance } : do nothing<br>        * { class.method name, class instance }: do nothing<br>        * { class name, class instance } : add all method names in the form of (className.methodName, classInstance)<br>        <span class=U>]]<br>        <span class=G>local <span class=C>result <span class=D>= <span class=E>{}<br><br>        <span class=N>for </span></span></span>i<span class=O>,</span>v <span class=N>in </span>ipairs<span class=E>( </span>listOfNameAndInst <span class=E>) <span class=N>do<br>            </span></span></span>local <span class=C>name<span class=O>, </span>instance <span class=D>= </span>v<span class=E>[<span class=M>1</span>]<span class=O>, </span></span>v<span class=E>[<span class=M>2</span>]<br>            <span class=N>if </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>asFunction<span class=E>(</span>instance<span class=E>) <span class=N>then<br>                </span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=E>{ </span></span>name<span class=O>, </span>instance <span class=E>} )<br>            <span class=N>else<br>                if </span></span>type<span class=E>(</span>instance<span class=E>) ~= <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>                    </span></span></span>error<span class=E>( <span class=B>&#39;<span class=F>Instance must be a table or a function, not a </span>&#39;</span>..</span>type<span class=E>(</span>instance<span class=E>)..<span class=B>&#39; <span class=F>with value </span>&#39;</span>..</span>prettystr<span class=E>(</span>instance<span class=E>))<br>                <span class=N>end<br>                </span></span></span>local <span class=C>className<span class=O>, </span>methodName <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>splitClassMethod<span class=E>( </span>name <span class=E>)<br>                <span class=N>if </span></span>className <span class=N>then<br>                    </span></span>local <span class=C>methodInstance <span class=D>= </span>instance<span class=E>[</span>methodName<span class=E>]<br>                    <span class=N>if </span></span>methodInstance <span class=E>== <span class=L>nil <span class=N>then<br>                        </span></span></span>error<span class=E>( <span class=B>&#34;<span class=F>Could not find method in class </span>&#34;</span>..</span>tostring<span class=E>(</span>className<span class=E>)..<span class=B>&#34; <span class=F>for method </span>&#34;</span>..</span>tostring<span class=E>(</span>methodName<span class=E>) )<br>                    <span class=N>end<br>                    </span></span>table<span class=H>.</span>insert<span class=E>( </span>result<span class=O>, <span class=E>{ </span></span>name<span class=O>, </span>instance <span class=E>} )<br>                <span class=N>else<br>                    </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>expandOneClass<span class=E>( </span>result<span class=O>, </span>name<span class=O>, </span>instance <span class=E>)<br>                <span class=N>end<br>            end<br>        end<br><br>        <span class=K>return </span></span></span>result<br>    <span class=K>end<br><br>    function </span>M.LuaUnit.applyPatternFilter<span class=E>( </span>patternIncFilter<span class=O>, </span>listOfNameAndInst <span class=E>)<br>        </span></span>local <span class=C>included<span class=O>, </span>excluded <span class=D>= <span class=E>{}<span class=O>, </span>{}<br>        <span class=N>for </span></span></span>i<span class=O>, </span>v <span class=N>in </span>ipairs<span class=E>( </span>listOfNameAndInst <span class=E>) <span class=N>do<br>            </span></span></span></span>-- </span>local name, instance = v[1], v[2]<br>            <span class=N>if  <span class=C>patternFilter<span class=E>( </span>patternIncFilter<span class=O>, </span>v<span class=E>[<span class=M>1</span>] ) </span></span>then<br>                <span class=C>table<span class=H>.</span>insert<span class=E>( </span>included<span class=O>, </span>v <span class=E>)<br>            </span></span>else<br>                <span class=C>table<span class=H>.</span>insert<span class=E>( </span>excluded<span class=O>, </span>v <span class=E>)<br>            </span></span>end<br>        end<br>        <span class=K>return <span class=C>included<span class=O>, </span>excluded<br>    </span>end<br><br>    local function <span class=C>getKeyInListWithGlobalFallback<span class=E>( </span>key<span class=O>,  </span>listOfNameAndInst <span class=E>)<br>        <span class=G>local </span></span>result <span class=D>= <span class=L>nil<br>        </span></span></span></span>for <span class=C>i<span class=O>,</span>v </span>in <span class=C>ipairs<span class=E>( </span>listOfNameAndInst <span class=E>) </span></span>do<br>            if<span class=E>(<span class=C>listOfNameAndInst</span>[<span class=C>i</span>][<span class=M>1</span>] == <span class=C>key</span>) </span>then<br>                <span class=C>result <span class=D>= </span>listOfNameAndInst<span class=E>[</span>i<span class=E>][<span class=M>2</span>]<br>                </span></span>break<br>            end<br>        end<br>        if<span class=E>(not  <span class=C>M<span class=H>.</span>LuaUnit<span class=H>.</span>asFunction</span>( <span class=C>result </span>) ) </span>then<br>            <span class=C>result <span class=D>= </span>_G<span class=E>[</span>key<span class=E>]<br>        </span></span>end<br>        <span class=K>return <span class=C>result<br>    </span>end<br><br>    function <span class=C>M.LuaUnit:setupSuite<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        <span class=G>local </span></span>setupSuite <span class=D>= </span>getKeyInListWithGlobalFallback<span class=E>(<span class=B>&#34;<span class=F>setupSuite</span>&#34;<span class=O>, </span></span></span>listOfNameAndInst<span class=E>)<br>        </span></span></span>if  <span class=C>self<span class=H>.</span>asFunction<span class=E>( </span>setupSuite <span class=E>) </span></span>then<br>            <span class=C>self<span class=H>:</span>updateStatus<span class=E>( </span>self<span class=H>:</span>protectedCall<span class=E>( <span class=L>nil<span class=O>, </span></span></span>setupSuite<span class=O>, <span class=B>&#39;<span class=F>setupSuite</span>&#39; <span class=E>) )<br>        </span></span></span></span>end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit:teardownSuite<span class=E>(</span>listOfNameAndInst<span class=E>)<br>        <span class=G>local </span></span>teardownSuite <span class=D>= </span>getKeyInListWithGlobalFallback<span class=E>(<span class=B>&#34;<span class=F>teardownSuite</span>&#34;<span class=O>, </span></span></span>listOfNameAndInst<span class=E>)<br>        </span></span></span>if <span class=C>self<span class=H>.</span>asFunction<span class=E>( </span>teardownSuite <span class=E>) </span></span>then<br>            <span class=C>self<span class=H>:</span>updateStatus<span class=E>( </span>self<span class=H>:</span>protectedCall<span class=E>( <span class=L>nil<span class=O>, </span></span></span>teardownSuite<span class=O>, <span class=B>&#39;<span class=F>teardownSuite</span>&#39;<span class=E>) )<br>        </span></span></span></span>end<br>    <span class=K>end<br><br>    function  <span class=C>M.LuaUnit:setupClass<span class=E>( </span>className<span class=O>, </span>instance <span class=E>)<br>        </span></span></span>if <span class=C>type<span class=E>( </span>instance <span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>self<span class=H>.</span>asFunction<span class=E>( </span>instance<span class=H>.</span>setupClass <span class=E>) </span></span>then<br>            <span class=C>self<span class=H>:</span>updateStatus<span class=E>( </span>self<span class=H>:</span>protectedCall<span class=E>( </span>instance<span class=O>, </span>instance<span class=H>.</span>setupClass<span class=O>, </span>className<span class=E>..<span class=B>&#39;<span class=F>.setupClass</span>&#39; </span>) )<br>        </span></span>end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit:teardownClass<span class=E>( </span>className<span class=O>, </span>instance <span class=E>)<br>        </span></span></span>if <span class=C>type<span class=E>( </span>instance <span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>self<span class=H>.</span>asFunction<span class=E>( </span>instance<span class=H>.</span>teardownClass <span class=E>) </span></span>then<br>            <span class=C>self<span class=H>:</span>updateStatus<span class=E>( </span>self<span class=H>:</span>protectedCall<span class=E>( </span>instance<span class=O>, </span>instance<span class=H>.</span>teardownClass<span class=O>, </span>className<span class=E>..<span class=B>&#39;<span class=F>.teardownClass</span>&#39; </span>) )<br>        </span></span>end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit:internalRunSuiteByInstances<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        <span class=U>--[[ </span></span></span></span></span>Run an explicit list of tests. Each item of the list must be one of:<br>        * { function name, function instance }<br>        * { class name, class instance }<br>        * { class.method name, class instance }<br><br>        This function is internal to LuaUnit. The official API to perform this action is runSuiteByInstances()<br>        <span class=U>]]<br><br>        <span class=G>local <span class=C>expandedList <span class=D>= </span>self<span class=H>.</span>expandClasses<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        <span class=N>if </span></span>self<span class=H>.</span>shuffle <span class=N>then<br>            </span>randomizeTable<span class=E>( </span>expandedList <span class=E>)<br>        <span class=N>end<br>        </span></span></span>local <span class=C>filteredList<span class=O>, </span>filteredOutList <span class=D>= </span>self<span class=H>.</span>applyPatternFilter<span class=E>(<br>            </span>self<span class=H>.</span>patternIncludeFilter<span class=O>, </span>expandedList <span class=E>)<br><br>        </span>self<span class=H>:</span>startSuite<span class=E>( #</span>filteredList<span class=O>, <span class=E>#</span></span>filteredOutList <span class=E>)<br>        </span>self<span class=H>:</span>setupSuite<span class=E>( </span>listOfNameAndInst <span class=E>)<br><br>        <span class=N>for </span></span>i<span class=O>,</span>v <span class=N>in </span>ipairs<span class=E>( </span>filteredList <span class=E>) <span class=N>do<br>            </span></span></span>local <span class=C>name<span class=O>, </span>instance <span class=D>= </span>v<span class=E>[<span class=M>1</span>]<span class=O>, </span></span>v<span class=E>[<span class=M>2</span>]<br>            <span class=N>if </span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>asFunction<span class=E>(</span>instance<span class=E>) <span class=N>then<br>                </span></span>self<span class=H>:</span>execOneFunction<span class=E>( <span class=L>nil<span class=O>, </span></span></span>name<span class=O>, <span class=L>nil</span>, </span>instance <span class=E>)<br>            <span class=N>else<br>                </span></span></span></span>-- </span>expandClasses() should have already taken care of sanitizing the input<br>                <span class=C>assert<span class=E>( </span>type<span class=E>(</span>instance<span class=E>) == <span class=B>&#39;<span class=F>table</span>&#39; </span>)<br>                <span class=G>local </span></span>className<span class=O>, </span>methodName <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>splitClassMethod<span class=E>( </span>name <span class=E>)<br>                </span>assert<span class=E>( </span>className <span class=E>~= <span class=L>nil </span>)<br>                <span class=G>local </span></span>methodInstance <span class=D>= </span>instance<span class=E>[</span>methodName<span class=E>]<br>                </span>assert<span class=E>(</span>methodInstance <span class=E>~= <span class=L>nil</span>)<br>                </span>self<span class=H>:</span>execOneFunction<span class=E>( </span>className<span class=O>, </span>methodName<span class=O>, </span>instance<span class=O>, </span>methodInstance <span class=E>)<br>            <span class=N>end<br>            if </span></span>self<span class=H>.</span>result<span class=H>.</span>aborted <span class=N>then<br>                break <span class=U>-- </span></span></span>&#34;--error&#34; or &#34;--failure&#34; option triggered<br>            <span class=N>end<br>        end<br><br>        if <span class=C>self<span class=H>.</span>lastClassName <span class=E>~= <span class=L>nil </span></span></span>then<br>            <span class=C>self<span class=H>:</span>endClass<span class=E>()<br>        </span></span>end<br><br>        <span class=C>self<span class=H>:</span>teardownSuite<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        </span>self<span class=H>:</span>endSuite<span class=E>()<br><br>        </span></span>if <span class=C>self<span class=H>.</span>result<span class=H>.</span>aborted </span>then<br>            <span class=C>print<span class=E>(<span class=B>&#34;<span class=F>LuaUnit ABORTED (as requested by --error or --failure option)</span>&#34;</span>)<br>            </span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>            </span>os<span class=H>.</span>exit<span class=E>(-<span class=M>2</span>)<br>        </span></span>end<br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit:internalRunSuiteByNames<span class=E>( </span>listOfName <span class=E>)<br>        <span class=U>--[[ </span></span></span></span></span>Run LuaUnit with a list of generic names, coming either from command-line or from global<br>            namespace analysis. Convert the list into a list of (name, valid instances (table or function))<br>            and calls internalRunSuiteByInstances.<br>        <span class=U>]]<br><br>        <span class=G>local <span class=C>instanceName<span class=O>, </span>instance<br>        </span>local <span class=C>listOfNameAndInst <span class=D>= <span class=E>{}<br><br>        <span class=N>for </span></span></span>i<span class=O>,</span>name <span class=N>in </span>ipairs<span class=E>( </span>listOfName <span class=E>) <span class=N>do<br>            </span></span></span>local <span class=C>className<span class=O>, </span>methodName <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>splitClassMethod<span class=E>( </span>name <span class=E>)<br>            <span class=N>if </span></span>className <span class=N>then<br>                </span>instanceName <span class=D>= </span>className<br>                instance <span class=D>= </span>_G<span class=E>[</span>instanceName<span class=E>]<br><br>                <span class=N>if </span></span>instance <span class=E>== <span class=L>nil <span class=N>then<br>                    </span></span></span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>                    </span>error<span class=E>( <span class=B>&#34;<span class=F>No such name in global space: </span>&#34;</span>..</span>instanceName <span class=E>)<br>                <span class=N>end<br><br>                if </span></span>type<span class=E>(</span>instance<span class=E>) ~= <span class=B>&#39;<span class=F>table</span>&#39; <span class=N>then<br>                    </span></span></span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>                    </span>error<span class=E>( <span class=B>&#39;<span class=F>Instance of </span>&#39;</span>..</span>instanceName<span class=E>..<span class=B>&#39; <span class=F>must be a table, not </span>&#39;</span>..</span>type<span class=E>(</span>instance<span class=E>))<br>                <span class=N>end<br><br>                </span></span></span>local <span class=C>methodInstance <span class=D>= </span>instance<span class=E>[</span>methodName<span class=E>]<br>                <span class=N>if </span></span>methodInstance <span class=E>== <span class=L>nil <span class=N>then<br>                    </span></span></span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>                    </span>error<span class=E>( <span class=B>&#34;<span class=F>Could not find method in class </span>&#34;</span>..</span>tostring<span class=E>(</span>className<span class=E>)..<span class=B>&#34; <span class=F>for method </span>&#34;</span>..</span>tostring<span class=E>(</span>methodName<span class=E>) )<br>                <span class=N>end<br><br>            else<br>                </span></span></span></span>-- </span>for functions and classes<br>                <span class=C>instanceName <span class=D>= </span>name<br>                instance <span class=D>= </span>_G<span class=E>[</span>instanceName<span class=E>]<br>            <span class=N>end<br><br>            if </span></span>instance <span class=E>== <span class=L>nil <span class=N>then<br>                </span></span></span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>                </span>error<span class=E>( <span class=B>&#34;<span class=F>No such name in global space: </span>&#34;</span>..</span>instanceName <span class=E>)<br>            <span class=N>end<br><br>            if </span>(</span>type<span class=E>(</span>instance<span class=E>) ~= <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>type<span class=E>(</span>instance<span class=E>) ~= <span class=B>&#39;<span class=F>function</span>&#39;</span>) <span class=N>then<br>                </span></span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>                </span>error<span class=E>( <span class=B>&#39;<span class=F>Name must match a function or a table: </span>&#39;</span>..</span>instanceName <span class=E>)<br>            <span class=N>end<br><br>            </span></span>table<span class=H>.</span>insert<span class=E>( </span>listOfNameAndInst<span class=O>, <span class=E>{ </span></span>name<span class=O>, </span>instance <span class=E>} )<br>        <span class=N>end<br><br>        </span></span>self<span class=H>:</span>internalRunSuiteByInstances<span class=E>( </span>listOfNameAndInst <span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit.run<span class=E>(<span class=O>...</span>)<br>        <span class=U>-- </span></span></span>Run some specific test classes.<br>        <span class=U>-- </span>If no arguments are passed, run the class names specified on the<br>        <span class=U>-- </span>command line. If no class name is specified on the command line<br>        <span class=U>-- </span>run all classes whose name starts with &#39;Test&#39;<br>        <span class=U>--<br>        -- </span>If arguments are passed, they must be strings of the class names<br>        <span class=U>-- </span>that you want to run or generic command line arguments (-o, -p, -v, ...)<br>        <span class=G>local <span class=C>runner <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>new<span class=E>()<br>        <span class=K>return </span></span>runner<span class=H>:</span>runSuite<span class=E>(<span class=O>...</span>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:registerSuite<span class=E>()<br>        <span class=U>-- </span></span></span></span>register the current instance into our global array of instances<br>        <span class=U>-- </span>print(&#39;-&gt; Register suite&#39;)<br>        <span class=C>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=E>[ #</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=E>+<span class=M>1 </span>] <span class=D>= </span></span>self<br>    <span class=K>end<br><br>    function </span>M.unregisterCurrentSuite<span class=E>()<br>        <span class=U>-- </span></span></span>force unregister the last registered suite<br>        <span class=C>table<span class=H>.</span>remove<span class=E>(</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=O>, <span class=E>#</span></span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=E>)<br>    <span class=K>end<br><br>    function </span></span>M.LuaUnit:unregisterSuite<span class=E>()<br>        <span class=U>-- </span></span></span>print(&#39;&lt;- Unregister suite&#39;)<br>        <span class=U>-- </span>remove our current instqances from the global array of instances<br>        <span class=G>local <span class=C>instanceIdx <span class=D>= <span class=L>nil<br>        <span class=N>for </span></span></span>i<span class=O>, </span>instance <span class=N>in </span>ipairs<span class=E>(</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=E>) <span class=N>do<br>            if </span></span>instance <span class=E>== </span>self <span class=N>then<br>                </span>instanceIdx <span class=D>= </span>i<br>                <span class=N>break<br>            end<br>        end<br><br>        if </span>instanceIdx <span class=E>~= <span class=L>nil <span class=N>then<br>            </span></span></span>table<span class=H>.</span>remove<span class=E>(</span>M<span class=H>.</span>LuaUnit<span class=H>.</span>instances<span class=O>, </span>instanceIdx<span class=E>)<br>            <span class=U>-- </span></span></span></span>print(&#39;Unregister done&#39;)<br>        <span class=N>end<br><br>    <span class=K>end<br><br>    function <span class=C>M.LuaUnit:initFromArguments<span class=E>( <span class=O>... </span>)<br>        <span class=U>--[[</span></span></span></span></span>Parses all arguments from either command-line or direct call and set internal<br>        flags of LuaUnit runner according to it.<br><br>        Return the list of names which were possibly passed on the command-line or as arguments<br>        <span class=U>]]<br>        <span class=G>local <span class=C>args <span class=D>= <span class=E>{<span class=O>...</span>}<br>        <span class=N>if </span></span></span>type<span class=E>(</span>args<span class=E>[<span class=M>1</span>]) == <span class=B>&#39;<span class=F>table</span>&#39; <span class=I>and </span></span></span>args<span class=E>[<span class=M>1</span>]<span class=H>.</span></span>__class__ <span class=E>== <span class=B>&#39;<span class=F>LuaUnit</span>&#39; <span class=N>then<br>            </span></span></span></span></span>-- </span>run was called with the syntax M.LuaUnit:runSuite()<br>            <span class=U>-- </span>we support both M.LuaUnit.run() and M.LuaUnit:run()<br>            <span class=U>-- </span>strip out the first argument self to make it a command-line argument list<br>            <span class=C>table<span class=H>.</span>remove<span class=E>(</span>args<span class=O>,<span class=M>1<span class=E>)<br>        <span class=N>end<br><br>        if </span>#</span></span></span>args <span class=E>== <span class=M>0 <span class=N>then<br>            </span></span></span>args <span class=D>= </span>cmdline_argv<br>        <span class=N>end<br><br>        <span class=G>local </span></span>options <span class=D>= </span>pcall_or_abort<span class=E>( </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>parseCmdLine<span class=O>, </span>args <span class=E>)<br><br>        <span class=U>-- </span></span></span>We expect these option fields to be either `nil` or contain<br>        <span class=U>-- </span>valid values, so it&#39;s safe to always copy them directly.<br>        <span class=C>self<span class=H>.</span>verbosity     <span class=D>= </span>options<span class=H>.</span>verbosity<br>        self<span class=H>.</span>quitOnError   <span class=D>= </span>options<span class=H>.</span>quitOnError<br>        self<span class=H>.</span>quitOnFailure <span class=D>= </span>options<span class=H>.</span>quitOnFailure<br><br>        self<span class=H>.</span>exeRepeat            <span class=D>= </span>options<span class=H>.</span>exeRepeat<br>        self<span class=H>.</span>patternIncludeFilter <span class=D>= </span>options<span class=H>.</span>pattern<br>        self<span class=H>.</span>shuffle              <span class=D>= </span>options<span class=H>.</span>shuffle<br><br>        options<span class=H>.</span>output     <span class=D>= </span>options<span class=H>.</span>output <span class=J>or </span>os<span class=H>.</span>getenv<span class=E>(<span class=B>&#39;<span class=F>LUAUNIT_OUTPUT</span>&#39;</span>)<br>        </span>options<span class=H>.</span>fname      <span class=D>= </span>options<span class=H>.</span>fname  <span class=J>or </span>os<span class=H>.</span>getenv<span class=E>(<span class=B>&#39;<span class=F>LUAUNIT_JUNIT_FNAME</span>&#39;</span>)<br><br>        <span class=N>if </span></span>options<span class=H>.</span>output <span class=N>then<br>            if </span>options<span class=H>.</span>output<span class=H>:</span>lower<span class=E>() == <span class=B>&#39;<span class=F>junit</span>&#39; <span class=I>and </span></span></span>options<span class=H>.</span>fname <span class=E>== <span class=L>nil <span class=N>then<br>                </span></span></span>print<span class=E>(<span class=B>&#39;<span class=F>With junit output, a filename must be supplied with -n or --name</span>&#39;</span>)<br>                </span>os<span class=H>.</span>exit<span class=E>(-<span class=M>1</span>)<br>            <span class=N>end<br>            </span></span>pcall_or_abort<span class=E>(</span>self<span class=H>.</span>setOutputType<span class=O>, </span>self<span class=O>, </span>options<span class=H>.</span>output<span class=O>, </span>options<span class=H>.</span>fname<span class=E>)<br>        <span class=N>end<br><br>        <span class=K>return </span></span></span>options<span class=H>.</span>testNames<br>    <span class=K>end<br><br>    function </span>M.LuaUnit:runSuite<span class=E>( <span class=O>... </span>)<br>        <span class=G>local </span></span>testNames <span class=D>= </span>self<span class=H>:</span>initFromArguments<span class=E>(<span class=O>...</span>)<br>        </span>self<span class=H>:</span>registerSuite<span class=E>()<br>        </span>self<span class=H>:</span>internalRunSuiteByNames<span class=E>( </span>testNames <span class=J>or </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>collectTests<span class=E>() )<br>        </span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>        <span class=K>return </span></span>self<span class=H>.</span>result<span class=H>.</span>notSuccessCount<br>    <span class=K>end<br><br>    function </span>M.LuaUnit:runSuiteByInstances<span class=E>( </span>listOfNameAndInst<span class=O>, </span>commandLineArguments <span class=E>)<br>        <span class=U>--[[<br>        </span></span></span>Run all test functions or tables provided as input.<br><br>        Input: a list of { name, instance }<br>            instance can either be a function or a table containing test functions starting with the prefix &#34;test&#34;<br><br>        return the number of failures and errors, 0 meaning success<br>        <span class=U>]]<br>        -- </span>parse the command-line arguments<br>        <span class=G>local <span class=C>testNames <span class=D>= </span>self<span class=H>:</span>initFromArguments<span class=E>( </span>commandLineArguments <span class=E>)<br>        </span>self<span class=H>:</span>registerSuite<span class=E>()<br>        </span>self<span class=H>:</span>internalRunSuiteByInstances<span class=E>( </span>listOfNameAndInst <span class=E>)<br>        </span>self<span class=H>:</span>unregisterSuite<span class=E>()<br>        <span class=K>return </span></span>self<span class=H>.</span>result<span class=H>.</span>notSuccessCount<br>    <span class=K>end<br><br><br><br><span class=U>-- </span></span></span></span>class LuaUnit<br><br><span class=U>-- </span>For compatbility with LuaUnit v2<br><span class=C>M<span class=H>.</span>run <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>run<br>M<span class=H>.</span>Run <span class=D>= </span>M<span class=H>.</span>LuaUnit<span class=H>.</span>run<br><br><span class=K>function </span>M:setVerbosity<span class=E>( </span>verbosity <span class=E>)<br>    <span class=U>-- </span></span></span>set the verbosity value (as integer)<br>    <span class=C>M<span class=H>.</span>LuaUnit<span class=H>.</span>verbosity <span class=D>= </span>verbosity<br><span class=K>end<br></span>M<span class=H>.</span>set_verbosity <span class=D>= </span>M<span class=H>.</span>setVerbosity<br>M<span class=H>.</span>SetVerbosity <span class=D>= </span>M<span class=H>.</span>setVerbosity<br><br><br><span class=K>return </span>M<br><br></span></code></div></div></body></html>