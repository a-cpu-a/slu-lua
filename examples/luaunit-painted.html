<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="description" content="Lua-unit highlighted"><title>Example</title><style>body{color:#AFAFAA;font-family:"Monaco",monospace;background:#000;margin-bottom:500px}h1{font-size:5em;text-align:center}#s{border-radius:10px;background:#222;width:800px;margin:auto;padding:12px 12px;overflow:visible}.q{overflow:hidden;border-radius:10px;background:#333;padding:7px 7px;position:relative;overflow:visible}.slua-code-box{tab-size:3;white-space-collapse:preserve;background:#151515;padding:8px;border-radius:8px;margin:4px 0px;display:block}</style></head><body><h1>Luaunit</h1><div id=s><div class=q><style>.A{color:#575763}.B{color:#ABD062}.C{color:#D7D7D7}.D{color:#E44F6E}.E{color:#8D97A7}.F{color:#7AA737}.G{color:#D77C7C}.H{color:#BEC3CB}.I{color:#5686DA}.J{color:#B47F54}.K{color:#CD4B4B}.L{color:#6481C0}.M{color:#529ABC}.N{color:#BC70C3}.O{color:#A8AFBB}.P{color:#9BA4B1}.R{color:#A9B0BC}.T{color:#716BA1}</style><code class=slua-code-box><span></span><span class=A>--[[<br>        luaunit.lua<br><br>Description: A unit testing framework<br>Homepage: https://github.com/bluebird75/luaunit<br>Development by Philippe Fremy &lt;phil@freehackers.org&gt;<br>Based on initial work of Ryu, Gwang (http://www.gpgstudy.com/gpgiki/LuaUnit)<br>License: BSD License, see LICENSE.txt<br>]]--<br><br></span><span class=C>require</span><span class=E>(</span><span class=B>&#34;</span><span class=F>math</span><span class=B>&#34;</span><span class=E>)<br></span><span class=G>local</span><span class=C> M</span><span class=D>=</span><span class=E>{}<br><br></span><span class=A>-- private exported functions (for testing)<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=D> =</span><span class=E> {}<br><br></span><span class=C>M</span><span class=H>.</span><span class=C>VERSION</span><span class=D>=</span><span class=B>&#39;</span><span class=F>3.4</span><span class=B>&#39;<br></span><span class=C>M</span><span class=H>.</span><span class=C>_VERSION</span><span class=D>=</span><span class=C>M</span><span class=H>.</span><span class=C>VERSION</span><span class=A> -- For LuaUnit v2 compatibility<br><br>-- a version which distinguish between regular Lua and LuaJit<br></span><span class=C>M</span><span class=H>.</span><span class=C>_LUAVERSION</span><span class=D> =</span><span class=E> (</span><span class=C>jit</span><span class=I> and</span><span class=C> jit</span><span class=H>.</span><span class=C>version</span><span class=E>)</span><span class=J> or</span><span class=C> _VERSION<br><br></span><span class=A>--[[ Some people like assertEquals( actual, expected ) and some people prefer<br>assertEquals( expected, actual ).<br>]]--<br></span><span class=C>M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=D> =</span><span class=L> true<br></span><span class=C>M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=D> =</span><span class=L> false<br></span><span class=C>M</span><span class=H>.</span><span class=C>LINE_LENGTH</span><span class=D> =</span><span class=M> 80<br></span><span class=C>M</span><span class=H>.</span><span class=C>TABLE_DIFF_ANALYSIS_THRESHOLD</span><span class=D> =</span><span class=M> 10</span><span class=A>    -- display deep analysis for more than 10 items<br></span><span class=C>M</span><span class=H>.</span><span class=C>LIST_DIFF_ANALYSIS_THRESHOLD</span><span class=D>  =</span><span class=M> 10</span><span class=A>    -- display deep analysis for more than 10 items<br><br>-- this setting allow to remove entries from the stack-trace, for <br>-- example to hide a call to a framework which would be calling luaunit<br></span><span class=C>M</span><span class=H>.</span><span class=C>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE</span><span class=D> =</span><span class=M> 0<br><br></span><span class=A>--[[ EPS is meant to help with Lua&#39;s floating point math in simple corner<br>cases like almostEquals(1.1-0.1, 1), which may not work as-is (e.g. on numbers<br>with rational binary representation) if the user doesn&#39;t provide some explicit<br>error margin.<br><br>The default margin used by almostEquals() in such cases is EPS; and since<br>Lua may be compiled with different numeric precisions (single vs. double), we<br>try to select a useful default for it dynamically. Note: If the initial value<br>is not acceptable, it can be changed by the user to better suit specific needs.<br><br>See also: https://en.wikipedia.org/wiki/Machine_epsilon<br>]]<br></span><span class=C>M</span><span class=H>.</span><span class=C>EPS</span><span class=D> =</span><span class=M> 2</span><span class=E>^-</span><span class=M>52</span><span class=A> -- = machine epsilon for &#34;double&#34;, ~2.22E-16<br></span><span class=N>if</span><span class=C> math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=M>1.1</span><span class=E> -</span><span class=M> 1</span><span class=E> -</span><span class=M> 0.1</span><span class=E>) &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>EPS</span><span class=N> then<br></span><span class=A>    -- rounding error is above EPS, assume single precision<br>    </span><span class=C>M</span><span class=H>.</span><span class=C>EPS</span><span class=D> =</span><span class=M> 2</span><span class=E>^-</span><span class=M>23</span><span class=C565662> -- = machine epsilon for &#34;float&#34;, ~1.19E-07<br></span><span class=N>end<br><br></span><span class=A>-- set this to false to debug luaunit<br></span><span class=G>local</span><span class=C> STRIP_LUAUNIT_FROM_STACKTRACE</span><span class=D> =</span><span class=L> true<br><br></span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=D> =</span><span class=M> 10<br></span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_LOW</span><span class=D>     =</span><span class=M> 1<br></span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_QUIET</span><span class=D>   =</span><span class=M> 0<br></span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_VERBOSE</span><span class=D> =</span><span class=M> 20<br></span><span class=C>M</span><span class=H>.</span><span class=C>DEFAULT_DEEP_ANALYSIS</span><span class=D> =</span><span class=L> nil<br></span><span class=C>M</span><span class=H>.</span><span class=C>FORCE_DEEP_ANALYSIS</span><span class=D>   =</span><span class=L> true<br></span><span class=C>M</span><span class=H>.</span><span class=C>DISABLE_DEEP_ANALYSIS</span><span class=D> =</span><span class=L> false<br><br></span><span class=A>-- set EXPORT_ASSERT_TO_GLOBALS to have all asserts visible as global values<br>-- EXPORT_ASSERT_TO_GLOBALS = true<br><br>-- we need to keep a copy of the script args before it is overriden<br></span><span class=G>local</span><span class=C> cmdline_argv</span><span class=D> =</span><span class=C> rawget</span><span class=E>(</span><span class=C>_G</span><span class=O>,</span><span class=B> &#34;</span><span class=F>arg</span><span class=B>&#34;</span><span class=E>)<br><br></span><span class=C>M</span><span class=H>.</span><span class=C>FAILURE_PREFIX</span><span class=D> =</span><span class=B> &#39;</span><span class=F>LuaUnit test FAILURE: </span><span class=B>&#39;</span><span class=A> -- prefix string for failed tests<br></span><span class=C>M</span><span class=H>.</span><span class=C>SUCCESS_PREFIX</span><span class=D> =</span><span class=B> &#39;</span><span class=F>LuaUnit test SUCCESS: </span><span class=B>&#39;</span><span class=A> -- prefix string for successful tests finished early<br></span><span class=C>M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=D>    =</span><span class=B> &#39;</span><span class=F>LuaUnit test SKIP:    </span><span class=B>&#39;</span><span class=A> -- prefix string for skipped tests<br><br><br><br></span><span class=C>M</span><span class=H>.</span><span class=C>USAGE</span><span class=D>=</span><span class=B>[[</span><span class=F>Usage: lua &lt;your_test_suite.lua&gt; [options] [testname1 [testname2] ... ]<br>Options:<br>  -h, --help:             Print this help<br>  --version:              Print version information<br>  -v, --verbose:          Increase verbosity<br>  -q, --quiet:            Set verbosity to minimum<br>  -e, --error:            Stop on first error<br>  -f, --failure:          Stop on first failure or error<br>  -s, --shuffle:          Shuffle tests before running them<br>  -o, --output OUTPUT:    Set output type to OUTPUT<br>                          Possible values: text, tap, junit, nil<br>  -n, --name NAME:        For junit only, mandatory name of xml file<br>  -r, --repeat NUM:       Execute all tests NUM times, e.g. to trig the JIT<br>  -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN<br>                          May be repeated to include several patterns<br>                          Make sure you escape magic chars like +? with %<br>  -x, --exclude PATTERN:  Exclude all test names matching the Lua PATTERN<br>                          May be repeated to exclude several patterns<br>                          Make sure you escape magic chars like +? with %<br>  testname1, testname2, ... : tests to run in the form of testFunction,<br>                              TestClass or TestClass.testMethod<br><br>You may also control LuaUnit options with the following environment variables:<br>* LUAUNIT_OUTPUT: same as --output<br>* LUAUNIT_JUNIT_FNAME: same as --name </span><span class=B>]]<br><br></span><span class=A>----------------------------------------------------------------<br>--<br>--                 general utility functions<br>--<br>----------------------------------------------------------------<br><br>--[[ Note on catching exit<br><br>I have seen the case where running a big suite of test cases and one of them would<br>perform a os.exit(0), making the outside world think that the full test suite was executed<br>successfully.<br><br>This is an attempt to mitigate this problem: we override os.exit() to now let a test<br>exit the framework while we are running. When we are not running, it behaves normally.<br>]]<br><br></span><span class=C>M</span><span class=H>.</span><span class=C>oldOsExit</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>exit<br>os</span><span class=H>.</span><span class=C>exit</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=O>...</span><span class=E>)</span><span class=A> <br>    </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=I> and</span><span class=E> #</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=E> ~=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> msg</span><span class=D> =</span><span class=B> [[</span><span class=F>You are trying to exit but there is still a running instance of LuaUnit.<br>LuaUnit expects to run until the end before exiting with a complete status of successful/failed tests.<br><br>To force exit LuaUnit while running, please call before os.exit (assuming lu is the luaunit module loaded):<br><br>    lu.unregisterCurrentSuite() <br><br></span><span class=B>]]<br></span><span class=A>        </span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=A>    </span><span class=C>M</span><span class=H>.</span><span class=C>oldOsExit</span><span class=E>(</span><span class=O>...</span><span class=E>)<br></span><span class=K>end<br><br>local function</span><span class=C> pcall_or_abort</span><span class=E>(</span><span class=C>func</span><span class=O>, ...</span><span class=E>)<br></span><span class=A>    -- unpack is a global function for Lua 5.1, otherwise use table.unpack<br>    </span><span class=G>local</span><span class=C> unpack</span><span class=D> =</span><span class=C> rawget</span><span class=E>(</span><span class=C>_G</span><span class=O>,</span><span class=B> &#34;</span><span class=F>unpack</span><span class=B>&#34;</span><span class=E>)</span><span class=J> or</span><span class=C> table</span><span class=H>.</span><span class=C>unpack<br></span><span class=A>    </span><span class=G>local</span><span class=C> result</span><span class=D> =</span><span class=E> {</span><span class=C>pcall</span><span class=E>(</span><span class=C>func</span><span class=O>, ...</span><span class=E>)}<br></span><span class=A>    </span><span class=N>if</span><span class=E> not</span><span class=C> result</span><span class=E>[</span><span class=M>1</span><span class=E>]</span><span class=N> then<br></span><span class=A>        -- an error occurred<br>        </span><span class=C>print</span><span class=E>(</span><span class=C>result</span><span class=E>[</span><span class=M>2</span><span class=E>])</span><span class=A> -- error message<br>        </span><span class=C>print</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>USAGE</span><span class=E>)<br></span><span class=A>        </span><span class=C>os</span><span class=H>.</span><span class=C>exit</span><span class=E>(-</span><span class=M>1</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>unpack</span><span class=E>(</span><span class=C>result</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=K>end<br><br></span><span class=G>local</span><span class=C> crossTypeOrdering</span><span class=D> =</span><span class=E> {<br></span><span class=P>    number</span><span class=D> =</span><span class=M> 1</span><span class=O>,</span><span class=P> boolean</span><span class=D> =</span><span class=M> 2</span><span class=O>,</span><span class=P> string</span><span class=D> =</span><span class=M> 3</span><span class=O>,</span><span class=P> table</span><span class=D> =</span><span class=M> 4</span><span class=O>,</span><span class=P> other</span><span class=D> =</span><span class=M> 5<br></span><span class=E>}<br></span><span class=G>local</span><span class=C> crossTypeComparison</span><span class=D> =</span><span class=E> {<br></span><span class=P>    number</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>a</span><span class=O>,</span><span class=C> b</span><span class=E>)</span><span class=A> </span><span class=K>return</span><span class=A> </span><span class=C>a</span><span class=E> &lt;</span><span class=A> </span><span class=C>b</span><span class=R> </span><span class=K>end</span><span class=O>,<br></span><span class=P>    string</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>a</span><span class=O>,</span><span class=C> b</span><span class=E>)</span><span class=A> </span><span class=K>return</span><span class=A> </span><span class=C>a</span><span class=E> &lt;</span><span class=A> </span><span class=C>b</span><span class=R> </span><span class=K>end</span><span class=O>,<br></span><span class=P>    other</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>a</span><span class=O>,</span><span class=C> b</span><span class=E>)</span><span class=A> </span><span class=K>return</span><span class=A> </span><span class=C>tostring</span><span class=E>(</span><span class=C>a</span><span class=E>) &lt;</span><span class=A> </span><span class=C>tostring</span><span class=E>(</span><span class=C>b</span><span class=E>)</span><span class=R> </span><span class=K>end</span><span class=O>,<br></span><span class=E>}<br><br></span><span class=K>local function</span><span class=C> crossTypeSort</span><span class=E>(</span><span class=C>a</span><span class=O>,</span><span class=C> b</span><span class=E>)<br></span><span class=A>    </span><span class=G>local</span><span class=C> type_a</span><span class=O>,</span><span class=C> type_b</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>a</span><span class=E>)</span><span class=O>,</span><span class=C> type</span><span class=E>(</span><span class=C>b</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type_a</span><span class=E> ==</span><span class=C> type_b</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> func</span><span class=D> =</span><span class=C> crossTypeComparison</span><span class=E>[</span><span class=C>type_a</span><span class=E>]</span><span class=J> or</span><span class=C> crossTypeComparison</span><span class=H>.</span><span class=C>other<br></span><span class=K>        return</span><span class=A> </span><span class=C>func</span><span class=E>(</span><span class=C>a</span><span class=O>,</span><span class=C> b</span><span class=E>)<br></span><span class=R>    </span><span class=N>end<br></span><span class=A>    </span><span class=C>type_a</span><span class=D> =</span><span class=C> crossTypeOrdering</span><span class=E>[</span><span class=C>type_a</span><span class=E>]</span><span class=J> or</span><span class=C> crossTypeOrdering</span><span class=H>.</span><span class=C>other<br></span><span class=A>    </span><span class=C>type_b</span><span class=D> =</span><span class=C> crossTypeOrdering</span><span class=E>[</span><span class=C>type_b</span><span class=E>]</span><span class=J> or</span><span class=C> crossTypeOrdering</span><span class=H>.</span><span class=C>other<br></span><span class=K>    return</span><span class=A> </span><span class=C>type_a</span><span class=E> &lt;</span><span class=A> </span><span class=C>type_b<br></span><span class=K>end<br><br>local function</span><span class=C> __genSortedIndex</span><span class=E>(</span><span class=C> t</span><span class=E> )<br></span><span class=A>    -- Returns a sequence consisting of t&#39;s keys, sorted.<br>    </span><span class=G>local</span><span class=C> sortedIndex</span><span class=D> =</span><span class=E> {}<br><br></span><span class=A>    </span><span class=N>for</span><span class=C> key</span><span class=O>,</span><span class=C>_</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>t</span><span class=E>)</span><span class=N> do<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>sortedIndex</span><span class=O>,</span><span class=C> key</span><span class=E>)<br></span><span class=N>    end<br><br></span><span class=A>    </span><span class=C>table</span><span class=H>.</span><span class=C>sort</span><span class=E>(</span><span class=C>sortedIndex</span><span class=O>,</span><span class=C> crossTypeSort</span><span class=E>)<br></span><span class=K>    return</span><span class=A> </span><span class=C>sortedIndex<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>__genSortedIndex</span><span class=D> =</span><span class=C> __genSortedIndex<br><br></span><span class=K>local function</span><span class=C> sortedNext</span><span class=E>(</span><span class=C>state</span><span class=O>,</span><span class=C> control</span><span class=E>)<br></span><span class=A>    -- Equivalent of the next() function of table iteration, but returns the<br>    -- keys in sorted order (see __genSortedIndex and crossTypeSort).<br>    -- The state is a temporary variable during iteration and contains the<br>    -- sorted key table (state.sortedIdx). It also stores the last index (into<br>    -- the keys) used by the iteration, to find the next one quickly.<br>    </span><span class=G>local</span><span class=C> key<br><br></span><span class=A>    --print(&#34;sortedNext: control = &#34;..tostring(control) )<br>    </span><span class=N>if</span><span class=C> control</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        -- start of iteration<br>        </span><span class=C>state</span><span class=H>.</span><span class=C>count</span><span class=D> =</span><span class=E> #</span><span class=C>state</span><span class=H>.</span><span class=C>sortedIdx<br></span><span class=A>        </span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=D> =</span><span class=M> 1<br></span><span class=A>        </span><span class=C>key</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>sortedIdx</span><span class=E>[</span><span class=M>1</span><span class=E>]<br></span><span class=K>        return</span><span class=A> </span><span class=C>key</span><span class=O>,</span><span class=C> state</span><span class=H>.</span><span class=C>t</span><span class=E>[</span><span class=C>key</span><span class=E>]<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    -- normally, we expect the control variable to match the last key used<br>    </span><span class=N>if</span><span class=C> control</span><span class=E> ~=</span><span class=C> state</span><span class=H>.</span><span class=C>sortedIdx</span><span class=E>[</span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E>]</span><span class=N> then<br></span><span class=A>        -- strange, we have to find the next value by ourselves<br>        -- the key table is sorted in crossTypeSort() order! -&gt; use bisection<br>        </span><span class=G>local</span><span class=C> lower</span><span class=O>,</span><span class=C> upper</span><span class=D> =</span><span class=M> 1</span><span class=O>,</span><span class=C> state</span><span class=H>.</span><span class=C>count<br></span><span class=A>        </span><span class=N>repeat<br></span><span class=A>            </span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>modf</span><span class=E>((</span><span class=C>lower</span><span class=E> +</span><span class=C> upper</span><span class=E>) /</span><span class=A> </span><span class=M>2</span><span class=E>)<br></span><span class=A>            </span><span class=C>key</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>sortedIdx</span><span class=E>[</span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E>]<br></span><span class=A>            </span><span class=N>if</span><span class=C> key</span><span class=E> ==</span><span class=C> control</span><span class=N> then<br></span><span class=A>                </span><span class=N>break</span><span class=C565662> -- key found (and thus prev index)<br></span><span class=N>            end<br></span><span class=A>            </span><span class=N>if</span><span class=C> crossTypeSort</span><span class=E>(</span><span class=C>key</span><span class=O>,</span><span class=C> control</span><span class=E>)</span><span class=N> then<br></span><span class=A>                -- key &lt; control, continue search &#34;right&#34; (towards upper bound)<br>                </span><span class=C>lower</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E> +</span><span class=M> 1<br></span><span class=N>            else<br></span><span class=A>                -- key &gt; control, continue search &#34;left&#34; (towards lower bound)<br>                </span><span class=C>upper</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E> -</span><span class=M> 1<br></span><span class=N>            end<br>        until</span><span class=C> lower</span><span class=E> &gt;</span><span class=A> </span><span class=C>upper<br></span><span class=A>        </span><span class=N>if</span><span class=C> lower</span><span class=E> &gt;</span><span class=A> </span><span class=C>upper</span><span class=N> then</span><span class=A> -- only true if the key wasn&#39;t found, ...<br>            </span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>count</span><span class=C565662> -- ... so ensure no match in code below<br></span><span class=N>        end<br>    end<br><br></span><span class=A>    -- proceed by retrieving the next value (or nil) from the sorted keys<br>    </span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E> +</span><span class=M> 1<br></span><span class=A>    </span><span class=C>key</span><span class=D> =</span><span class=C> state</span><span class=H>.</span><span class=C>sortedIdx</span><span class=E>[</span><span class=C>state</span><span class=H>.</span><span class=C>lastIdx</span><span class=E>]<br></span><span class=A>    </span><span class=N>if</span><span class=C> key</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>key</span><span class=O>,</span><span class=C> state</span><span class=H>.</span><span class=C>t</span><span class=E>[</span><span class=C>key</span><span class=E>]<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=C565662>    -- getting here means returning `nil`, which will end the iteration<br></span><span class=K>end<br><br>local function</span><span class=C> sortedPairs</span><span class=E>(</span><span class=C>tbl</span><span class=E>)<br></span><span class=A>    -- Equivalent of the pairs() function on tables. Allows to iterate in<br>    -- sorted order. As required by &#34;generic for&#34; loops, this will return the<br>    -- iterator (function), an &#34;invariant state&#34;, and the initial control value.<br>    -- (see http://www.lua.org/pil/7.2.html)<br>    </span><span class=K>return</span><span class=A> </span><span class=C>sortedNext</span><span class=O>,</span><span class=E> {</span><span class=P>t</span><span class=D> =</span><span class=C> tbl</span><span class=O>,</span><span class=P> sortedIdx</span><span class=D> =</span><span class=C> __genSortedIndex</span><span class=E>(</span><span class=C>tbl</span><span class=E>)}</span><span class=O>,</span><span class=L> nil<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>sortedPairs</span><span class=D> =</span><span class=C> sortedPairs<br><br></span><span class=A>-- seed the random with a strongly varying seed<br></span><span class=C>math</span><span class=H>.</span><span class=C>randomseed</span><span class=E>(</span><span class=C>math</span><span class=H>.</span><span class=C>floor</span><span class=E>(</span><span class=C>os</span><span class=H>.</span><span class=C>clock</span><span class=E>()*</span><span class=M>1</span><span class=T>E</span><span class=M>11</span><span class=E>))<br><br></span><span class=K>local function</span><span class=C> randomizeTable</span><span class=E>(</span><span class=C> t</span><span class=E> )<br></span><span class=A>    -- randomize the item orders of the table t<br>    </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=E> #</span><span class=C>t</span><span class=O>,</span><span class=M> 2</span><span class=O>,</span><span class=E> -</span><span class=M>1</span><span class=N> do<br></span><span class=A>        </span><span class=G>local</span><span class=C> j</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>random</span><span class=E>(</span><span class=C>i</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> i</span><span class=E> ~=</span><span class=C> j</span><span class=N> then<br></span><span class=A>            </span><span class=C>t</span><span class=E>[</span><span class=C>i</span><span class=E>]</span><span class=O>,</span><span class=C> t</span><span class=E>[</span><span class=C>j</span><span class=E>]</span><span class=D> =</span><span class=C> t</span><span class=E>[</span><span class=C>j</span><span class=E>]</span><span class=O>,</span><span class=C> t</span><span class=E>[</span><span class=C>i</span><span class=E>]<br></span><span class=N>        end<br>    end<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>randomizeTable</span><span class=D> =</span><span class=C> randomizeTable<br><br></span><span class=K>local function</span><span class=C> strsplit</span><span class=E>(</span><span class=C>delimiter</span><span class=O>,</span><span class=C> text</span><span class=E>)<br></span><span class=A>-- Split text into a list consisting of the strings in text, separated<br>-- by strings matching delimiter (which may _NOT_ be a pattern).<br>-- Example: strsplit(&#34;, &#34;, &#34;Anna, Bob, Charlie, Dolores&#34;)<br>    </span><span class=N>if</span><span class=C> delimiter</span><span class=E> ==</span><span class=B> &#34;&#34;</span><span class=J> or</span><span class=C> delimiter</span><span class=E> ==</span><span class=L> nil</span><span class=N> then</span><span class=A> -- this would result in endless loops<br>        </span><span class=C>error</span><span class=E>(</span><span class=B>&#34;</span><span class=F>delimiter is nil or empty string!</span><span class=B>&#34;</span><span class=E>)<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> text</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>nil<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> list</span><span class=O>,</span><span class=C> pos</span><span class=O>,</span><span class=C> first</span><span class=O>,</span><span class=C> last</span><span class=D> =</span><span class=E> {}</span><span class=O>,</span><span class=M> 1<br></span><span class=A>    </span><span class=N>while</span><span class=L> true</span><span class=N> do<br></span><span class=A>        </span><span class=C>first</span><span class=O>,</span><span class=C> last</span><span class=D> =</span><span class=C> text</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=C>delimiter</span><span class=O>,</span><span class=C> pos</span><span class=O>,</span><span class=L> true</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> first</span><span class=N> then</span><span class=A> -- found?<br>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>list</span><span class=O>,</span><span class=C> text</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=C>pos</span><span class=O>,</span><span class=C> first</span><span class=E> -</span><span class=M> 1</span><span class=E>))<br></span><span class=A>            </span><span class=C>pos</span><span class=D> =</span><span class=C> last</span><span class=E> +</span><span class=M> 1<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>list</span><span class=O>,</span><span class=C> text</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=C>pos</span><span class=E>))<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>list<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>strsplit</span><span class=D> =</span><span class=C> strsplit<br><br></span><span class=K>local function</span><span class=C> hasNewLine</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>    -- return true if s has a newline<br>    </span><span class=K>return</span><span class=A> </span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>) ~=</span><span class=L> nil</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>hasNewLine</span><span class=D> =</span><span class=C> hasNewLine<br><br></span><span class=K>local function</span><span class=C> prefixString</span><span class=E>(</span><span class=C> prefix</span><span class=O>,</span><span class=C> s</span><span class=E> )<br></span><span class=A>    -- Prefix all the lines of s with prefix<br>    </span><span class=K>return</span><span class=A> </span><span class=C>prefix</span><span class=E> ..</span><span class=C> string</span><span class=H>.</span><span class=C>gsub</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> prefix</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>prefixString</span><span class=D> =</span><span class=C> prefixString<br><br></span><span class=K>local function</span><span class=C> strMatch</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> pattern</span><span class=O>,</span><span class=C> start</span><span class=O>,</span><span class=C> final</span><span class=E> )<br></span><span class=A>    -- return true if s matches completely the pattern from index start to index end<br>    -- return false in every other cases<br>    -- if start is nil, matches from the beginning of the string<br>    -- if final is nil, matches to the end of the string<br>    </span><span class=C>start</span><span class=D> =</span><span class=C> start</span><span class=J> or</span><span class=M> 1<br></span><span class=A>    </span><span class=C>final</span><span class=D> =</span><span class=C> final</span><span class=J> or</span><span class=C> string</span><span class=H>.</span><span class=C>len</span><span class=E>(</span><span class=C>s</span><span class=E>)<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> foundStart</span><span class=O>,</span><span class=C> foundEnd</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> pattern</span><span class=O>,</span><span class=C> start</span><span class=O>,</span><span class=L> false</span><span class=E>)<br></span><span class=K>    return</span><span class=A> </span><span class=C>foundStart</span><span class=E> ==</span><span class=C> start</span><span class=I> and</span><span class=C> foundEnd</span><span class=E> ==</span><span class=C> final<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>strMatch</span><span class=D> =</span><span class=C> strMatch<br><br></span><span class=K>local function</span><span class=C> patternFilter</span><span class=E>(</span><span class=C>patterns</span><span class=O>,</span><span class=C> expr</span><span class=E>)<br></span><span class=A>    -- Run `expr` through the inclusion and exclusion rules defined in patterns<br>    -- and return true if expr shall be included, false for excluded.<br>    -- Inclusion pattern are defined as normal patterns, exclusions <br>    -- patterns start with `!` and are followed by a normal pattern<br><br>    -- result: nil = UNKNOWN (not matched yet), true = ACCEPT, false = REJECT<br>    -- default: true if no explicit &#34;include&#34; is found, set to false otherwise<br>    </span><span class=G>local</span><span class=C> default</span><span class=O>,</span><span class=C> result</span><span class=D> =</span><span class=L> true</span><span class=O>,</span><span class=L> nil<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> patterns</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=N>for</span><span class=C> _</span><span class=O>,</span><span class=C> pattern</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>patterns</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=G>local</span><span class=C> exclude</span><span class=D> =</span><span class=C> pattern</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>1</span><span class=O>,</span><span class=M>1</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>!</span><span class=B>&#39;<br></span><span class=A>            </span><span class=N>if</span><span class=C> exclude</span><span class=N> then<br></span><span class=A>                </span><span class=C>pattern</span><span class=D> =</span><span class=C> pattern</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>2</span><span class=E>)<br></span><span class=N>            else<br></span><span class=A>                -- at least one include pattern specified, a match is required<br>                </span><span class=C>default</span><span class=D> =</span><span class=L> false<br></span><span class=N>            end<br></span><span class=A>            -- print(&#39;pattern: &#39;,pattern)<br>            -- print(&#39;exclude: &#39;,exclude)<br>            -- print(&#39;default: &#39;,default)<br><br>            </span><span class=N>if</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>expr</span><span class=O>,</span><span class=C> pattern</span><span class=E>)</span><span class=N> then<br></span><span class=A>                -- set result to false when excluding, true otherwise<br>                </span><span class=C>result</span><span class=D> =</span><span class=E> not</span><span class=C> exclude<br></span><span class=N>            end<br>        end<br>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> result</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>result<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>    return</span><span class=A> </span><span class=C>default<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>patternFilter</span><span class=D> =</span><span class=C> patternFilter<br><br></span><span class=K>local function</span><span class=C> xmlEscape</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>    -- Return s escaped for XML attributes<br>    -- escapes table:<br>    -- &#34;   &amp;quot;<br>    -- &#39;   &amp;apos;<br>    -- &lt;   &amp;lt;<br>    -- &gt;   &amp;gt;<br>    -- &amp;   &amp;amp;<br><br>    </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>gsub</span><span class=E>(</span><span class=A> </span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>.</span><span class=B>&#39;</span><span class=O>,</span><span class=E> {<br></span><span class=O>        [</span><span class=B>&#39;</span><span class=F>&amp;</span><span class=B>&#39;</span><span class=O>]</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&amp;amp;</span><span class=B>&#34;</span><span class=O>,<br>        [</span><span class=B>&#39;</span><span class=F>&#34;</span><span class=B>&#39;</span><span class=O>]</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&amp;quot;</span><span class=B>&#34;</span><span class=O>,<br>        [</span><span class=B>&#34;</span><span class=F>&#39;</span><span class=B>&#34;</span><span class=O>]</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&amp;apos;</span><span class=B>&#34;</span><span class=O>,<br>        [</span><span class=B>&#39;</span><span class=F>&lt;</span><span class=B>&#39;</span><span class=O>]</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&amp;lt;</span><span class=B>&#34;</span><span class=O>,<br>        [</span><span class=B>&#39;</span><span class=F>&gt;</span><span class=B>&#39;</span><span class=O>]</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&amp;gt;</span><span class=B>&#34;</span><span class=O>,<br></span><span class=E>    } )<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>xmlEscape</span><span class=D> =</span><span class=C> xmlEscape<br><br></span><span class=K>local function</span><span class=C> xmlCDataEscape</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>    -- Return s escaped for CData section, escapes: &#34;]]&gt;&#34;<br>    </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>gsub</span><span class=E>(</span><span class=A> </span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>]]&gt;</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;</span><span class=F>]]&amp;gt;</span><span class=B>&#39;</span><span class=E> )<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>xmlCDataEscape</span><span class=D> =</span><span class=C> xmlCDataEscape<br><br><br></span><span class=K>local function</span><span class=C> lstrip</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>    --[[Return s with all leading white spaces and tabs removed]]<br>    </span><span class=G>local</span><span class=C> idx</span><span class=D> =</span><span class=M> 0<br></span><span class=A>    </span><span class=N>while</span><span class=C> idx</span><span class=E> &lt;</span><span class=A> </span><span class=C>s</span><span class=H>:</span><span class=C>len</span><span class=E>()</span><span class=N> do<br></span><span class=A>        </span><span class=C>idx</span><span class=D> =</span><span class=C> idx</span><span class=E> +</span><span class=M> 1<br></span><span class=A>        </span><span class=G>local</span><span class=C> c</span><span class=D> =</span><span class=C> s</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=C>idx</span><span class=O>,</span><span class=C>idx</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> c</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F> </span><span class=B>&#39;</span><span class=I> and</span><span class=C> c</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F>\t</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>s</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=C>idx</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>lstrip</span><span class=D> =</span><span class=C> lstrip<br><br></span><span class=K>local function</span><span class=C> extractFileLineInfo</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>    --[[ From a string in the form &#34;(leading spaces) dir1/dir2\dir3\file.lua:linenb: msg&#34;<br><br>    Return the &#34;file.lua:linenb&#34; information<br>    ]]<br>    </span><span class=G>local</span><span class=C> s2</span><span class=D> =</span><span class=C> lstrip</span><span class=E>(</span><span class=C>s</span><span class=E>)<br></span><span class=A>    </span><span class=G>local</span><span class=C> firstColon</span><span class=D> =</span><span class=C> s2</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=B>&#39;</span><span class=F>:</span><span class=B>&#39;</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> firstColon</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        -- string is not in the format file:line:<br>        </span><span class=K>return</span><span class=A> </span><span class=C>s<br></span><span class=R>    </span><span class=N>end<br></span><span class=A>    </span><span class=G>local</span><span class=C> secondColon</span><span class=D> =</span><span class=C> s2</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=B>&#39;</span><span class=F>:</span><span class=B>&#39;</span><span class=O>,</span><span class=C> firstColon</span><span class=E>+</span><span class=M>1</span><span class=O>,</span><span class=L> true</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> secondColon</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        -- string is not in the format file:line:<br>        </span><span class=K>return</span><span class=A> </span><span class=C>s<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=K>    return</span><span class=A> </span><span class=C>s2</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>1</span><span class=O>,</span><span class=C> secondColon</span><span class=E>-</span><span class=M>1</span><span class=E>)</span><span class=R> <br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>extractFileLineInfo</span><span class=D> =</span><span class=C> extractFileLineInfo<br><br><br></span><span class=K>local function</span><span class=C> stripLuaunitTrace2</span><span class=E>(</span><span class=C> stackTrace</span><span class=O>,</span><span class=C> errMsg</span><span class=E> )<br></span><span class=A>    --[[<br>    -- Example of  a traceback:<br>    &lt;&lt;stack traceback:<br>        example_with_luaunit.lua:130: in function &#39;test2_withFailure&#39;<br>        ./luaunit.lua:1449: in function &lt;./luaunit.lua:1449&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        ./luaunit.lua:1449: in function &#39;protectedCall&#39;<br>        ./luaunit.lua:1508: in function &#39;execOneFunction&#39;<br>        ./luaunit.lua:1596: in function &#39;runSuiteByInstances&#39;<br>        ./luaunit.lua:1660: in function &#39;runSuiteByNames&#39;<br>        ./luaunit.lua:1736: in function &#39;runSuite&#39;<br>        example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;example_with_luaunit.lua:130: expected 2, got 1&gt;&gt;<br><br>        Other example:<br>    &lt;&lt;stack traceback:<br>        ./luaunit.lua:545: in function &#39;assertEquals&#39;<br>        example_with_luaunit.lua:58: in function &#39;TestToto.test7&#39;<br>        ./luaunit.lua:1517: in function &lt;./luaunit.lua:1517&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        ./luaunit.lua:1517: in function &#39;protectedCall&#39;<br>        ./luaunit.lua:1578: in function &#39;execOneFunction&#39;<br>        ./luaunit.lua:1677: in function &#39;runSuiteByInstances&#39;<br>        ./luaunit.lua:1730: in function &#39;runSuiteByNames&#39;<br>        ./luaunit.lua:1806: in function &#39;runSuite&#39;<br>        example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;example_with_luaunit.lua:58:  expected 2, got 1&gt;&gt;<br><br>    &lt;&lt;stack traceback:<br>        luaunit2/example_with_luaunit.lua:124: in function &#39;test1_withFailure&#39;<br>        luaunit2/luaunit.lua:1532: in function &lt;luaunit2/luaunit.lua:1532&gt;<br>        [C]: in function &#39;xpcall&#39;<br>        luaunit2/luaunit.lua:1532: in function &#39;protectedCall&#39;<br>        luaunit2/luaunit.lua:1591: in function &#39;execOneFunction&#39;<br>        luaunit2/luaunit.lua:1679: in function &#39;runSuiteByInstances&#39;<br>        luaunit2/luaunit.lua:1743: in function &#39;runSuiteByNames&#39;<br>        luaunit2/luaunit.lua:1819: in function &#39;runSuite&#39;<br>        luaunit2/example_with_luaunit.lua:140: in main chunk<br>        [C]: in ?&gt;&gt;<br>    error message: &lt;&lt;luaunit2/example_with_luaunit.lua:124:  expected 2, got 1&gt;&gt;<br><br><br>    -- first line is &#34;stack traceback&#34;: KEEP<br>    -- next line may be luaunit line: REMOVE<br>    -- next lines are call in the program under testOk: REMOVE<br>    -- next lines are calls from luaunit to call the program under test: KEEP<br><br>    -- Strategy:<br>    -- keep first line<br>    -- remove lines that are part of luaunit<br>    -- kepp lines until we hit a luaunit line<br><br>    The strategy for stripping is:<br>    * keep first line &#34;stack traceback:&#34;<br>    * part1:<br>        * analyse all lines of the stack from bottom to top of the stack (first line to last line)<br>        * extract the &#34;file:line:&#34; part of the line<br>        * compare it with the &#34;file:line&#34; part of the error message<br>        * if it does not match strip the line<br>        * if it matches, keep the line and move to part 2<br>    * part2:<br>        * anything NOT starting with luaunit.lua is the interesting part of the stack trace<br>        * anything starting again with luaunit.lua is part of the test launcher and should be stripped out<br>    ]]<br><br>    </span><span class=K>local function</span><span class=C> isLuaunitInternalLine</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>        -- return true if line of stack trace comes from inside luaunit<br>        </span><span class=K>return</span><span class=A> </span><span class=C>s</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=B>&#39;</span><span class=F>[/\\]luaunit%.lua:%d+: </span><span class=B>&#39;</span><span class=E>) ~=</span><span class=L> nil<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    -- print( &#39;&lt;&lt;&#39;..stackTrace..&#39;&gt;&gt;&#39; )<br><br>    </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=C> strsplit</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=O>,</span><span class=C> stackTrace</span><span class=E> )<br></span><span class=A>    -- print( prettystr(t) )<br><br>    </span><span class=G>local</span><span class=C> idx</span><span class=D> =</span><span class=M> 2<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> errMsgFileLine</span><span class=D> =</span><span class=C> extractFileLineInfo</span><span class=E>(</span><span class=C>errMsg</span><span class=E>)<br></span><span class=A>    -- print(&#39;emfi=&#34;&#39;..errMsgFileLine..&#39;&#34;&#39;)<br><br>    -- remove lines that are still part of luaunit<br>    </span><span class=N>while</span><span class=C> t</span><span class=E>[</span><span class=C>idx</span><span class=E>]</span><span class=I> and</span><span class=C> extractFileLineInfo</span><span class=E>(</span><span class=C>t</span><span class=E>[</span><span class=C>idx</span><span class=E>]) ~=</span><span class=C> errMsgFileLine</span><span class=N> do<br></span><span class=A>        -- print(&#39;Removing : &#39;..t[idx] )<br>        </span><span class=C>table</span><span class=H>.</span><span class=C>remove</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> idx</span><span class=E>)<br></span><span class=N>    end<br><br></span><span class=A>    -- keep lines until we hit luaunit again<br>    </span><span class=N>while</span><span class=C> t</span><span class=E>[</span><span class=C>idx</span><span class=E>]</span><span class=I> and</span><span class=E> (not</span><span class=C> isLuaunitInternalLine</span><span class=E>(</span><span class=C>t</span><span class=E>[</span><span class=C>idx</span><span class=E>]))</span><span class=N> do<br></span><span class=A>        -- print(&#39;Keeping : &#39;..t[idx] )<br>        </span><span class=C>idx</span><span class=D> =</span><span class=C> idx</span><span class=E> +</span><span class=M> 1<br></span><span class=N>    end<br><br></span><span class=A>    -- remove remaining luaunit lines<br>    </span><span class=N>while</span><span class=C> t</span><span class=E>[</span><span class=C>idx</span><span class=E>]</span><span class=N> do<br></span><span class=A>        -- print(&#39;Removing2 : &#39;..t[idx] )<br>        </span><span class=C>table</span><span class=H>.</span><span class=C>remove</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> idx</span><span class=E>)<br></span><span class=N>    end<br><br></span><span class=C565662>    -- print( prettystr(t) )<br></span><span class=K>    return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br><br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>stripLuaunitTrace2</span><span class=D> =</span><span class=C> stripLuaunitTrace2<br><br><br></span><span class=K>local function</span><span class=C> prettystr_sub</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=C> indentLevel</span><span class=O>,</span><span class=C> printTableRefs</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E> )<br></span><span class=A>    </span><span class=G>local</span><span class=C> type_v</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>v</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=E> ==</span><span class=C> type_v</span><span class=N>  then<br></span><span class=A>        -- use clever delimiters according to content:<br>        -- enclose with single quotes if string contains &#34;, but no &#39;<br>        </span><span class=N>if</span><span class=C> v</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&#34;</span><span class=B>&#39;</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)</span><span class=I> and</span><span class=E> not</span><span class=C> v</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=B>&#34;</span><span class=F>&#39;</span><span class=B>&#34;</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=B>&#34;</span><span class=F>&#39;</span><span class=B>&#34;</span><span class=E> ..</span><span class=C> v</span><span class=E> ..</span><span class=B> &#34;</span><span class=F>&#39;</span><span class=B>&#34;<br></span><span class=R>        </span><span class=N>end<br></span><span class=C565662>        -- use double quotes otherwise, escape embedded &#34;<br></span><span class=K>        return</span><span class=A> </span><span class=B>&#39;</span><span class=F>&#34;</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> v</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&#34;</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\\&#34;</span><span class=B>&#39;</span><span class=E>) ..</span><span class=B> &#39;</span><span class=F>&#34;</span><span class=B>&#39;<br><br></span><span class=R>    </span><span class=N>elseif</span><span class=B> &#34;</span><span class=F>table</span><span class=B>&#34;</span><span class=E> ==</span><span class=C> type_v</span><span class=N> then<br></span><span class=A>        --if v.__class__ then<br>        --    return string.gsub( tostring(v), &#39;table&#39;, v.__class__ )<br>        --end<br>        </span><span class=K>return</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=C> indentLevel</span><span class=O>,</span><span class=C> printTableRefs</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E>)<br><br></span><span class=R>    </span><span class=N>elseif</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=E> ==</span><span class=C> type_v</span><span class=N> then<br></span><span class=A>        -- eliminate differences in formatting between various Lua versions<br>        </span><span class=N>if</span><span class=C> v</span><span class=E> ~=</span><span class=C> v</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=B>&#34;</span><span class=F>#NaN</span><span class=B>&#34;</span><span class=R> -- &#34;not a number&#34;<br>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> v</span><span class=E> ==</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=B>&#34;</span><span class=F>#Inf</span><span class=B>&#34;</span><span class=R> -- &#34;infinite&#34;<br>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> v</span><span class=E> == -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=B>&#34;</span><span class=F>-#Inf</span><span class=B>&#34;<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> _VERSION</span><span class=E> ==</span><span class=B> &#34;</span><span class=F>Lua 5.3</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>            </span><span class=G>local</span><span class=C> i</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>tointeger</span><span class=E>(</span><span class=C>v</span><span class=E>)<br></span><span class=A>            </span><span class=N>if</span><span class=C> i</span><span class=N> then<br></span><span class=A>                </span><span class=K>return</span><span class=A> </span><span class=C>tostring</span><span class=E>(</span><span class=C>i</span><span class=E>)<br></span><span class=R>            </span><span class=N>end<br>        end<br>    end<br><br></span><span class=K>    return</span><span class=A> </span><span class=C>tostring</span><span class=E>(</span><span class=C>v</span><span class=E>)<br></span><span class=K>end<br><br>local function</span><span class=C> prettystr</span><span class=E>(</span><span class=C> v</span><span class=E> )<br></span><span class=A>    --[[ Pretty string conversion, to display the full content of a variable of any type.<br><br>    * string are enclosed with &#34; by default, or with &#39; if string contains a &#34;<br>    * tables are expanded to show their full content, with indentation in case of nested tables<br>    ]]--<br>    </span><span class=G>local</span><span class=C> cycleDetectTable</span><span class=D> =</span><span class=E> {}<br></span><span class=A>    </span><span class=G>local</span><span class=C> s</span><span class=D> =</span><span class=C> prettystr_sub</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> cycleDetectTable</span><span class=H>.</span><span class=C>detected</span><span class=I> and</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=N> then<br></span><span class=A>        -- some table contain recursive references,<br>        -- so we must recompute the value by including all table references<br>        -- else the result looks like crap<br>        </span><span class=C>cycleDetectTable</span><span class=D> =</span><span class=E> {}<br></span><span class=A>        </span><span class=C>s</span><span class=D> =</span><span class=C> prettystr_sub</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>s<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>prettystr</span><span class=D> =</span><span class=C> prettystr<br><br></span><span class=K>function</span><span class=C> M.adjust_err_msg_with_iter</span><span class=E>(</span><span class=C> err_msg</span><span class=O>,</span><span class=C> iter_msg</span><span class=E> )<br></span><span class=A>    --[[ Adjust the error message err_msg: trim the FAILURE_PREFIX or SUCCESS_PREFIX information if needed, <br>    add the iteration message if any and return the result.<br><br>    err_msg:  string, error message captured with pcall<br>    iter_msg: a string describing the current iteration (&#34;iteration N&#34;) or nil<br>              if there is no iteration in this test.<br><br>    Returns: (new_err_msg, test_status)<br>        new_err_msg: string, adjusted error message, or nil in case of success<br>        test_status: M.NodeStatus.FAIL, SUCCESS or ERROR according to the information<br>                     contained in the error message.<br>    ]]<br>    </span><span class=N>if</span><span class=C> iter_msg</span><span class=N> then<br></span><span class=A>        </span><span class=C>iter_msg</span><span class=D> =</span><span class=C> iter_msg</span><span class=E>..</span><span class=B>&#39;</span><span class=F>, </span><span class=B>&#39;<br></span><span class=N>    else<br></span><span class=A>        </span><span class=C>iter_msg</span><span class=D> =</span><span class=B> &#39;&#39;<br></span><span class=N>    end<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> RE_FILE_LINE</span><span class=D> =</span><span class=B> &#39;</span><span class=F>.*:%d+: </span><span class=B>&#39;<br><br></span><span class=A>    -- error message is not necessarily a string, <br>    -- so convert the value to string with prettystr()<br>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=A> </span><span class=C>err_msg</span><span class=E> ) ~=</span><span class=B> &#39;</span><span class=F>string</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=C>err_msg</span><span class=D> =</span><span class=C> prettystr</span><span class=E>(</span><span class=A> </span><span class=C>err_msg</span><span class=E> )<br></span><span class=N>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=E> (</span><span class=C>err_msg</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>SUCCESS_PREFIX</span><span class=E> ) ==</span><span class=M> 1</span><span class=E>)</span><span class=J> or</span><span class=C> err_msg</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>(</span><span class=B>&#39;</span><span class=E>..</span><span class=C>RE_FILE_LINE</span><span class=E>..</span><span class=B>&#39;</span><span class=F>)</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> M</span><span class=H>.</span><span class=C>SUCCESS_PREFIX</span><span class=E> ..</span><span class=B> &#34;</span><span class=F>.*</span><span class=B>&#34;</span><span class=E> )</span><span class=N> then<br></span><span class=A>        -- test finished early with success()<br>        </span><span class=K>return</span><span class=A> </span><span class=L>nil</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>SUCCESS<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=E> (</span><span class=C>err_msg</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=E> ) ==</span><span class=M> 1</span><span class=E>)</span><span class=J> or</span><span class=E> (</span><span class=C>err_msg</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>(</span><span class=B>&#39;</span><span class=E>..</span><span class=C>RE_FILE_LINE</span><span class=E>..</span><span class=B>&#39;</span><span class=F>)</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=E> ..</span><span class=B> &#34;</span><span class=F>.*</span><span class=B>&#34;</span><span class=E> ) ~=</span><span class=L> nil</span><span class=E>)</span><span class=N> then<br></span><span class=A>        -- substitute prefix by iteration message<br>        </span><span class=C>err_msg</span><span class=D> =</span><span class=C> err_msg</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=B>&#39;</span><span class=F>.*</span><span class=B>&#39;</span><span class=E>..</span><span class=C>M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=O>,</span><span class=C> iter_msg</span><span class=O>,</span><span class=M> 1</span><span class=E>)<br></span><span class=C565662>        -- print(&#34;failure detected&#34;)<br></span><span class=K>        return</span><span class=A> </span><span class=C>err_msg</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>SKIP<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=E> (</span><span class=C>err_msg</span><span class=H>:</span><span class=C>find</span><span class=E>(</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>FAILURE_PREFIX</span><span class=E> ) ==</span><span class=M> 1</span><span class=E>)</span><span class=J> or</span><span class=E> (</span><span class=C>err_msg</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>(</span><span class=B>&#39;</span><span class=E>..</span><span class=C>RE_FILE_LINE</span><span class=E>..</span><span class=B>&#39;</span><span class=F>)</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> M</span><span class=H>.</span><span class=C>FAILURE_PREFIX</span><span class=E> ..</span><span class=B> &#34;</span><span class=F>.*</span><span class=B>&#34;</span><span class=E> ) ~=</span><span class=L> nil</span><span class=E>)</span><span class=N> then<br></span><span class=A>        -- substitute prefix by iteration message<br>        </span><span class=C>err_msg</span><span class=D> =</span><span class=C> err_msg</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>FAILURE_PREFIX</span><span class=O>,</span><span class=C> iter_msg</span><span class=O>,</span><span class=M> 1</span><span class=E>)<br></span><span class=C565662>        -- print(&#34;failure detected&#34;)<br></span><span class=K>        return</span><span class=A> </span><span class=C>err_msg</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>FAIL<br></span><span class=R>    </span><span class=N>end<br><br><br><br></span><span class=A>    -- print(&#34;error detected&#34;)<br>    -- regular error, not a failure<br>    </span><span class=N>if</span><span class=C> iter_msg</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> match<br></span><span class=A>        -- &#34;./test\\test_luaunit.lua:2241: some error msg<br>        </span><span class=C>match</span><span class=D> =</span><span class=C> err_msg</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>(.*:%d+: ).*</span><span class=B>&#39;</span><span class=E> )</span><span class=A> <br>        </span><span class=N>if</span><span class=C> match</span><span class=N> then<br></span><span class=A>            </span><span class=C>err_msg</span><span class=D> =</span><span class=C> err_msg</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=A> </span><span class=C>match</span><span class=O>,</span><span class=C> match</span><span class=E> ..</span><span class=C> iter_msg</span><span class=E> )<br></span><span class=N>        else<br></span><span class=A>            -- no file:line: infromation, just add the iteration info at the beginning of the line<br>            </span><span class=C>err_msg</span><span class=D> =</span><span class=C> iter_msg</span><span class=E> ..</span><span class=C> err_msg<br></span><span class=N>        end<br>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>err_msg</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>ERROR<br></span><span class=K>end<br><br>local function</span><span class=C> tryMismatchFormatting</span><span class=E>(</span><span class=C> table_a</span><span class=O>,</span><span class=C> table_b</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=O>,</span><span class=C> margin</span><span class=E> )<br></span><span class=A>    --[[<br>    Prepares a nice error message when comparing tables, performing a deeper <br>    analysis.<br><br>    Arguments:<br>    * table_a, table_b: tables to be compared<br>    * doDeepAnalysis:<br>        M.DEFAULT_DEEP_ANALYSIS: (the default if not specified) perform deep analysis only for big lists and big dictionnaries<br>        M.FORCE_DEEP_ANALYSIS  : always perform deep analysis<br>        M.DISABLE_DEEP_ANALYSIS: never perform deep analysis<br>    * margin: supplied only for almost equality<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    ]]<br><br>    -- check if table_a &amp; table_b are suitable for deep analysis<br>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>table_a</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=J> or</span><span class=C> type</span><span class=E>(</span><span class=C>table_b</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> doDeepAnalysis</span><span class=E> ==</span><span class=C> M</span><span class=H>.</span><span class=C>DISABLE_DEEP_ANALYSIS</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> len_a</span><span class=O>,</span><span class=C> len_b</span><span class=O>,</span><span class=C> isPureList</span><span class=D> =</span><span class=E> #</span><span class=C>table_a</span><span class=O>,</span><span class=E> #</span><span class=C>table_b</span><span class=O>,</span><span class=L> true<br><br></span><span class=A>    </span><span class=N>for</span><span class=C> k1</span><span class=O>,</span><span class=C> v1</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>table_a</span><span class=E>)</span><span class=N> do<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>k1</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> k1</span><span class=E> &gt;</span><span class=A> </span><span class=C>len_a</span><span class=N> then<br></span><span class=A>            -- this table a mapping<br>            </span><span class=C>isPureList</span><span class=D> =</span><span class=L> false<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> isPureList</span><span class=N> then<br></span><span class=A>        </span><span class=N>for</span><span class=C> k2</span><span class=O>,</span><span class=C> v2</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>table_b</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>k2</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> k2</span><span class=E> &gt;</span><span class=A> </span><span class=C>len_b</span><span class=N> then<br></span><span class=A>                -- this table a mapping<br>                </span><span class=C>isPureList</span><span class=D> =</span><span class=L> false<br></span><span class=A>                </span><span class=N>break<br>            end<br>        end<br>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> isPureList</span><span class=I> and</span><span class=C> math</span><span class=H>.</span><span class=C>min</span><span class=E>(</span><span class=C>len_a</span><span class=O>,</span><span class=C> len_b</span><span class=E>) &lt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>LIST_DIFF_ANALYSIS_THRESHOLD</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not (</span><span class=C>doDeepAnalysis</span><span class=E> ==</span><span class=C> M</span><span class=H>.</span><span class=C>FORCE_DEEP_ANALYSIS</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>        </span><span class=N>end<br>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> isPureList</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>mismatchFormattingPureList</span><span class=E>(</span><span class=A> </span><span class=C>table_a</span><span class=O>,</span><span class=C> table_b</span><span class=O>,</span><span class=C> margin</span><span class=E> )<br></span><span class=R>    </span><span class=N>else<br></span><span class=A>        -- only work on mapping for the moment<br>        -- return M.private.mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )<br>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>tryMismatchFormatting</span><span class=D> =</span><span class=C> tryMismatchFormatting<br><br></span><span class=K>local function</span><span class=C> getTaTbDescr</span><span class=E>()<br></span><span class=A>    </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=B>&#39;</span><span class=F>expected</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;</span><span class=F>actual</span><span class=B>&#39;<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>    return</span><span class=A> </span><span class=B>&#39;</span><span class=F>actual</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected</span><span class=B>&#39;<br></span><span class=K>end<br><br>local function</span><span class=C> extendWithStrFmt</span><span class=E>(</span><span class=C> res</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>res</span><span class=O>,</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=A> </span><span class=O>...</span><span class=E> ) )<br></span><span class=K>end<br><br>local function</span><span class=C> mismatchFormattingMapping</span><span class=E>(</span><span class=C> table_a</span><span class=O>,</span><span class=C> table_b</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=E> )<br></span><span class=A>    --[[<br>    Prepares a nice error message when comparing tables which are not pure lists, performing a deeper <br>    analysis.<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    ]]<br><br>    -- disable for the moment<br>    --[[<br>    local result = {}<br>    local descrTa, descrTb = getTaTbDescr()<br><br>    local keysCommon = {}<br>    local keysOnlyTa = {}<br>    local keysOnlyTb = {}<br>    local keysDiffTaTb = {}<br><br>    local k, v<br><br>    for k,v in pairs( table_a ) do<br>        if is_equal( v, table_b[k] ) then<br>            table.insert( keysCommon, k )<br>        else <br>            if table_b[k] == nil then<br>                table.insert( keysOnlyTa, k )<br>            else<br>                table.insert( keysDiffTaTb, k )<br>            end<br>        end<br>    end<br><br>    for k,v in pairs( table_b ) do<br>        if not is_equal( v, table_a[k] ) and table_a[k] == nil then<br>            table.insert( keysOnlyTb, k )<br>        end<br>    end<br><br>    local len_a = #keysCommon + #keysDiffTaTb + #keysOnlyTa<br>    local len_b = #keysCommon + #keysDiffTaTb + #keysOnlyTb<br>    local limited_display = (len_a &lt; 5 or len_b &lt; 5)<br><br>    if math.min(len_a, len_b) &lt; M.TABLE_DIFF_ANALYSIS_THRESHOLD then<br>        return false<br>    end<br><br>    if not limited_display then<br>        if len_a == len_b then<br>            extendWithStrFmt( result, &#39;Table A (%s) and B (%s) both have %d items&#39;, descrTa, descrTb, len_a )<br>        else<br>            extendWithStrFmt( result, &#39;Table A (%s) has %d items and table B (%s) has %d items&#39;, descrTa, len_a, descrTb, len_b )<br>            end<br><br>        if #keysCommon == 0 and #keysDiffTaTb == 0 then<br>            table.insert( result, &#39;Table A and B have no keys in common, they are totally different&#39;)<br>        else<br>            local s_other = &#39;other &#39;<br>            if #keysCommon then<br>                extendWithStrFmt( result, &#39;Table A and B have %d identical items&#39;, #keysCommon )<br>            else<br>                table.insert( result, &#39;Table A and B have no identical items&#39; )<br>                s_other = &#39;&#39;<br>            end<br><br>            if #keysDiffTaTb ~= 0 then<br>                result[#result] = string.format( &#39;%s and %d items differing present in both tables&#39;, result[#result], #keysDiffTaTb)<br>            else<br>                result[#result] = string.format( &#39;%s and no %sitems differing present in both tables&#39;, result[#result], s_other, #keysDiffTaTb)<br>            end<br>        end<br><br>        extendWithStrFmt( result, &#39;Table A has %d keys not present in table B and table B has %d keys not present in table A&#39;, #keysOnlyTa, #keysOnlyTb ) <br>    end<br><br>    local function keytostring(k)<br>        if &#34;string&#34; == type(k) and k:match(&#34;^[_%a][_%w]*$&#34;) then<br>            return k<br>        end<br>        return prettystr(k)<br>    end<br><br>    if #keysDiffTaTb ~= 0 then<br>        table.insert( result, &#39;Items differing in A and B:&#39;)<br>        for k,v in sortedPairs( keysDiffTaTb ) do<br>            extendWithStrFmt( result, &#39;  - A[%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>            extendWithStrFmt( result, &#39;  + B[%s]: %s&#39;, keytostring(v), prettystr(table_b[v]) )<br>        end<br>    end    <br><br>    if #keysOnlyTa ~= 0 then<br>        table.insert( result, &#39;Items only in table A:&#39; )<br>        for k,v in sortedPairs( keysOnlyTa ) do<br>            extendWithStrFmt( result, &#39;  - A[%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>        end<br>    end<br><br>    if #keysOnlyTb ~= 0 then<br>        table.insert( result, &#39;Items only in table B:&#39; )<br>        for k,v in sortedPairs( keysOnlyTb ) do<br>            extendWithStrFmt( result, &#39;  + B[%s]: %s&#39;, keytostring(v), prettystr(table_b[v]) )<br>        end<br>    end<br><br>    if #keysCommon ~= 0 then<br>        table.insert( result, &#39;Items common to A and B:&#39;)<br>        for k,v in sortedPairs( keysCommon ) do<br>            extendWithStrFmt( result, &#39;  = A and B [%s]: %s&#39;, keytostring(v), prettystr(table_a[v]) )<br>        end<br>    end    <br><br>    return true, table.concat( result, &#39;\n&#39;)<br>    ]]<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>mismatchFormattingMapping</span><span class=D> =</span><span class=C> mismatchFormattingMapping<br><br></span><span class=K>local function</span><span class=C> mismatchFormattingPureList</span><span class=E>(</span><span class=C> table_a</span><span class=O>,</span><span class=C> table_b</span><span class=O>,</span><span class=C> margin</span><span class=E> )<br></span><span class=A>    --[[<br>    Prepares a nice error message when comparing tables which are lists, performing a deeper <br>    analysis.<br><br>    margin is supplied only for almost equality<br><br>    Returns: {success, result}<br>    * success: false if deep analysis could not be performed <br>               in this case, just use standard assertion message<br>    * result: if success is true, a multi-line string with deep analysis of the two lists<br>    ]]<br>    </span><span class=G>local</span><span class=C> result</span><span class=O>,</span><span class=C> descrTa</span><span class=O>,</span><span class=C> descrTb</span><span class=D> =</span><span class=E> {}</span><span class=O>,</span><span class=C> getTaTbDescr</span><span class=E>()<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> len_a</span><span class=O>,</span><span class=C> len_b</span><span class=O>,</span><span class=C> refa</span><span class=O>,</span><span class=C> refb</span><span class=D> =</span><span class=E> #</span><span class=C>table_a</span><span class=O>,</span><span class=E> #</span><span class=C>table_b</span><span class=O>,</span><span class=B> &#39;&#39;</span><span class=O>,</span><span class=B> &#39;&#39;<br></span><span class=A>    </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=N> then<br></span><span class=A>        </span><span class=C>refa</span><span class=O>,</span><span class=C> refb</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>&lt;%s&gt; </span><span class=B>&#39;</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>table_ref</span><span class=E>(</span><span class=C>table_a</span><span class=E>))</span><span class=O>,</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&lt;%s&gt; </span><span class=B>&#39;</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>table_ref</span><span class=E>(</span><span class=C>table_b</span><span class=E>) )<br></span><span class=N>    end<br></span><span class=A>    </span><span class=G>local</span><span class=C> longest</span><span class=O>,</span><span class=C> shortest</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>max</span><span class=E>(</span><span class=C>len_a</span><span class=O>,</span><span class=C> len_b</span><span class=E>)</span><span class=O>,</span><span class=C> math</span><span class=H>.</span><span class=C>min</span><span class=E>(</span><span class=C>len_a</span><span class=O>,</span><span class=C> len_b</span><span class=E>)<br></span><span class=A>    </span><span class=G>local</span><span class=C> deltalv</span><span class=D>  =</span><span class=C> longest</span><span class=E> -</span><span class=C> shortest<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> commonUntil</span><span class=D> =</span><span class=C> shortest<br></span><span class=A>    </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=M> 1</span><span class=O>,</span><span class=C> shortest</span><span class=N> do<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>is_table_equals</span><span class=E>(</span><span class=C>table_a</span><span class=E>[</span><span class=C>i</span><span class=E>]</span><span class=O>,</span><span class=C> table_b</span><span class=E>[</span><span class=C>i</span><span class=E>]</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=C>commonUntil</span><span class=D> =</span><span class=C> i</span><span class=E> -</span><span class=M> 1<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> commonBackTo</span><span class=D> =</span><span class=C> shortest</span><span class=E> -</span><span class=M> 1<br></span><span class=A>    </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=M> 0</span><span class=O>,</span><span class=C> shortest</span><span class=E> -</span><span class=M> 1</span><span class=N> do<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>is_table_equals</span><span class=E>(</span><span class=C>table_a</span><span class=E>[</span><span class=C>len_a</span><span class=E>-</span><span class=C>i</span><span class=E>]</span><span class=O>,</span><span class=C> table_b</span><span class=E>[</span><span class=C>len_b</span><span class=E>-</span><span class=C>i</span><span class=E>]</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=C>commonBackTo</span><span class=D> =</span><span class=C> i</span><span class=E> -</span><span class=M> 1<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br><br><br></span><span class=A>    </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>List difference analysis:</span><span class=B>&#39;</span><span class=E> )</span><span class=A>    <br>    </span><span class=N>if</span><span class=C> len_a</span><span class=E> ==</span><span class=C> len_b</span><span class=N> then<br></span><span class=A>        -- TODO: handle expected/actual naming<br>        </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* lists %sA (%s) and %sB (%s) have the same size</span><span class=B>&#39;</span><span class=O>,</span><span class=C> refa</span><span class=O>,</span><span class=C> descrTa</span><span class=O>,</span><span class=C> refb</span><span class=O>,</span><span class=C> descrTb</span><span class=E> )<br></span><span class=N>    else</span><span class=A> <br>        </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* list sizes differ: list %sA (%s) has %d items, list %sB (%s) has %d items</span><span class=B>&#39;</span><span class=O>,</span><span class=C> refa</span><span class=O>,</span><span class=C> descrTa</span><span class=O>,</span><span class=C> len_a</span><span class=O>,</span><span class=C> refb</span><span class=O>,</span><span class=C> descrTb</span><span class=O>,</span><span class=C> len_b</span><span class=E> )<br></span><span class=N>    end<br><br></span><span class=A>    </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* lists A and B start differing at index %d</span><span class=B>&#39;</span><span class=O>,</span><span class=C> commonUntil</span><span class=E>+</span><span class=M>1</span><span class=E> )</span><span class=A> <br>    </span><span class=N>if</span><span class=C> commonBackTo</span><span class=E> &gt;=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=C> deltalv</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>            </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* lists A and B are equal again from index %d for A, %d for B</span><span class=B>&#39;</span><span class=O>,</span><span class=C> len_a</span><span class=E>-</span><span class=C>commonBackTo</span><span class=O>,</span><span class=C> len_b</span><span class=E>-</span><span class=C>commonBackTo</span><span class=E> )<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* lists A and B are equal again from index %d</span><span class=B>&#39;</span><span class=O>,</span><span class=C> len_a</span><span class=E>-</span><span class=C>commonBackTo</span><span class=E> )<br></span><span class=N>        end<br>    end<br><br></span><span class=A>    </span><span class=K>local function</span><span class=C> insertABValue</span><span class=E>(</span><span class=C>ai</span><span class=O>,</span><span class=C> bi</span><span class=E>)<br></span><span class=A>        </span><span class=C>bi</span><span class=D> =</span><span class=C> bi</span><span class=J> or</span><span class=C> ai<br></span><span class=A>        </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>is_table_equals</span><span class=E>(</span><span class=A> </span><span class=C>table_a</span><span class=E>[</span><span class=C>ai</span><span class=E>]</span><span class=O>,</span><span class=C> table_b</span><span class=E>[</span><span class=C>bi</span><span class=E>]</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>  = A[%d], B[%d]: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> ai</span><span class=O>,</span><span class=C> bi</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>table_a</span><span class=E>[</span><span class=C>ai</span><span class=E>]) )<br></span><span class=R>        </span><span class=N>else<br></span><span class=A>            </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>  - A[%d]: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> ai</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>table_a</span><span class=E>[</span><span class=C>ai</span><span class=E>]))<br></span><span class=A>            </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>  + B[%d]: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> bi</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>table_b</span><span class=E>[</span><span class=C>bi</span><span class=E>]))<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    -- common parts to list A &amp; B, at the beginning<br>    </span><span class=N>if</span><span class=C> commonUntil</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* Common parts:</span><span class=B>&#39;</span><span class=E> )<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=M> 1</span><span class=O>,</span><span class=C> commonUntil</span><span class=N> do<br></span><span class=A>            </span><span class=C>insertABValue</span><span class=E>(</span><span class=A> </span><span class=C>i</span><span class=E> )<br></span><span class=N>        end<br>    end<br><br></span><span class=A>    -- diffing parts to list A &amp; B<br>    </span><span class=N>if</span><span class=C> commonUntil</span><span class=E> &lt;</span><span class=A> </span><span class=C>shortest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=E> -</span><span class=M> 1</span><span class=N> then<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* Differing parts:</span><span class=B>&#39;</span><span class=E> )<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=C> commonUntil</span><span class=E> +</span><span class=M> 1</span><span class=O>,</span><span class=C> shortest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=E> -</span><span class=M> 1</span><span class=N> do<br></span><span class=A>            </span><span class=C>insertABValue</span><span class=E>(</span><span class=A> </span><span class=C>i</span><span class=E> )<br></span><span class=N>        end<br>    end<br><br></span><span class=A>    -- display indexes of one list, with no match on other list<br>    </span><span class=N>if</span><span class=C> shortest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=E> &lt;=</span><span class=C> longest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=E> -</span><span class=M> 1</span><span class=N> then<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* Present only in one list:</span><span class=B>&#39;</span><span class=E> )<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=C> shortest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=O>,</span><span class=C> longest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=E> -</span><span class=M> 1</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> len_a</span><span class=E> &gt;</span><span class=A> </span><span class=C>len_b</span><span class=N> then<br></span><span class=A>                </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>  - A[%d]: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> i</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>table_a</span><span class=E>[</span><span class=C>i</span><span class=E>]) )<br></span><span class=C565662>                -- table.insert( result, &#39;+ (no matching B index)&#39;)<br></span><span class=N>            else<br></span><span class=A>                -- table.insert( result, &#39;- no matching A index&#39;)<br>                </span><span class=C>extendWithStrFmt</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>  + B[%d]: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> i</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>table_b</span><span class=E>[</span><span class=C>i</span><span class=E>]) )<br></span><span class=N>            end<br>        end<br>    end<br><br></span><span class=A>    -- common parts to list A &amp; B, at the end<br>    </span><span class=N>if</span><span class=C> commonBackTo</span><span class=E> &gt;=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>* Common parts at the end of the lists</span><span class=B>&#39;</span><span class=E> )<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=D> =</span><span class=C> longest</span><span class=E> -</span><span class=C> commonBackTo</span><span class=O>,</span><span class=C> longest</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> len_a</span><span class=E> &gt;</span><span class=A> </span><span class=C>len_b</span><span class=N> then<br></span><span class=A>                </span><span class=C>insertABValue</span><span class=E>(</span><span class=A> </span><span class=C>i</span><span class=O>,</span><span class=C> i</span><span class=E>-</span><span class=C>deltalv</span><span class=E> )<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>insertABValue</span><span class=E>(</span><span class=A> </span><span class=C>i</span><span class=E>-</span><span class=C>deltalv</span><span class=O>,</span><span class=C> i</span><span class=E> )<br></span><span class=N>            end<br>        end<br>    end<br><br></span><span class=K>    return</span><span class=A> </span><span class=L>true</span><span class=O>,</span><span class=C> table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>mismatchFormattingPureList</span><span class=D> =</span><span class=C> mismatchFormattingPureList<br><br></span><span class=K>local function</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>value1</span><span class=O>,</span><span class=C> value2</span><span class=O>,</span><span class=C> suffix_a</span><span class=O>,</span><span class=C> suffix_b</span><span class=E>)<br></span><span class=A>    --[[<br>    This function helps with the recurring task of constructing the &#34;expected<br>    vs. actual&#34; error messages. It takes two arbitrary values and formats<br>    corresponding strings with prettystr().<br><br>    To keep the (possibly complex) output more readable in case the resulting<br>    strings contain line breaks, they get automatically prefixed with additional<br>    newlines. Both suffixes are optional (default to empty strings), and get<br>    appended to the &#34;value1&#34; string. &#34;suffix_a&#34; is used if line breaks were<br>    encountered, &#34;suffix_b&#34; otherwise.<br><br>    Returns the two formatted strings (including padding/newlines).<br>    ]]<br>    </span><span class=G>local</span><span class=C> str1</span><span class=O>,</span><span class=C> str2</span><span class=D> =</span><span class=C> prettystr</span><span class=E>(</span><span class=C>value1</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>value2</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> hasNewLine</span><span class=E>(</span><span class=C>str1</span><span class=E>)</span><span class=J> or</span><span class=C> hasNewLine</span><span class=E>(</span><span class=C>str2</span><span class=E>)</span><span class=N> then<br></span><span class=A>        -- line break(s) detected, add padding<br>        </span><span class=K>return</span><span class=A> </span><span class=B>&#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=E> ..</span><span class=C> str1</span><span class=E> .. (</span><span class=C>suffix_a</span><span class=J> or</span><span class=B> &#34;&#34;</span><span class=E>)</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=E> ..</span><span class=C> str2<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>    return</span><span class=A> </span><span class=C>str1</span><span class=E> .. (</span><span class=C>suffix_b</span><span class=J> or</span><span class=B> &#34;&#34;</span><span class=E>)</span><span class=O>,</span><span class=C> str2<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>prettystrPairs</span><span class=D> =</span><span class=C> prettystrPairs<br><br></span><span class=G>local</span><span class=C> UNKNOWN_REF</span><span class=D> =</span><span class=B> &#39;</span><span class=F>table 00-unknown ref</span><span class=B>&#39;<br></span><span class=G>local</span><span class=C> ref_generator</span><span class=D> =</span><span class=E> {</span><span class=P> value</span><span class=D>=</span><span class=M>1</span><span class=O>, [</span><span class=C>UNKNOWN_REF</span><span class=O>]</span><span class=D>=</span><span class=M>0</span><span class=E> }<br><br></span><span class=K>local function</span><span class=C> table_ref</span><span class=E>(</span><span class=C> t</span><span class=E> )<br></span><span class=A>    -- return the default tostring() for tables, with the table ID, even if the table has a metatable<br>    -- with the __tostring converter<br>    </span><span class=G>local</span><span class=C> ref</span><span class=D> =</span><span class=B> &#39;&#39;<br></span><span class=A>    </span><span class=G>local</span><span class=C> mt</span><span class=D> =</span><span class=C> getmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=E> )<br></span><span class=A>    </span><span class=N>if</span><span class=C> mt</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=C>ref</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>t</span><span class=E>)<br></span><span class=N>    else<br></span><span class=A>        </span><span class=G>local</span><span class=C> success</span><span class=O>,</span><span class=C> result<br></span><span class=A>        </span><span class=C>success</span><span class=O>,</span><span class=C> result</span><span class=D> =</span><span class=C> pcall</span><span class=E>(</span><span class=C>setmetatable</span><span class=O>,</span><span class=C> t</span><span class=O>,</span><span class=L> nil</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> success</span><span class=N> then<br></span><span class=A>            -- protected table, if __tostring is defined, we can<br>            -- not get the reference. And we can not know in advance.<br>            </span><span class=C>ref</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>t</span><span class=E>)</span><span class=A> <br>            </span><span class=N>if</span><span class=E> not</span><span class=C> ref</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>table: 0?x?[%x]+</span><span class=B>&#39;</span><span class=E> )</span><span class=N> then<br></span><span class=A>                </span><span class=K>return</span><span class=A> </span><span class=C>UNKNOWN_REF<br></span><span class=R>            </span><span class=N>end<br>        else<br></span><span class=A>            </span><span class=C>ref</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>t</span><span class=E>)<br></span><span class=A>            </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> mt</span><span class=E> )<br></span><span class=N>        end<br>    end<br></span><span class=A>    -- strip the &#34;table: &#34; part<br>    </span><span class=C>ref</span><span class=D> =</span><span class=C> ref</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>8</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> ref</span><span class=E> ~=</span><span class=C> UNKNOWN_REF</span><span class=I> and</span><span class=C> ref_generator</span><span class=E>[</span><span class=C>ref</span><span class=E>] ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        -- Create a new reference number<br>        </span><span class=C>ref_generator</span><span class=E>[</span><span class=C>ref</span><span class=E>]</span><span class=D> =</span><span class=C> ref_generator</span><span class=H>.</span><span class=C>value<br></span><span class=A>        </span><span class=C>ref_generator</span><span class=H>.</span><span class=C>value</span><span class=D> =</span><span class=C> ref_generator</span><span class=H>.</span><span class=C>value</span><span class=E>+</span><span class=M>1<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>table %02d-%s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> ref_generator</span><span class=E>[</span><span class=C>ref</span><span class=E>]</span><span class=O>,</span><span class=C> ref</span><span class=E>)<br></span><span class=R>    </span><span class=N>else<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>table %02d</span><span class=B>&#39;</span><span class=O>,</span><span class=C> ref_generator</span><span class=E>[</span><span class=C>ref</span><span class=E>])<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>table_ref</span><span class=D> =</span><span class=C> table_ref<br><br></span><span class=G>local</span><span class=C> TABLE_TOSTRING_SEP</span><span class=D> =</span><span class=B> &#34;</span><span class=F>, </span><span class=B>&#34;<br></span><span class=G>local</span><span class=C> TABLE_TOSTRING_SEP_LEN</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>len</span><span class=E>(</span><span class=C>TABLE_TOSTRING_SEP</span><span class=E>)<br><br></span><span class=K>local function</span><span class=C> _table_tostring</span><span class=E>(</span><span class=C> tbl</span><span class=O>,</span><span class=C> indentLevel</span><span class=O>,</span><span class=C> printTableRefs</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E> )<br></span><span class=A>    </span><span class=C>printTableRefs</span><span class=D> =</span><span class=C> printTableRefs</span><span class=J> or</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG<br></span><span class=A>    </span><span class=C>cycleDetectTable</span><span class=D> =</span><span class=C> cycleDetectTable</span><span class=J> or</span><span class=E> {}<br></span><span class=A>    </span><span class=C>cycleDetectTable</span><span class=E>[</span><span class=C>tbl</span><span class=E>]</span><span class=D> =</span><span class=L> true<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> result</span><span class=O>,</span><span class=C> dispOnMultLines</span><span class=D> =</span><span class=E> {}</span><span class=O>,</span><span class=L> false<br><br></span><span class=A>    -- like prettystr but do not enclose with &#34;&#34; if the string is just alphanumerical<br>    -- this is better for displaying table keys who are often simple strings<br>    </span><span class=K>local function</span><span class=C> keytostring</span><span class=E>(</span><span class=C>k</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=E> ==</span><span class=C> type</span><span class=E>(</span><span class=C>k</span><span class=E>)</span><span class=I> and</span><span class=C> k</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=B>&#34;</span><span class=F>^[_%a][_%w]*$</span><span class=B>&#34;</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>k<br></span><span class=R>        </span><span class=N>end<br></span><span class=K>        return</span><span class=A> </span><span class=C>prettystr_sub</span><span class=E>(</span><span class=C>k</span><span class=O>,</span><span class=C> indentLevel</span><span class=E>+</span><span class=M>1</span><span class=O>,</span><span class=C> printTableRefs</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=G>local</span><span class=C> mt</span><span class=D> =</span><span class=C> getmetatable</span><span class=E>(</span><span class=A> </span><span class=C>tbl</span><span class=E> )<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> mt</span><span class=I> and</span><span class=C> mt</span><span class=H>.</span><span class=C>__tostring</span><span class=N> then<br></span><span class=A>        -- if table has a __tostring() function in its metatable, use it to display the table<br>        -- else, compute a regular table<br>        </span><span class=C>result</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>tbl</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>result</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>string</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>&lt;invalid tostring() result: &#34;%s&#34; &gt;</span><span class=B>&#39;</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>result</span><span class=E>) )<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=C>result</span><span class=D> =</span><span class=C> strsplit</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=O>,</span><span class=C> result</span><span class=E> )<br></span><span class=K>        return</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring_format_multiline_string</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=C> indentLevel</span><span class=E> )<br><br></span><span class=R>    </span><span class=N>else<br></span><span class=A>        -- no metatable, compute the table representation<br><br>        </span><span class=G>local</span><span class=C> entry</span><span class=O>,</span><span class=C> count</span><span class=O>,</span><span class=C> seq_index</span><span class=D> =</span><span class=L> nil</span><span class=O>,</span><span class=M> 0</span><span class=O>,</span><span class=M> 1<br></span><span class=A>        </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> sortedPairs</span><span class=E>(</span><span class=A> </span><span class=C>tbl</span><span class=E> )</span><span class=N> do<br><br></span><span class=A>            -- key part<br>            </span><span class=N>if</span><span class=C> k</span><span class=E> ==</span><span class=C> seq_index</span><span class=N> then<br></span><span class=A>                -- for the sequential part of tables, we&#39;ll skip the &#34;&lt;key&gt;=&#34; output<br>                </span><span class=C>entry</span><span class=D> =</span><span class=B> &#39;&#39;<br></span><span class=A>                </span><span class=C>seq_index</span><span class=D> =</span><span class=C> seq_index</span><span class=E> +</span><span class=M> 1<br></span><span class=N>            elseif</span><span class=C> cycleDetectTable</span><span class=E>[</span><span class=C>k</span><span class=E>]</span><span class=N> then<br></span><span class=A>                -- recursion in the key detected<br>                </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>detected</span><span class=D> =</span><span class=L> true<br></span><span class=A>                </span><span class=C>entry</span><span class=D> =</span><span class=B> &#34;</span><span class=F>&lt;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>table_ref</span><span class=E>(</span><span class=C>k</span><span class=E>)..</span><span class=B>&#34;</span><span class=F>&gt;=</span><span class=B>&#34;<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>entry</span><span class=D> =</span><span class=C> keytostring</span><span class=E>(</span><span class=C>k</span><span class=E>) ..</span><span class=B> &#34;</span><span class=F>=</span><span class=B>&#34;<br></span><span class=N>            end<br><br></span><span class=A>            -- value part <br>            </span><span class=N>if</span><span class=C> cycleDetectTable</span><span class=E>[</span><span class=C>v</span><span class=E>]</span><span class=N> then<br></span><span class=A>                -- recursion in the value detected!<br>                </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>detected</span><span class=D> =</span><span class=L> true<br></span><span class=A>                </span><span class=C>entry</span><span class=D> =</span><span class=C> entry</span><span class=E> ..</span><span class=B> &#34;</span><span class=F>&lt;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>table_ref</span><span class=E>(</span><span class=C>v</span><span class=E>)..</span><span class=B>&#34;</span><span class=F>&gt;</span><span class=B>&#34;<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>entry</span><span class=D> =</span><span class=C> entry</span><span class=E> ..<br></span><span class=C>                    prettystr_sub</span><span class=E>(</span><span class=A> </span><span class=C>v</span><span class=O>,</span><span class=C> indentLevel</span><span class=E>+</span><span class=M>1</span><span class=O>,</span><span class=C> printTableRefs</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=E> )<br></span><span class=N>            end<br></span><span class=A>            </span><span class=C>count</span><span class=D> =</span><span class=C> count</span><span class=E> +</span><span class=M> 1<br></span><span class=A>            </span><span class=C>result</span><span class=E>[</span><span class=C>count</span><span class=E>]</span><span class=D> =</span><span class=C> entry<br></span><span class=N>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring_format_result</span><span class=E>(</span><span class=A> </span><span class=C>tbl</span><span class=O>,</span><span class=C> result</span><span class=O>,</span><span class=C> indentLevel</span><span class=O>,</span><span class=C> printTableRefs</span><span class=E> )<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring</span><span class=D> =</span><span class=C> _table_tostring</span><span class=A> -- prettystr_sub() needs it<br><br></span><span class=K>local function</span><span class=C> _table_tostring_format_multiline_string</span><span class=E>(</span><span class=C> tbl_str</span><span class=O>,</span><span class=C> indentLevel</span><span class=E> )<br></span><span class=A>    </span><span class=G>local</span><span class=C> indentString</span><span class=D> =</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>..</span><span class=C>string</span><span class=H>.</span><span class=C>rep</span><span class=E>(</span><span class=B>&#34;</span><span class=F>    </span><span class=B>&#34;</span><span class=O>,</span><span class=C> indentLevel</span><span class=E> -</span><span class=M> 1</span><span class=E>)<br></span><span class=K>    return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=A> </span><span class=C>tbl_str</span><span class=O>,</span><span class=C> indentString</span><span class=E> )<br><br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring_format_multiline_string</span><span class=D> =</span><span class=C> _table_tostring_format_multiline_string<br><br><br></span><span class=K>local function</span><span class=C> _table_tostring_format_result</span><span class=E>(</span><span class=C> tbl</span><span class=O>,</span><span class=C> result</span><span class=O>,</span><span class=C> indentLevel</span><span class=O>,</span><span class=C> printTableRefs</span><span class=E> )<br></span><span class=A>    -- final function called in _table_to_string() to format the resulting list of <br>    -- string describing the table.<br><br>    </span><span class=G>local</span><span class=C> dispOnMultLines</span><span class=D> =</span><span class=L> false<br><br></span><span class=A>    -- set dispOnMultLines to true if the maximum LINE_LENGTH would be exceeded with the values<br>    </span><span class=G>local</span><span class=C> totalLength</span><span class=D> =</span><span class=M> 0<br></span><span class=A>    </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=E> )</span><span class=N> do<br></span><span class=A>        </span><span class=C>totalLength</span><span class=D> =</span><span class=C> totalLength</span><span class=E> +</span><span class=C> string</span><span class=H>.</span><span class=C>len</span><span class=E>(</span><span class=A> </span><span class=C>v</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> totalLength</span><span class=E> &gt;=</span><span class=C> M</span><span class=H>.</span><span class=C>LINE_LENGTH</span><span class=N> then<br></span><span class=A>            </span><span class=C>dispOnMultLines</span><span class=D> =</span><span class=L> true<br></span><span class=A>            </span><span class=N>break<br>        end<br>    end<br><br></span><span class=A>    -- set dispOnMultLines to true if the max LINE_LENGTH would be exceeded<br>    -- with the values and the separators.<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> dispOnMultLines</span><span class=N> then<br></span><span class=A>        -- adjust with length of separator(s):<br>        -- two items need 1 sep, three items two seps, ... plus len of &#39;{}&#39;<br>        </span><span class=N>if</span><span class=E> #</span><span class=C>result</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>            </span><span class=C>totalLength</span><span class=D> =</span><span class=C> totalLength</span><span class=E> +</span><span class=C> TABLE_TOSTRING_SEP_LEN</span><span class=E> * (#</span><span class=C>result</span><span class=E> -</span><span class=M> 1</span><span class=E>)<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>dispOnMultLines</span><span class=D> =</span><span class=E> (</span><span class=C>totalLength</span><span class=E> +</span><span class=M> 2</span><span class=E> &gt;=</span><span class=C> M</span><span class=H>.</span><span class=C>LINE_LENGTH</span><span class=E>)<br></span><span class=N>    end<br><br></span><span class=A>    -- now reformat the result table (currently holding element strings)<br>    </span><span class=N>if</span><span class=C> dispOnMultLines</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> indentString</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>rep</span><span class=E>(</span><span class=B>&#34;</span><span class=F>    </span><span class=B>&#34;</span><span class=O>,</span><span class=C> indentLevel</span><span class=E> -</span><span class=M> 1</span><span class=E>)<br></span><span class=A>        </span><span class=C>result</span><span class=D> =</span><span class=E> {</span><span class=A>  <br>                    </span><span class=B>&#34;</span><span class=F>{\n    </span><span class=B>&#34;</span><span class=O>,</span><span class=A> <br>                    </span><span class=C>indentString</span><span class=O>,<br></span><span class=A>                    </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=C>result</span><span class=O>,</span><span class=B> &#34;</span><span class=F>,\n    </span><span class=B>&#34;</span><span class=E> ..</span><span class=C> indentString</span><span class=E>)</span><span class=O>,</span><span class=A> <br>                    </span><span class=B>&#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=O>,<br></span><span class=A>                    </span><span class=C>indentString</span><span class=O>,</span><span class=A> <br>                    </span><span class=B>&#34;</span><span class=F>}</span><span class=B>&#34;<br></span><span class=E>                }<br></span><span class=N>    else<br></span><span class=A>        </span><span class=C>result</span><span class=D> =</span><span class=E> {</span><span class=B>&#34;</span><span class=F>{</span><span class=B>&#34;</span><span class=O>,</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=C>result</span><span class=O>,</span><span class=C> TABLE_TOSTRING_SEP</span><span class=E>)</span><span class=O>,</span><span class=A> </span><span class=B>&#34;</span><span class=F>}</span><span class=B>&#34;</span><span class=E>}<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> printTableRefs</span><span class=N> then<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>result</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=B> &#34;</span><span class=F>&lt;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>table_ref</span><span class=E>(</span><span class=C>tbl</span><span class=E>)..</span><span class=B>&#34;</span><span class=F>&gt; </span><span class=B>&#34;</span><span class=E>)</span><span class=C565662> -- prepend table ref<br></span><span class=N>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=C>result</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_table_tostring_format_result</span><span class=D> =</span><span class=C> _table_tostring_format_result</span><span class=A> -- prettystr_sub() needs it<br><br></span><span class=K>local function</span><span class=C> table_findkeyof</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> element</span><span class=E>)<br></span><span class=A>    -- Return the key k of the given element in table t, so that t[k] == element<br>    -- (or `nil` if element is not present within t). Note that we use our<br>    -- &#39;general&#39; is_equal comparison for matching, so this function should<br>    -- handle table-type elements gracefully and consistently.<br>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>t</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>table</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>        </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>t</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>is_table_equals</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=C> element</span><span class=E>)</span><span class=N> then<br></span><span class=A>                </span><span class=K>return</span><span class=A> </span><span class=C>k<br></span><span class=R>            </span><span class=N>end<br>        end<br>    end<br></span><span class=K>    return</span><span class=A> </span><span class=L>nil<br></span><span class=K>end<br><br>local function</span><span class=C> _is_table_items_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E> )<br></span><span class=A>    </span><span class=G>local</span><span class=C> type_a</span><span class=O>,</span><span class=C> type_e</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=O>,</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>)<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> type_a</span><span class=E> ~=</span><span class=C> type_e</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br><br></span><span class=R>    </span><span class=N>elseif</span><span class=E> (</span><span class=C>type_a</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=E>)</span><span class=N> --[[and (type_e == &#39;table&#39;)]] then<br></span><span class=A>        </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> table_findkeyof</span><span class=E>(</span><span class=C>expected</span><span class=O>,</span><span class=C> v</span><span class=E>) ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=K>return</span><span class=A> </span><span class=L>false</span><span class=R> -- v not contained in expected<br>            </span><span class=N>end<br>        end<br></span><span class=A>        </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> table_findkeyof</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> v</span><span class=E>) ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=K>return</span><span class=A> </span><span class=L>false</span><span class=R> -- v not contained in actual<br>            </span><span class=N>end<br>        end<br></span><span class=K>        return</span><span class=A> </span><span class=L>true<br><br></span><span class=R>    </span><span class=N>elseif</span><span class=C> actual</span><span class=E> ~=</span><span class=C> expected</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=K>    return</span><span class=A> </span><span class=L>true<br></span><span class=K>end<br><br></span><span class=A>--[[<br>This is a specialized metatable to help with the bookkeeping of recursions<br>in _is_table_equals(). It provides an __index table that implements utility<br>functions for easier management of the table. The &#34;cached&#34; method queries<br>the state of a specific (actual,expected) pair; and the &#34;store&#34; method sets<br>this state to the given value. The state of pairs not &#34;seen&#34; / visited is<br>assumed to be `nil`.<br>]]<br></span><span class=G>local</span><span class=C> _recursion_cache_MT</span><span class=D> =</span><span class=E> {<br></span><span class=P>    __index</span><span class=D> =</span><span class=E> {<br></span><span class=C565662>        -- Return the cached value for an (actual,expected) pair (or `nil`)<br></span><span class=P>        cached</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> actual</span><span class=O>,</span><span class=C> expected</span><span class=E>)<br></span><span class=A>            </span><span class=G>local</span><span class=C> subtable</span><span class=D> =</span><span class=C> t</span><span class=E>[</span><span class=C>actual</span><span class=E>]</span><span class=J> or</span><span class=E> {}<br></span><span class=K>            return</span><span class=A> </span><span class=C>subtable</span><span class=E>[</span><span class=C>expected</span><span class=E>]<br></span><span class=R>        </span><span class=K>end</span><span class=O>,<br><br></span><span class=C565662>        -- Store cached value for a specific (actual,expected) pair.<br>        -- Returns the value, so it&#39;s easy to use for a &#34;tailcall&#34; (return ...).<br></span><span class=P>        store</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> value</span><span class=O>,</span><span class=C> asymmetric</span><span class=E>)<br></span><span class=A>            </span><span class=G>local</span><span class=C> subtable</span><span class=D> =</span><span class=C> t</span><span class=E>[</span><span class=C>actual</span><span class=E>]<br></span><span class=A>            </span><span class=N>if</span><span class=E> not</span><span class=C> subtable</span><span class=N> then<br></span><span class=A>                </span><span class=C>subtable</span><span class=D> =</span><span class=E> {}<br></span><span class=A>                </span><span class=C>t</span><span class=E>[</span><span class=C>actual</span><span class=E>]</span><span class=D> =</span><span class=C> subtable<br></span><span class=N>            end<br></span><span class=A>            </span><span class=C>subtable</span><span class=E>[</span><span class=C>expected</span><span class=E>]</span><span class=D> =</span><span class=C> value<br><br></span><span class=A>            -- Unless explicitly marked &#34;asymmetric&#34;: Consider the recursion<br>            -- on (expected,actual) to be equivalent to (actual,expected) by<br>            -- default, and thus cache the value for both.<br>            </span><span class=N>if</span><span class=E> not</span><span class=C> asymmetric</span><span class=N> then<br></span><span class=A>                </span><span class=C>t</span><span class=H>:</span><span class=C>store</span><span class=E>(</span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=O>,</span><span class=C> value</span><span class=O>,</span><span class=L> true</span><span class=E>)<br></span><span class=N>            end<br><br></span><span class=K>            return</span><span class=A> </span><span class=C>value<br></span><span class=R>        </span><span class=K>end<br></span><span class=E>    }<br>}<br><br></span><span class=K>local function</span><span class=C> _is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=O>,</span><span class=C> marginForAlmostEqual</span><span class=E>)<br></span><span class=A>    --[[Returns true if both table are equal.<br><br>    If argument marginForAlmostEqual is suppied, number comparison is done using alomstEqual instead <br>    of strict equality.<br><br>    cycleDetectTable is an internal argument used during recursion on tables.<br>    ]]<br>    --print(&#39;_is_table_equals( \n     &#39;..prettystr(actual)..&#39;\n      , &#39;..prettystr(expected)..<br>    --                        &#39;\n     , &#39;..prettystr(cycleDetectTable)..&#39;\n    , &#39;..prettystr(marginForAlmostEqual)..&#39; )&#39;)<br><br>    </span><span class=G>local</span><span class=C> type_a</span><span class=O>,</span><span class=C> type_e</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=O>,</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>)<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> type_a</span><span class=E> ~=</span><span class=C> type_e</span><span class=N> then<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=L>false</span><span class=R> -- different types won&#39;t match<br>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> type_a</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=C> marginForAlmostEqual</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>almostEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> marginForAlmostEqual</span><span class=E>)<br></span><span class=R>        </span><span class=N>else<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>actual</span><span class=E> ==</span><span class=C> expected<br></span><span class=R>        </span><span class=N>end<br>    elseif</span><span class=C> type_a</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        -- other types compare directly<br>        </span><span class=K>return</span><span class=A> </span><span class=C>actual</span><span class=E> ==</span><span class=C> expected<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=C>cycleDetectTable</span><span class=D> =</span><span class=C> cycleDetectTable</span><span class=J> or</span><span class=E> {</span><span class=P> actual</span><span class=D>=</span><span class=E>{}</span><span class=O>,</span><span class=P> expected</span><span class=D>=</span><span class=E>{} }<br></span><span class=A>    </span><span class=N>if</span><span class=C> cycleDetectTable</span><span class=H>.</span><span class=C>actual</span><span class=E>[</span><span class=C> actual</span><span class=E> ]</span><span class=N> then<br></span><span class=A>        -- oh, we hit a cycle in actual<br>        </span><span class=N>if</span><span class=C> cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=N> then<br></span><span class=A>            -- uh, we hit a cycle at the same time in expected<br>            -- so the two tables have similar structure<br>            </span><span class=K>return</span><span class=A> </span><span class=L>true<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=C565662>        -- cycle was hit only in actual, the structure differs from expected<br></span><span class=K>        return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=N> then<br></span><span class=A>        -- no cycle in actual, but cycle in expected<br>        -- the structure differ<br>        </span><span class=K>return</span><span class=A> </span><span class=L>false<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    -- at this point, no table cycle detected, we are<br>    -- seeing this table for the first time<br><br>    -- mark the cycle detection<br>    </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>actual</span><span class=E>[</span><span class=C> actual</span><span class=E> ]</span><span class=D> =</span><span class=L> true<br></span><span class=A>    </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=D> =</span><span class=L> true<br><br><br></span><span class=A>    </span><span class=G>local</span><span class=C> actualKeysMatched</span><span class=D> =</span><span class=E> {}<br></span><span class=A>    </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=N> do<br></span><span class=A>        </span><span class=C>actualKeysMatched</span><span class=E>[</span><span class=C>k</span><span class=E>]</span><span class=D> =</span><span class=L> true</span><span class=A> -- Keep track of matched keys<br>        </span><span class=N>if</span><span class=E> not</span><span class=C> _is_table_equals</span><span class=E>(</span><span class=C>v</span><span class=O>,</span><span class=C> expected</span><span class=E>[</span><span class=C>k</span><span class=E>]</span><span class=O>,</span><span class=C> cycleDetectTable</span><span class=O>,</span><span class=C> marginForAlmostEqual</span><span class=E>)</span><span class=N> then<br></span><span class=A>            -- table differs on this key<br>            -- clear the cycle detection before returning<br>            </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>actual</span><span class=E>[</span><span class=C> actual</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=A>            </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=K>            return</span><span class=A> </span><span class=L>false<br></span><span class=R>        </span><span class=N>end<br>    end<br><br></span><span class=A>    </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=N> do<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> actualKeysMatched</span><span class=E>[</span><span class=C>k</span><span class=E>]</span><span class=N> then<br></span><span class=A>            -- Found a key that we did not see in &#34;actual&#34; -&gt; mismatch<br>            -- clear the cycle detection before returning<br>            </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>actual</span><span class=E>[</span><span class=C> actual</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=A>            </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=K>            return</span><span class=A> </span><span class=L>false<br></span><span class=R>        </span><span class=N>end<br></span><span class=C565662>        -- Otherwise actual[k] was already matched against v = expected[k].<br></span><span class=N>    end<br><br></span><span class=A>    -- all key match, we have a match !<br>    </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>actual</span><span class=E>[</span><span class=C> actual</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=A>    </span><span class=C>cycleDetectTable</span><span class=H>.</span><span class=C>expected</span><span class=E>[</span><span class=C> expected</span><span class=E> ]</span><span class=D> =</span><span class=L> nil<br></span><span class=K>    return</span><span class=A> </span><span class=L>true<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>_is_table_equals</span><span class=D> =</span><span class=C> _is_table_equals<br><br></span><span class=K>local function</span><span class=C> failure</span><span class=E>(</span><span class=C>main_msg</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=C> level</span><span class=E>)<br></span><span class=A>    -- raise an error indicating a test failure<br>    -- for error() compatibility we adjust &#34;level&#34; here (by +1), to report the<br>    -- calling context<br>    </span><span class=G>local</span><span class=C> msg<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>extra_msg_or_nil</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>string</span><span class=B>&#39;</span><span class=I> and</span><span class=C> extra_msg_or_nil</span><span class=H>:</span><span class=C>len</span><span class=E>() &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>        </span><span class=C>msg</span><span class=D> =</span><span class=C> extra_msg_or_nil</span><span class=E> ..</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E> ..</span><span class=C> main_msg<br></span><span class=N>    else<br></span><span class=A>        </span><span class=C>msg</span><span class=D> =</span><span class=C> main_msg<br></span><span class=N>    end<br></span><span class=A>    </span><span class=C>error</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>FAILURE_PREFIX</span><span class=E> ..</span><span class=C> msg</span><span class=O>,</span><span class=E> (</span><span class=C>level</span><span class=J> or</span><span class=M> 1</span><span class=E>) +</span><span class=M> 1</span><span class=E> +</span><span class=C> M</span><span class=H>.</span><span class=C>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE</span><span class=E>)<br></span><span class=K>end<br><br>local function</span><span class=C> is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> marginForAlmostEqual</span><span class=E>)<br></span><span class=A>    </span><span class=K>return</span><span class=A> </span><span class=C>_is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=C> marginForAlmostEqual</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>is_table_equals</span><span class=D> =</span><span class=C> is_table_equals<br><br></span><span class=K>local function</span><span class=C> fail_fmt</span><span class=E>(</span><span class=C>level</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>, ...</span><span class=E>)<br></span><span class=A>     -- failure with printf-style formatted message and given error level<br>    </span><span class=C>failure</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=O>...</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=E> (</span><span class=C>level</span><span class=J> or</span><span class=M> 1</span><span class=E>) +</span><span class=M> 1</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>fail_fmt</span><span class=D> =</span><span class=C> fail_fmt<br><br></span><span class=K>local function</span><span class=C> error_fmt</span><span class=E>(</span><span class=C>level</span><span class=O>, ...</span><span class=E>)<br></span><span class=A>     -- printf-style error()<br>    </span><span class=C>error</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=O>...</span><span class=E>)</span><span class=O>,</span><span class=E> (</span><span class=C>level</span><span class=J> or</span><span class=M> 1</span><span class=E>) +</span><span class=M> 1</span><span class=E> +</span><span class=C> M</span><span class=H>.</span><span class=C>STRIP_EXTRA_ENTRIES_IN_STACK_TRACE</span><span class=E>)<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>private</span><span class=H>.</span><span class=C>error_fmt</span><span class=D> =</span><span class=C> error_fmt<br><br></span><span class=A>----------------------------------------------------------------<br>--<br>--                     assertions<br>--<br>----------------------------------------------------------------<br><br></span><span class=K>local function</span><span class=C> errorMsgEquality</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=O>,</span><span class=C> margin</span><span class=E>)<br></span><span class=A>    -- margin is supplied only for almost equal verification<br><br>    </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>        </span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=D> =</span><span class=C> actual</span><span class=O>,</span><span class=C> expected<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>string</span><span class=B>&#39;</span><span class=J> or</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> strExpected</span><span class=O>,</span><span class=C> strActual</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=E>)<br></span><span class=A>        </span><span class=G>local</span><span class=C> result</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: %s\nactual: %s</span><span class=B>&#34;</span><span class=O>,</span><span class=C> strExpected</span><span class=O>,</span><span class=C> strActual</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> margin</span><span class=N> then<br></span><span class=A>            </span><span class=C>result</span><span class=D> =</span><span class=C> result</span><span class=E> ..</span><span class=B> &#39;</span><span class=F>\nwere not equal by the margin of: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>margin</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=A>        -- extend with mismatch analysis if possible:<br>        </span><span class=G>local</span><span class=C> success</span><span class=O>,</span><span class=C> mismatchResult<br></span><span class=A>        </span><span class=C>success</span><span class=O>,</span><span class=C> mismatchResult</span><span class=D> =</span><span class=C> tryMismatchFormatting</span><span class=E>(</span><span class=A> </span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=O>,</span><span class=C> margin</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> success</span><span class=N> then</span><span class=A> <br>            </span><span class=C>result</span><span class=D> =</span><span class=C> table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=A> </span><span class=E>{</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=A> </span><span class=C>mismatchResult</span><span class=E> }</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E> )<br></span><span class=N>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>result<br></span><span class=R>    </span><span class=N>end<br></span><span class=K>    return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: %s, actual: %s</span><span class=B>&#34;</span><span class=O>,<br></span><span class=C>                         prettystr</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>actual</span><span class=E>))<br></span><span class=K>end<br><br>function</span><span class=C> M.assertError</span><span class=E>(</span><span class=C>f</span><span class=O>, ...</span><span class=E>)<br></span><span class=A>    -- assert that calling f with the arguments will raise an error<br>    -- example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    </span><span class=N>if</span><span class=C> pcall</span><span class=E>(</span><span class=A> </span><span class=C>f</span><span class=O>, ...</span><span class=E> )</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>Expected an error when calling function but no error generated</span><span class=B>&#34;</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.fail</span><span class=E>(</span><span class=C> msg</span><span class=E> )<br></span><span class=A>    -- stops a test due to a failure<br>    </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>msg</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=K>end<br><br>function</span><span class=C> M.failIf</span><span class=E>(</span><span class=C> cond</span><span class=O>,</span><span class=C> msg</span><span class=E> )<br></span><span class=A>    -- Fails a test with &#34;msg&#34; if condition is true<br>    </span><span class=N>if</span><span class=C> cond</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>msg</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.skip</span><span class=E>(</span><span class=C>msg</span><span class=E>)<br></span><span class=A>    -- skip a running test<br>    </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=E> ..</span><span class=C> msg</span><span class=E>)<br></span><span class=K>end<br><br>function</span><span class=C> M.skipIf</span><span class=E>(</span><span class=C> cond</span><span class=O>,</span><span class=C> msg</span><span class=E> )<br></span><span class=A>    -- skip a running test if condition is met<br>    </span><span class=N>if</span><span class=C> cond</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=E> ..</span><span class=C> msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.runOnlyIf</span><span class=E>(</span><span class=C> cond</span><span class=O>,</span><span class=C> msg</span><span class=E> )<br></span><span class=A>    -- continue a running test if condition is met, else skip it<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> cond</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>SKIP_PREFIX</span><span class=E> ..</span><span class=C> prettystr</span><span class=E>(</span><span class=C>msg</span><span class=E>))<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.success</span><span class=E>()<br></span><span class=A>    -- stops a test with a success<br>    </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>SUCCESS_PREFIX</span><span class=E>)<br></span><span class=K>end<br><br>function</span><span class=C> M.successIf</span><span class=E>(</span><span class=C> cond</span><span class=E> )<br></span><span class=A>    -- stops a test with a success if condition is met<br>    </span><span class=N>if</span><span class=C> cond</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>SUCCESS_PREFIX</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br><br></span><span class=A>------------------------------------------------------------------<br>--                  Equality assertions<br>------------------------------------------------------------------<br><br></span><span class=K>function</span><span class=C> M.assertEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>errorMsgEquality</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> doDeepAnalysis</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>        end<br>    elseif</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ~=</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>errorMsgEquality</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    elseif</span><span class=C> actual</span><span class=E> ~=</span><span class=C> expected</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>errorMsgEquality</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.almostEquals</span><span class=E>(</span><span class=C> actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=E> )<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> type</span><span class=E>(</span><span class=C>margin</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>3</span><span class=O>,</span><span class=B> &#39;</span><span class=F>almostEquals: must supply only number arguments.\nArguments supplied: %s, %s, %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>            prettystr</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>margin</span><span class=E>))<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> margin</span><span class=E> &lt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>3</span><span class=O>,</span><span class=B> &#39;</span><span class=F>almostEquals: margin must not be negative, current value is </span><span class=B>&#39;</span><span class=E> ..</span><span class=C> margin</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=C>expected</span><span class=E> -</span><span class=C> actual</span><span class=E>) &lt;=</span><span class=C> margin<br></span><span class=K>end<br><br>function</span><span class=C> M.assertAlmostEquals</span><span class=E>(</span><span class=C> actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- check that two floats are close by margin<br>    </span><span class=C>margin</span><span class=D> =</span><span class=C> margin</span><span class=J> or</span><span class=C> M</span><span class=H>.</span><span class=C>EPS<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>margin</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=B> &#39;</span><span class=F>almostEquals: margin must be a number, not %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>margin</span><span class=E>))<br></span><span class=N>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        -- handle almost equals for table<br>        </span><span class=N>if</span><span class=E> not</span><span class=C> is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=C>errorMsgEquality</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>        end<br>    elseif</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>margin</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>almostEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>                </span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=D> =</span><span class=C> actual</span><span class=O>,</span><span class=C> expected<br></span><span class=N>            end<br></span><span class=A>            </span><span class=G>local</span><span class=C> delta</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=C>actual</span><span class=E> -</span><span class=C> expected</span><span class=E>)</span><span class=A> <br>            </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Values are not almost equal\n</span><span class=B>&#39;</span><span class=E> ..<br></span><span class=B>                        &#39;</span><span class=F>Actual: %s, expected: %s, delta %s above margin of %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                        actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> delta</span><span class=O>,</span><span class=C> margin</span><span class=E>)<br></span><span class=N>        end<br>    else<br></span><span class=A>        </span><span class=C>error_fmt</span><span class=E>(</span><span class=M>3</span><span class=O>,</span><span class=B> &#39;</span><span class=F>almostEquals: must supply only number or table arguments.\nArguments supplied: %s, %s, %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>            prettystr</span><span class=E>(</span><span class=C>actual</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>margin</span><span class=E>))<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ~=</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=K>return<br></span><span class=R>    </span><span class=N>end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>actual</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>expected</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> is_table_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return<br></span><span class=R>        </span><span class=N>end<br>    elseif</span><span class=C> actual</span><span class=E> ~=</span><span class=C> expected</span><span class=N> then<br></span><span class=A>        </span><span class=K>return<br></span><span class=R>    </span><span class=N>end<br></span><span class=A>    </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Received the not expected value: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>actual</span><span class=E>))<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotAlmostEquals</span><span class=E>(</span><span class=C> actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- check that two floats are not close by margin<br>    </span><span class=C>margin</span><span class=D> =</span><span class=C> margin</span><span class=J> or</span><span class=C> M</span><span class=H>.</span><span class=C>EPS<br></span><span class=A>    </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>almostEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> margin</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>            </span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=D> =</span><span class=C> actual</span><span class=O>,</span><span class=C> expected<br></span><span class=N>        end<br></span><span class=A>        </span><span class=G>local</span><span class=C> delta</span><span class=D> =</span><span class=C> math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=C>actual</span><span class=E> -</span><span class=C> expected</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Values are almost equal\nActual: %s, expected: %s</span><span class=B>&#39;</span><span class=E> ..<br></span><span class=B>                    &#39;</span><span class=F>, delta %s below margin of %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                    actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> delta</span><span class=O>,</span><span class=C> margin</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertItemsEquals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    -- checks that the items of table expected<br>    -- are contained in table actual. Warning, this function<br>    -- is at least O(n^2)<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> _is_table_items_equals</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=E> )</span><span class=N> then<br></span><span class=A>        </span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Content of the tables are not identical:\nExpected: %s\nActual: %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 expected</span><span class=O>,</span><span class=C> actual</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br></span><span class=A>------------------------------------------------------------------<br>--                  String assertion<br>------------------------------------------------------------------<br><br></span><span class=K>function</span><span class=C> M.assertStrContains</span><span class=E>(</span><span class=C> str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> isPattern</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- this relies on lua string.find function<br>    -- a string always contains the empty string<br>    -- assert( type(str) == &#39;string&#39;, &#39;Argument 1 of assertStrContains() should be a string.&#39; ) )<br>    -- assert( type(sub) == &#39;string&#39;, &#39;Argument 2 of assertStrContains() should be a string.&#39; ) )<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=E> not</span><span class=C> isPattern</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Could not find %s %s in string %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 isPattern</span><span class=I> and</span><span class=B> &#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=J> or</span><span class=B> &#39;</span><span class=F>substring</span><span class=B>&#39;</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> str</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertStrIContains</span><span class=E>(</span><span class=C> str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- this relies on lua string.find function<br>    -- a string always contains the empty string<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>str</span><span class=H>:</span><span class=C>lower</span><span class=E>()</span><span class=O>,</span><span class=C> sub</span><span class=H>:</span><span class=C>lower</span><span class=E>()</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Could not find (case insensitively) substring %s in string %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 sub</span><span class=O>,</span><span class=C> str</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotStrContains</span><span class=E>(</span><span class=C> str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> isPattern</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- this relies on lua string.find function<br>    -- a string always contains the empty string<br>    </span><span class=N>if</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=E> not</span><span class=C> isPattern</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Found the not expected %s %s in string %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 isPattern</span><span class=I> and</span><span class=B> &#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=J> or</span><span class=B> &#39;</span><span class=F>substring</span><span class=B>&#39;</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> str</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotStrIContains</span><span class=E>(</span><span class=C> str</span><span class=O>,</span><span class=C> sub</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- this relies on lua string.find function<br>    -- a string always contains the empty string<br>    </span><span class=N>if</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>str</span><span class=H>:</span><span class=C>lower</span><span class=E>()</span><span class=O>,</span><span class=C> sub</span><span class=H>:</span><span class=C>lower</span><span class=E>()</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>sub</span><span class=O>,</span><span class=C> str</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Found (case insensitively) the not expected substring %s in string %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 sub</span><span class=O>,</span><span class=C> str</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertStrMatches</span><span class=E>(</span><span class=C> str</span><span class=O>,</span><span class=C> pattern</span><span class=O>,</span><span class=C> start</span><span class=O>,</span><span class=C> final</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E> )<br></span><span class=A>    -- Verify a full match for the string<br>    </span><span class=N>if</span><span class=E> not</span><span class=C> strMatch</span><span class=E>(</span><span class=A> </span><span class=C>str</span><span class=O>,</span><span class=C> pattern</span><span class=O>,</span><span class=C> start</span><span class=O>,</span><span class=C> final</span><span class=E> )</span><span class=N> then<br></span><span class=A>        </span><span class=C>pattern</span><span class=O>,</span><span class=C> str</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>pattern</span><span class=O>,</span><span class=C> str</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Could not match pattern %s with string %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 pattern</span><span class=O>,</span><span class=C> str</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>local function</span><span class=C> _assertErrorMsgEquals</span><span class=E>(</span><span class=C> stripFileAndLine</span><span class=O>,</span><span class=C> expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    </span><span class=G>local</span><span class=C> no_error</span><span class=O>,</span><span class=C> error_msg</span><span class=D> =</span><span class=C> pcall</span><span class=E>(</span><span class=A> </span><span class=C>func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    </span><span class=N>if</span><span class=C> no_error</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>No error generated when calling function but expected error: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>M</span><span class=H>.</span><span class=C>prettystr</span><span class=E>(</span><span class=C>expectedMsg</span><span class=E>)</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 3</span><span class=E> )<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>expectedMsg</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>error_msg</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>        -- table are converted to string automatically<br>        </span><span class=C>error_msg</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=A>    </span><span class=G>local</span><span class=C> differ</span><span class=D> =</span><span class=L> false<br></span><span class=A>    </span><span class=N>if</span><span class=C> stripFileAndLine</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=C> error_msg</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=B>&#34;</span><span class=F>^.+:%d+: </span><span class=B>&#34;</span><span class=O>,</span><span class=B> &#34;&#34;</span><span class=E>) ~=</span><span class=C> expectedMsg</span><span class=N> then<br></span><span class=A>            </span><span class=C>differ</span><span class=D> =</span><span class=L> true<br></span><span class=N>        end<br>    else<br></span><span class=A>        </span><span class=N>if</span><span class=C> error_msg</span><span class=E> ~=</span><span class=C> expectedMsg</span><span class=N> then<br></span><span class=A>            </span><span class=G>local</span><span class=C> tr</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>error_msg</span><span class=E>)<br></span><span class=A>            </span><span class=G>local</span><span class=C> te</span><span class=D> =</span><span class=C> type</span><span class=E>(</span><span class=C>expectedMsg</span><span class=E>)<br></span><span class=A>            </span><span class=N>if</span><span class=C> te</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=N>if</span><span class=C> tr</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                    </span><span class=C>differ</span><span class=D> =</span><span class=L> true<br></span><span class=N>                else<br></span><span class=A>                     </span><span class=G>local</span><span class=C> ok</span><span class=D> =</span><span class=C> pcall</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>assertItemsEquals</span><span class=O>,</span><span class=C> error_msg</span><span class=O>,</span><span class=C> expectedMsg</span><span class=E>)<br></span><span class=A>                     </span><span class=N>if</span><span class=E> not</span><span class=C> ok</span><span class=N> then<br></span><span class=A>                         </span><span class=C>differ</span><span class=D> =</span><span class=L> true<br></span><span class=N>                     end<br>                end<br>            else<br></span><span class=A>               </span><span class=C>differ</span><span class=D> =</span><span class=L> true<br></span><span class=N>            end<br>        end<br>    end<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> differ</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_msg</span><span class=O>,</span><span class=C> expectedMsg</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>error_msg</span><span class=O>,</span><span class=C> expectedMsg</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>3</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Error message expected: %s\nError message received: %s\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 expectedMsg</span><span class=O>,</span><span class=C> error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertErrorMsgEquals</span><span class=E>(</span><span class=C> expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    -- assert that calling f with the arguments will raise an error<br>    -- example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    </span><span class=C>_assertErrorMsgEquals</span><span class=E>(</span><span class=L>false</span><span class=O>,</span><span class=C> expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E>)<br></span><span class=K>end<br><br>function</span><span class=C> M.assertErrorMsgContentEquals</span><span class=E>(</span><span class=C>expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E>)<br></span><span class=A>     </span><span class=C>_assertErrorMsgEquals</span><span class=E>(</span><span class=L>true</span><span class=O>,</span><span class=C> expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E>)<br></span><span class=K>end<br><br>function</span><span class=C> M.assertErrorMsgContains</span><span class=E>(</span><span class=C> partialMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    -- assert that calling f with the arguments will raise an error<br>    -- example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    </span><span class=G>local</span><span class=C> no_error</span><span class=O>,</span><span class=C> error_msg</span><span class=D> =</span><span class=C> pcall</span><span class=E>(</span><span class=A> </span><span class=C>func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    </span><span class=N>if</span><span class=C> no_error</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>No error generated when calling function but expected error containing: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>partialMsg</span><span class=E>)</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>error_msg</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_msg</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=E> not</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=A> </span><span class=C>error_msg</span><span class=O>,</span><span class=C> partialMsg</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=L> true</span><span class=E> )</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_msg</span><span class=O>,</span><span class=C> partialMsg</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>error_msg</span><span class=O>,</span><span class=C> partialMsg</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Error message does not contain: %s\nError message received: %s\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 partialMsg</span><span class=O>,</span><span class=C> error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertErrorMsgMatches</span><span class=E>(</span><span class=C> expectedMsg</span><span class=O>,</span><span class=C> func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    -- assert that calling f with the arguments will raise an error<br>    -- example: assertError( f, 1, 2 ) =&gt; f(1,2) should generate an error<br>    </span><span class=G>local</span><span class=C> no_error</span><span class=O>,</span><span class=C> error_msg</span><span class=D> =</span><span class=C> pcall</span><span class=E>(</span><span class=A> </span><span class=C>func</span><span class=O>, ...</span><span class=E> )<br></span><span class=A>    </span><span class=N>if</span><span class=C> no_error</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>No error generated when calling function but expected error matching: &#34;</span><span class=B>&#39;</span><span class=E>..</span><span class=C>expectedMsg</span><span class=E>..</span><span class=B>&#39;</span><span class=F>&#34;</span><span class=B>&#39;</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=M> 2</span><span class=E> )<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>error_msg</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>        </span><span class=C>error_msg</span><span class=D> =</span><span class=C> tostring</span><span class=E>(</span><span class=C>error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=A>    </span><span class=N>if</span><span class=E> not</span><span class=C> strMatch</span><span class=E>(</span><span class=A> </span><span class=C>error_msg</span><span class=O>,</span><span class=C> expectedMsg</span><span class=E> )</span><span class=N> then<br></span><span class=A>        </span><span class=C>expectedMsg</span><span class=O>,</span><span class=C> error_msg</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>expectedMsg</span><span class=O>,</span><span class=C> error_msg</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Error message does not match pattern: %s\nError message received: %s\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 expectedMsg</span><span class=O>,</span><span class=C> error_msg</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br></span><span class=A>------------------------------------------------------------------<br>--              Type assertions<br>------------------------------------------------------------------<br><br></span><span class=K>function</span><span class=C> M.assertEvalToTrue</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=E> not</span><span class=C> value</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: a value evaluating to true, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertEvalToFalse</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: false or nil, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsTrue</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ~=</span><span class=L> true</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: true, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsTrue</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ==</span><span class=L> true</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not true, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsFalse</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ~=</span><span class=L> false</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: false, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsFalse</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ==</span><span class=L> false</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not false, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsNil</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: nil, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsNil</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> value</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not nil, actual: nil</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br></span><span class=A>--[[<br>Add type assertion functions to the module table M. Each of these functions<br>takes a single parameter &#34;value&#34;, and checks that its Lua type matches the<br>expected string (derived from the function name):<br><br>M.assertIsXxx(value) -&gt; ensure that type(value) conforms to &#34;xxx&#34;<br>]]<br></span><span class=N>for</span><span class=C> _</span><span class=O>,</span><span class=C> funcName</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(<br></span><span class=A>    </span><span class=E>{</span><span class=B>&#39;</span><span class=F>assertIsNumber</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsString</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTable</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsBoolean</span><span class=B>&#39;</span><span class=O>,<br></span><span class=A>     </span><span class=B>&#39;</span><span class=F>assertIsFunction</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsUserdata</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=E>}<br>)</span><span class=N> do<br></span><span class=A>    </span><span class=G>local</span><span class=C> typeExpected</span><span class=D> =</span><span class=C> funcName</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=B>&#34;</span><span class=F>^assertIs([A-Z]%a*)$</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>    -- Lua type() always returns lowercase, also make sure the match() succeeded<br>    </span><span class=C>typeExpected</span><span class=D> =</span><span class=C> typeExpected</span><span class=I> and</span><span class=C> typeExpected</span><span class=H>:</span><span class=C>lower</span><span class=E>()<br></span><span class=J>                   or</span><span class=C> error</span><span class=E>(</span><span class=B>&#34;</span><span class=F>bad function name &#39;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>funcName</span><span class=E>..</span><span class=B>&#34;</span><span class=F>&#39; for type assertion</span><span class=B>&#34;</span><span class=E>)<br><br></span><span class=A>    </span><span class=C>M</span><span class=E>[</span><span class=C>funcName</span><span class=E>]</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=C> typeExpected</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>nil</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected: a %s value, actual: nil</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                         typeExpected</span><span class=O>,</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>value</span><span class=E>))<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected: a %s value, actual: type %s, value %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                         typeExpected</span><span class=O>,</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>value</span><span class=E>))<br></span><span class=N>            end<br>        end<br></span><span class=K>    end<br></span><span class=N>end<br><br></span><span class=A>--[[<br>Add shortcuts for verifying type of a variable, without failure (luaunit v2 compatibility)<br>M.isXxx(value) -&gt; returns true if type(value) conforms to &#34;xxx&#34;<br>]]<br></span><span class=N>for</span><span class=C> _</span><span class=O>,</span><span class=C> typeExpected</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(<br></span><span class=A>    </span><span class=E>{</span><span class=B>&#39;</span><span class=F>Number</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>String</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>Table</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>Boolean</span><span class=B>&#39;</span><span class=O>,<br></span><span class=A>     </span><span class=B>&#39;</span><span class=F>Function</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>Userdata</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>Thread</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>Nil</span><span class=B>&#39;</span><span class=E> }<br>)</span><span class=N> do<br></span><span class=A>    </span><span class=G>local</span><span class=C> typeExpectedLower</span><span class=D> =</span><span class=C> typeExpected</span><span class=H>:</span><span class=C>lower</span><span class=E>()<br></span><span class=A>    </span><span class=G>local</span><span class=C> isType</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>value</span><span class=E>)<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=E>(</span><span class=C>type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=C> typeExpectedLower</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br></span><span class=A>    </span><span class=C>M</span><span class=E>[</span><span class=B>&#39;</span><span class=F>is</span><span class=B>&#39;</span><span class=E>..</span><span class=C>typeExpected</span><span class=E>]</span><span class=D> =</span><span class=C> isType<br></span><span class=A>    </span><span class=C>M</span><span class=E>[</span><span class=B>&#39;</span><span class=F>is_</span><span class=B>&#39;</span><span class=E>..</span><span class=C>typeExpectedLower</span><span class=E>]</span><span class=D> =</span><span class=C> isType<br></span><span class=N>end<br><br></span><span class=A>--[[<br>Add non-type assertion functions to the module table M. Each of these functions<br>takes a single parameter &#34;value&#34;, and checks that its Lua type differs from the<br>expected string (derived from the function name):<br><br>M.assertNotIsXxx(value) -&gt; ensure that type(value) is not &#34;xxx&#34;<br>]]<br></span><span class=N>for</span><span class=C> _</span><span class=O>,</span><span class=C> funcName</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(<br></span><span class=A>    </span><span class=E>{</span><span class=B>&#39;</span><span class=F>assertNotIsNumber</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsString</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTable</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsBoolean</span><span class=B>&#39;</span><span class=O>,<br></span><span class=A>     </span><span class=B>&#39;</span><span class=F>assertNotIsFunction</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsUserdata</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=E>}<br>)</span><span class=N> do<br></span><span class=A>    </span><span class=G>local</span><span class=C> typeUnexpected</span><span class=D> =</span><span class=C> funcName</span><span class=H>:</span><span class=C>match</span><span class=E>(</span><span class=B>&#34;</span><span class=F>^assertNotIs([A-Z]%a*)$</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>    -- Lua type() always returns lowercase, also make sure the match() succeeded<br>    </span><span class=C>typeUnexpected</span><span class=D> =</span><span class=C> typeUnexpected</span><span class=I> and</span><span class=C> typeUnexpected</span><span class=H>:</span><span class=C>lower</span><span class=E>()<br></span><span class=J>                   or</span><span class=C> error</span><span class=E>(</span><span class=B>&#34;</span><span class=F>bad function name &#39;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>funcName</span><span class=E>..</span><span class=B>&#34;</span><span class=F>&#39; for type assertion</span><span class=B>&#34;</span><span class=E>)<br><br></span><span class=A>    </span><span class=C>M</span><span class=E>[</span><span class=C>funcName</span><span class=E>]</span><span class=D> =</span><span class=K> function</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=C> typeUnexpected</span><span class=N> then<br></span><span class=A>            </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected: not a %s type, actual: value %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                     typeUnexpected</span><span class=O>,</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>value</span><span class=E>))<br></span><span class=N>        end<br></span><span class=K>    end<br></span><span class=N>end<br><br></span><span class=K>function</span><span class=C> M.assertIs</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> actual</span><span class=E> ~=</span><span class=C> expected</span><span class=N> then<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>            </span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=D> =</span><span class=C> expected</span><span class=O>,</span><span class=C> actual<br></span><span class=N>        end<br></span><span class=A>        </span><span class=G>local</span><span class=C> old_print_table_ref_in_error_msg</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG<br></span><span class=A>        </span><span class=C>M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=D> =</span><span class=L> true<br></span><span class=A>        </span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>expected</span><span class=O>,</span><span class=C> actual</span><span class=O>,</span><span class=B> &#39;</span><span class=F>\n</span><span class=B>&#39;</span><span class=O>,</span><span class=B> &#39;&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=D> =</span><span class=C> old_print_table_ref_in_error_msg<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected and actual object should not be different\nExpected: %s\nReceived: %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 expected</span><span class=O>,</span><span class=C> actual</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIs</span><span class=E>(</span><span class=C>actual</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> actual</span><span class=E> ==</span><span class=C> expected</span><span class=N> then<br></span><span class=A>        </span><span class=G>local</span><span class=C> old_print_table_ref_in_error_msg</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG<br></span><span class=A>        </span><span class=C>M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=D> =</span><span class=L> true<br></span><span class=A>        </span><span class=G>local</span><span class=C> s_expected<br></span><span class=A>        </span><span class=N>if</span><span class=E> not</span><span class=C> M</span><span class=H>.</span><span class=C>ORDER_ACTUAL_EXPECTED</span><span class=N> then<br></span><span class=A>            </span><span class=C>s_expected</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>actual</span><span class=E>)<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>s_expected</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>expected</span><span class=E>)<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>M</span><span class=H>.</span><span class=C>PRINT_TABLE_REF_IN_ERROR_MSG</span><span class=D> =</span><span class=C> old_print_table_ref_in_error_msg<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>expected and actual object should be different: %s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> s_expected</span><span class=E> )<br></span><span class=N>    end<br></span><span class=K>end<br><br><br></span><span class=A>------------------------------------------------------------------<br>--              Scientific assertions<br>------------------------------------------------------------------<br><br><br></span><span class=K>function</span><span class=C> M.assertIsNaN</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=J> or</span><span class=C> value</span><span class=E> ==</span><span class=C> value</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: NaN, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsNaN</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=I> and</span><span class=C> value</span><span class=E> ~=</span><span class=C> value</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not NaN, actual: NaN</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=J> or</span><span class=C> math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: #Inf, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsPlusInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=J> or</span><span class=C> value</span><span class=E> ~=</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: #Inf, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsMinusInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=J> or</span><span class=C> value</span><span class=E> ~= -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: -#Inf, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsPlusInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=I> and</span><span class=C> value</span><span class=E> ==</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not #Inf, actual: #Inf</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsMinusInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=I> and</span><span class=C> value</span><span class=E> == -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not -#Inf, actual: -#Inf</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsInf</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>number</span><span class=B>&#34;</span><span class=I> and</span><span class=C> math</span><span class=H>.</span><span class=C>abs</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not infinity, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C> prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsPlusZero</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> value</span><span class=E> ~=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: +0.0, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    else</span><span class=A> </span><span class=N>if</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> == -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>            -- more precise error diagnosis<br>            </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: +0.0, actual: -0.0</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>        else</span><span class=A> </span><span class=N>if</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> ~=</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>                -- strange, case should have already been covered<br>                </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: +0.0, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>            end<br>        end<br>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertIsMinusZero</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=J> or</span><span class=C> value</span><span class=E> ~=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: -0.0, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    else</span><span class=A> </span><span class=N>if</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> ==</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>            -- more precise error diagnosis<br>            </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: -0.0, actual: +0.0</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>        else</span><span class=A> </span><span class=N>if</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> ~= -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>                -- strange, case should have already been covered<br>                </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: -0.0, actual: </span><span class=B>&#34;</span><span class=E> ..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>value</span><span class=E>)</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>            end<br>        end<br>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsPlusZero</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=I> and</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> ==</span><span class=C> math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not +0.0, actual: +0.0</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotIsMinusZero</span><span class=E>(</span><span class=C>value</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>value</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>number</span><span class=B>&#39;</span><span class=I> and</span><span class=E> (</span><span class=M>1</span><span class=E>/</span><span class=C>value</span><span class=E> == -</span><span class=C>math</span><span class=H>.</span><span class=C>huge</span><span class=E>)</span><span class=N> then<br></span><span class=A>        </span><span class=C>failure</span><span class=E>(</span><span class=B>&#34;</span><span class=F>expected: not -0.0, actual: -0.0</span><span class=B>&#34;</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertTableContains</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    -- checks that table t contains the expected element<br>    </span><span class=N>if</span><span class=C> table_findkeyof</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=E>) ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Table %s does NOT contain the expected element %s</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 t</span><span class=O>,</span><span class=C> expected</span><span class=E>)<br></span><span class=N>    end<br></span><span class=K>end<br><br>function</span><span class=C> M.assertNotTableContains</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=E>)<br></span><span class=A>    -- checks that table t doesn&#39;t contain the expected element<br>    </span><span class=G>local</span><span class=C> k</span><span class=D> =</span><span class=C> table_findkeyof</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=E>)<br></span><span class=A>    </span><span class=N>if</span><span class=C> k</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>        </span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=D> =</span><span class=C> prettystrPairs</span><span class=E>(</span><span class=C>t</span><span class=O>,</span><span class=C> expected</span><span class=E>)<br></span><span class=A>        </span><span class=C>fail_fmt</span><span class=E>(</span><span class=M>2</span><span class=O>,</span><span class=C> extra_msg_or_nil</span><span class=O>,</span><span class=B> &#39;</span><span class=F>Table %s DOES contain the unwanted element %s (at key %s)</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                 t</span><span class=O>,</span><span class=C> expected</span><span class=O>,</span><span class=C> prettystr</span><span class=E>(</span><span class=C>k</span><span class=E>))<br></span><span class=N>    end<br></span><span class=K>end<br><br></span><span class=A>----------------------------------------------------------------<br>--                     Compatibility layer<br>----------------------------------------------------------------<br><br>-- for compatibility with LuaUnit v2.x<br></span><span class=K>function</span><span class=C> M.wrapFunctions</span><span class=E>()<br></span><span class=A>    -- In LuaUnit version &lt;= 2.1 , this function was necessary to include<br>    -- a test function inside the global test suite. Nowadays, the functions<br>    -- are simply run directly as part of the test discovery process.<br>    -- so just do nothing !<br>    </span><span class=C>io</span><span class=H>.</span><span class=C>stderr</span><span class=H>:</span><span class=C>write</span><span class=B>[[</span><span class=F>Use of WrapFunctions() is no longer needed.<br>Just prefix your test function names with &#34;test&#34; or &#34;Test&#34; and they<br>will be picked up and run by LuaUnit.<br></span><span class=B>]]<br></span><span class=K>end<br><br></span><span class=G>local</span><span class=C> list_of_funcs</span><span class=D> =</span><span class=E> {<br></span><span class=A>    -- { official function name , alias }<br><br>    -- general assertions<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertEquals</span><span class=B>&#39;</span><span class=O>            ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertItemsEquals</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_items_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotEquals</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertAlmostEquals</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_almost_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotAlmostEquals</span><span class=B>&#39;</span><span class=O>   ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_almost_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertEvalToTrue</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_eval_to_true</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertEvalToFalse</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_eval_to_false</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertStrContains</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_str_contains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertStrIContains</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_str_icontains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotStrContains</span><span class=B>&#39;</span><span class=O>    ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_str_contains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotStrIContains</span><span class=B>&#39;</span><span class=O>   ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_str_icontains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertStrMatches</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_str_matches</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertError</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_error</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertErrorMsgEquals</span><span class=B>&#39;</span><span class=O>    ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_error_msg_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertErrorMsgContains</span><span class=B>&#39;</span><span class=O>  ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_error_msg_contains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertErrorMsgMatches</span><span class=B>&#39;</span><span class=O>   ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_error_msg_matches</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertErrorMsgContentEquals</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_error_msg_content_equals</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIs</span><span class=B>&#39;</span><span class=O>                ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIs</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertTableContains</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_table_contains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotTableContains</span><span class=B>&#39;</span><span class=O>  ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_table_contains</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>wrapFunctions</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>WrapFunctions</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>wrapFunctions</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>wrap_functions</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertIsXXX -&gt; assert_is_xxx<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNumber</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_number</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsString</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_string</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTable</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_table</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsBoolean</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_boolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNil</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_nil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTrue</span><span class=B>&#39;</span><span class=O>            ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_true</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFalse</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_false</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNaN</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_nan</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsInf</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusInf</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_plus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusInf</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_minus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusZero</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_plus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusZero</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_minus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFunction</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_function</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_thread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsUserdata</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_userdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertIsXXX -&gt; assertXxx<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNumber</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNumber</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsString</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertString</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTable</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertTable</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsBoolean</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertBoolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNil</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTrue</span><span class=B>&#39;</span><span class=O>            ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertTrue</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFalse</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertFalse</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNaN</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNaN</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsInf</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusInf</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertPlusInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusInf</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertMinusInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusZero</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertPlusZero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusZero</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertMinusZero</span><span class=B>&#39;</span><span class=E>}</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFunction</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertFunction</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertThread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsUserdata</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertUserdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertIsXXX -&gt; assert_xxx (luaunit v2 compat)<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNumber</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_number</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsString</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_string</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTable</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_table</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsBoolean</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_boolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNil</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_nil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsTrue</span><span class=B>&#39;</span><span class=O>            ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_true</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFalse</span><span class=B>&#39;</span><span class=O>           ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_false</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsNaN</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_nan</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsInf</span><span class=B>&#39;</span><span class=O>             ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusInf</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_plus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusInf</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_minus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsPlusZero</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_plus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsMinusZero</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_minus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsFunction</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_function</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_thread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsUserdata</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_userdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertNotIsXXX -&gt; assert_not_is_xxx<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNumber</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_number</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsString</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_string</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTable</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_table</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsBoolean</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_boolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNil</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_nil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTrue</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_true</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFalse</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_false</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNaN</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_nan</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsInf</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusInf</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_plus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusInf</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_minus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusZero</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_plus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusZero</span><span class=B>&#39;</span><span class=O>    ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_minus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFunction</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_function</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_thread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsUserdata</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_userdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertNotIsXXX -&gt; assertNotXxx (luaunit v2 compat)<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNumber</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotNumber</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsString</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotString</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTable</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotTable</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsBoolean</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotBoolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNil</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotNil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTrue</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotTrue</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFalse</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotFalse</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNaN</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotNaN</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsInf</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusInf</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotPlusInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusInf</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotMinusInf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusZero</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotPlusZero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusZero</span><span class=B>&#39;</span><span class=O>    ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotMinusZero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFunction</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotFunction</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotThread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsUserdata</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotUserdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- type assertions: assertNotIsXXX -&gt; assert_not_xxx<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNumber</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_number</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsString</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_string</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTable</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_table</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsBoolean</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_boolean</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNil</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_nil</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsTrue</span><span class=B>&#39;</span><span class=O>         ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_true</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFalse</span><span class=B>&#39;</span><span class=O>        ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_false</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsNaN</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_nan</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsInf</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusInf</span><span class=B>&#39;</span><span class=O>      ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_plus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusInf</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_minus_inf</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsPlusZero</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_plus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsMinusZero</span><span class=B>&#39;</span><span class=O>    ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_minus_zero</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsFunction</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_function</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_thread</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsUserdata</span><span class=B>&#39;</span><span class=O>     ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_userdata</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br><br></span><span class=A>    -- all assertions with Coroutine duplicate Thread assertions<br>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsCoroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertCoroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_is_coroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertIsThread</span><span class=B>&#39;</span><span class=O>          ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_coroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsCoroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotCoroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_is_coroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=A>    </span><span class=E>{</span><span class=A> </span><span class=B>&#39;</span><span class=F>assertNotIsThread</span><span class=B>&#39;</span><span class=O>       ,</span><span class=A> </span><span class=B>&#39;</span><span class=F>assert_not_coroutine</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,<br></span><span class=E>}<br><br></span><span class=A>-- Create all aliases in M<br></span><span class=N>for</span><span class=C> _</span><span class=O>,</span><span class=C>v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>list_of_funcs</span><span class=E> )</span><span class=N> do<br></span><span class=A>    </span><span class=G>local</span><span class=C> funcname</span><span class=O>,</span><span class=C> alias</span><span class=D> =</span><span class=C> v</span><span class=E>[</span><span class=M>1</span><span class=E>]</span><span class=O>,</span><span class=C> v</span><span class=E>[</span><span class=M>2</span><span class=E>]<br></span><span class=A>    </span><span class=C>M</span><span class=E>[</span><span class=C>alias</span><span class=E>]</span><span class=D> =</span><span class=C> M</span><span class=E>[</span><span class=C>funcname</span><span class=E>]<br><br></span><span class=A>    </span><span class=N>if</span><span class=C> EXPORT_ASSERT_TO_GLOBALS</span><span class=N> then<br></span><span class=A>        </span><span class=C>_G</span><span class=E>[</span><span class=C>funcname</span><span class=E>]</span><span class=D> =</span><span class=C> M</span><span class=E>[</span><span class=C>funcname</span><span class=E>]<br></span><span class=A>        </span><span class=C>_G</span><span class=E>[</span><span class=C>alias</span><span class=E>]</span><span class=D> =</span><span class=C> M</span><span class=E>[</span><span class=C>funcname</span><span class=E>]<br></span><span class=N>    end<br>end<br><br></span><span class=A>----------------------------------------------------------------<br>--<br>--                     Outputters<br>--<br>----------------------------------------------------------------<br><br>-- A common &#34;base&#34; class for outputters<br>-- For concepts involved (class inheritance) see http://www.lua.org/pil/16.2.html<br><br></span><span class=G>local</span><span class=C> genericOutput</span><span class=D> =</span><span class=E> {</span><span class=P> __class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>genericOutput</span><span class=B>&#39;</span><span class=E> }</span><span class=A> -- class<br></span><span class=G>local</span><span class=C> genericOutput_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> genericOutput</span><span class=E> }</span><span class=A> -- metatable<br></span><span class=C>M</span><span class=H>.</span><span class=C>genericOutput</span><span class=D> =</span><span class=C> genericOutput</span><span class=A> -- publish, so that custom classes may derive from it<br><br></span><span class=K>function</span><span class=C> genericOutput.new</span><span class=E>(</span><span class=C>runner</span><span class=O>,</span><span class=C> default_verbosity</span><span class=E>)<br></span><span class=A>    -- runner is the &#34;parent&#34; object controlling the output, usually a LuaUnit instance<br>    </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=E> {</span><span class=P> runner</span><span class=D> =</span><span class=C> runner</span><span class=E> }<br></span><span class=A>    </span><span class=N>if</span><span class=C> runner</span><span class=N> then<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>result</span><span class=D> =</span><span class=C> runner</span><span class=H>.</span><span class=C>result<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>verbosity</span><span class=D> =</span><span class=C> runner</span><span class=H>.</span><span class=C>verbosity</span><span class=J> or</span><span class=C> default_verbosity<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>fname</span><span class=D> =</span><span class=C> runner</span><span class=H>.</span><span class=C>fname<br></span><span class=N>    else<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>verbosity</span><span class=D> =</span><span class=C> default_verbosity<br></span><span class=N>    end<br></span><span class=K>    return</span><span class=A> </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> genericOutput_MT</span><span class=E>)<br></span><span class=K>end<br><br></span><span class=A>-- abstract (&#34;empty&#34;) methods<br></span><span class=K>function</span><span class=C> genericOutput:startSuite</span><span class=E>()</span><span class=A> <br>    -- Called once, when the suite is started<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:startClass</span><span class=E>(</span><span class=C>className</span><span class=E>)</span><span class=A> <br>    -- Called each time a new test class is started<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:startTest</span><span class=E>(</span><span class=C>testName</span><span class=E>)</span><span class=A> <br>    -- called each time a new test is started, right before the setUp()<br>    -- the current test status node is already created and available in: self.result.currentNode<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:updateStatus</span><span class=E>(</span><span class=C>node</span><span class=E>)</span><span class=A> <br>    -- called with status failed or error as soon as the error/failure is encountered<br>    -- this method is NOT called for a successful test because a test is marked as successful by default<br>    -- and does not need to be updated<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:endTest</span><span class=E>(</span><span class=C>node</span><span class=E>)</span><span class=A> <br>    -- called when the test is finished, after the tearDown() method<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:endClass</span><span class=E>()</span><span class=A> <br>    -- called when executing the class is finished, before moving on to the next class of at the end of the test execution<br></span><span class=K>end<br><br>function</span><span class=C> genericOutput:endSuite</span><span class=E>()</span><span class=A> <br>    -- called at the end of the test suite execution<br></span><span class=K>end<br><br><br></span><span class=A>----------------------------------------------------------------<br>--                     class TapOutput<br>----------------------------------------------------------------<br><br></span><span class=G>local</span><span class=C> TapOutput</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>()</span><span class=A> -- derived class<br></span><span class=G>local</span><span class=C> TapOutput_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> TapOutput</span><span class=E> }</span><span class=A> -- metatable<br></span><span class=C>TapOutput</span><span class=H>.</span><span class=C>__class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>TapOutput</span><span class=B>&#39;<br><br></span><span class=A>    -- For a good reference for TAP format, check: http://testanything.org/tap-specification.html<br><br>    </span><span class=K>function</span><span class=C> TapOutput.new</span><span class=E>(</span><span class=C>runner</span><span class=E>)<br></span><span class=A>        </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>(</span><span class=C>runner</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_LOW</span><span class=E>)<br></span><span class=K>        return</span><span class=A> </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> TapOutput_MT</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br></span><span class=A>    </span><span class=K>function</span><span class=C> TapOutput:startSuite</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>1..</span><span class=B>&#34;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>selectedCount</span><span class=E>)<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># Started on </span><span class=B>&#39;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>startDate</span><span class=E>)<br></span><span class=K>    end<br></span><span class=A>    </span><span class=K>function</span><span class=C> TapOutput:startClass</span><span class=E>(</span><span class=C>className</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> className</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F>[TestFunctions]</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># Starting class: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>className</span><span class=E>)<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TapOutput:updateStatus</span><span class=E>(</span><span class=C> node</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isSkipped</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>ok </span><span class=B>&#34;</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\t# SKIP </span><span class=B>&#34;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=E> )<br></span><span class=K>            return<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=A>        </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>not ok </span><span class=B>&#34;</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\t</span><span class=B>&#34;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>testName</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_LOW</span><span class=N> then<br></span><span class=A>           </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>prefixString</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   </span><span class=B>&#39;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=E> ) )<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=E> (</span><span class=C>node</span><span class=H>:</span><span class=C>isFailure</span><span class=E>()</span><span class=J> or</span><span class=C> node</span><span class=H>:</span><span class=C>isError</span><span class=E>())</span><span class=I> and</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>           </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>prefixString</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   </span><span class=B>&#39;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>stackTrace</span><span class=E> ) )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TapOutput:endTest</span><span class=E>(</span><span class=C> node</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>ok     </span><span class=B>&#34;</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\t</span><span class=B>&#34;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>testName</span><span class=O>,</span><span class=B> &#34;</span><span class=F>\n</span><span class=B>&#34;</span><span class=E>)<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TapOutput:endSuite</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F># </span><span class=B>&#39;</span><span class=E>..</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>statusLine</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=E> ) )<br></span><span class=K>        return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount<br></span><span class=R>    </span><span class=K>end<br><br><br></span><span class=A>-- class TapOutput end<br><br>----------------------------------------------------------------<br>--                     class JUnitOutput<br>----------------------------------------------------------------<br><br>-- See directory junitxml for more information about the junit format<br></span><span class=G>local</span><span class=C> JUnitOutput</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>()</span><span class=A> -- derived class<br></span><span class=G>local</span><span class=C> JUnitOutput_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> JUnitOutput</span><span class=E> }</span><span class=A> -- metatable<br></span><span class=C>JUnitOutput</span><span class=H>.</span><span class=C>__class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>JUnitOutput</span><span class=B>&#39;<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput.new</span><span class=E>(</span><span class=C>runner</span><span class=E>)<br></span><span class=A>        </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>(</span><span class=C>runner</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_LOW</span><span class=E>)<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>testList</span><span class=D> =</span><span class=E> {}<br></span><span class=K>        return</span><span class=A> </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> JUnitOutput_MT</span><span class=E> )<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput:startSuite</span><span class=E>()<br></span><span class=A>        -- open xml file early to deal with errors<br>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>fname</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>With Junit, an output filename must be supplied with --name!</span><span class=B>&#39;</span><span class=E>)<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=C> string</span><span class=H>.</span><span class=C>sub</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=O>,</span><span class=E>-</span><span class=M>4</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>.xml</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>fname</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.xml</span><span class=B>&#39;<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=D> =</span><span class=C> io</span><span class=H>.</span><span class=C>open</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=O>,</span><span class=B> &#34;</span><span class=F>w</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>fd</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#34;</span><span class=F>Could not open file for writing: </span><span class=B>&#34;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># XML output to </span><span class=B>&#39;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=E>)<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># Started on </span><span class=B>&#39;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>startDate</span><span class=E>)<br></span><span class=K>    end<br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput:startClass</span><span class=E>(</span><span class=C>className</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> className</span><span class=E> ~=</span><span class=B> &#39;</span><span class=F>[TestFunctions]</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># Starting class: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>className</span><span class=E>)<br></span><span class=N>        end<br></span><span class=K>    end<br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput:startTest</span><span class=E>(</span><span class=C>testName</span><span class=E>)<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F># Starting test: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>testName</span><span class=E>)<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput:updateStatus</span><span class=E>(</span><span class=C> node</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isFailure</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   Failure: </span><span class=B>&#39;</span><span class=E> ..</span><span class=C> prefixString</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   </span><span class=B>&#39;</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=E> )</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>4</span><span class=O>,</span><span class=L> nil</span><span class=E>) )<br></span><span class=C565662>            -- print(&#39;# &#39; .. node.stackTrace)<br></span><span class=N>        elseif</span><span class=C> node</span><span class=H>:</span><span class=C>isError</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   Error: </span><span class=B>&#39;</span><span class=E> ..</span><span class=C> prefixString</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>#   </span><span class=B>&#39;</span><span class=O>  ,</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=E> )</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>4</span><span class=O>,</span><span class=L> nil</span><span class=E>) )<br></span><span class=C565662>            -- print(&#39;# &#39; .. node.stackTrace)<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> JUnitOutput:endSuite</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F># </span><span class=B>&#39;</span><span class=E>..</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>statusLine</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=E>))<br><br></span><span class=A>        -- XML file writing<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&lt;testsuites&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(<br></span><span class=A>            </span><span class=B>&#39;</span><span class=F>    &lt;testsuite name=&#34;LuaUnit&#34; id=&#34;00001&#34; package=&#34;&#34; hostname=&#34;localhost&#34; tests=&#34;%d&#34; timestamp=&#34;%s&#34; time=&#34;%0.3f&#34; errors=&#34;%d&#34; failures=&#34;%d&#34; skipped=&#34;%d&#34;&gt;\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>            self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>runCount</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>startIsodate</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>duration</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorCount</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failureCount</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>skippedCount</span><span class=E> ))<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>        &lt;properties&gt;\n</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>            &lt;property name=&#34;Lua Version&#34; value=&#34;%s&#34;/&gt;\n</span><span class=B>&#39;</span><span class=O>,</span><span class=C> _VERSION</span><span class=E> ) )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>            &lt;property name=&#34;LuaUnit Version&#34; value=&#34;%s&#34;/&gt;\n</span><span class=B>&#39;</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>VERSION</span><span class=E>) )<br></span><span class=A>        -- XXX please include system name and version if possible<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>        &lt;/properties&gt;\n</span><span class=B>&#34;</span><span class=E>)<br><br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C>node</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>allTests</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>        &lt;testcase classname=&#34;%s&#34; name=&#34;%s&#34; time=&#34;%0.3f&#34;&gt;\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                node</span><span class=H>.</span><span class=C>className</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>testName</span><span class=O>,</span><span class=C> node</span><span class=H>.</span><span class=C>duration</span><span class=E> ) )<br></span><span class=A>            </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isNotSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>node</span><span class=H>:</span><span class=C>statusXML</span><span class=E>())<br></span><span class=N>            end<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>        &lt;/testcase&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=A>        -- Next two lines are needed to validate junit ANT xsd, but really not useful in general:<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>    &lt;system-out/&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>    &lt;system-err/&gt;\n</span><span class=B>&#39;</span><span class=E>)<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>    &lt;/testsuite&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#39;</span><span class=F>&lt;/testsuites&gt;\n</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>fd</span><span class=H>:</span><span class=C>close</span><span class=E>()<br></span><span class=K>        return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount<br></span><span class=R>    </span><span class=K>end<br><br><br></span><span class=A>-- class TapOutput end<br><br>----------------------------------------------------------------<br>--                     class TextOutput<br>----------------------------------------------------------------<br><br>--[[    Example of other unit-tests suite text output<br><br>-- Python Non verbose:<br><br>For each test: . or F or E<br><br>If some failed tests:<br>    ==============<br>    ERROR / FAILURE: TestName (testfile.testclass)<br>    ---------<br>    Stack trace<br><br><br>then --------------<br>then &#34;Ran x tests in 0.000s&#34;<br>then OK or FAILED (failures=1, error=1)<br><br>-- Python Verbose:<br>testname (filename.classname) ... ok<br>testname (filename.classname) ... FAIL<br>testname (filename.classname) ... ERROR<br><br>then --------------<br>then &#34;Ran x tests in 0.000s&#34;<br>then OK or FAILED (failures=1, error=1)<br><br>-- Ruby:<br>Started<br> .<br> Finished in 0.002695 seconds.<br><br> 1 tests, 2 assertions, 0 failures, 0 errors<br><br>-- Ruby:<br>&gt;&gt; ruby tc_simple_number2.rb<br>Loaded suite tc_simple_number2<br>Started<br>F..<br>Finished in 0.038617 seconds.<br><br>  1) Failure:<br>test_failure(TestSimpleNumber) [tc_simple_number2.rb:16]:<br>Adding doesn&#39;t work.<br>&lt;3&gt; expected but was<br>&lt;4&gt;.<br><br>3 tests, 4 assertions, 1 failures, 0 errors<br><br>-- Java Junit<br>.......F.<br>Time: 0,003<br>There was 1 failure:<br>1) testCapacity(junit.samples.VectorTest)junit.framework.AssertionFailedError<br>    at junit.samples.VectorTest.testCapacity(VectorTest.java:87)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br><br>FAILURES!!!<br>Tests run: 8,  Failures: 1,  Errors: 0<br><br><br>-- Maven<br><br># mvn test<br>-------------------------------------------------------<br> T E S T S<br>-------------------------------------------------------<br>Running math.AdditionTest<br>Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed:<br>0.03 sec &lt;&lt;&lt; FAILURE!<br><br>Results :<br><br>Failed tests:<br>  testLireSymbole(math.AdditionTest)<br><br>Tests run: 2, Failures: 1, Errors: 0, Skipped: 0<br><br><br>-- LuaUnit<br>---- non verbose<br>* display . or F or E when running tests<br>---- verbose<br>* display test name + ok/fail<br>----<br>* blank line<br>* number) ERROR or FAILURE: TestName<br>   Stack trace<br>* blank line<br>* number) ERROR or FAILURE: TestName<br>   Stack trace<br><br>then --------------<br>then &#34;Ran x tests in 0.000s (%d not selected, %d skipped)&#34;<br>then OK or FAILED (failures=1, error=1)<br><br><br>]]<br><br></span><span class=G>local</span><span class=C> TextOutput</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>()</span><span class=A> -- derived class<br></span><span class=G>local</span><span class=C> TextOutput_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> TextOutput</span><span class=E> }</span><span class=A> -- metatable<br></span><span class=C>TextOutput</span><span class=H>.</span><span class=C>__class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>TextOutput</span><span class=B>&#39;<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput.new</span><span class=E>(</span><span class=C>runner</span><span class=E>)<br></span><span class=A>        </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=C> genericOutput</span><span class=H>.</span><span class=C>new</span><span class=E>(</span><span class=C>runner</span><span class=O>,</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=E>)<br></span><span class=A>        </span><span class=C>t</span><span class=H>.</span><span class=C>errorList</span><span class=D> =</span><span class=E> {}<br></span><span class=K>        return</span><span class=A> </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> TextOutput_MT</span><span class=E> )<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:startSuite</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>Started on </span><span class=B>&#39;</span><span class=E>..</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>startDate</span><span class=E> )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:startTest</span><span class=E>(</span><span class=C>testName</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>            </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>    </span><span class=B>&#34;</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode</span><span class=H>.</span><span class=C>testName</span><span class=O>,</span><span class=B> &#34;</span><span class=F> ... </span><span class=B>&#34;</span><span class=E> )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:endTest</span><span class=E>(</span><span class=C> node</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>                </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>Ok\n</span><span class=B>&#34;</span><span class=E>)<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=B>&#34;</span><span class=F>.</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>                </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>flush</span><span class=E>()<br></span><span class=N>            end<br>        else<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>                </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>node</span><span class=H>.</span><span class=C>status</span><span class=E> )<br></span><span class=A>                </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>node</span><span class=H>.</span><span class=C>msg</span><span class=E> )<br></span><span class=C565662>                --[[<br>                -- find out when to do this:<br>                if self.verbosity &gt; M.VERBOSITY_DEFAULT then<br>                    print( node.stackTrace )<br>                end<br>                ]]<br></span><span class=N>            else<br></span><span class=A>                -- write only the first character of status E, F or S<br>                </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>write</span><span class=E>(</span><span class=C>string</span><span class=H>.</span><span class=C>sub</span><span class=E>(</span><span class=C>node</span><span class=H>.</span><span class=C>status</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=M> 1</span><span class=E>))<br></span><span class=A>                </span><span class=C>io</span><span class=H>.</span><span class=C>stdout</span><span class=H>:</span><span class=C>flush</span><span class=E>()<br></span><span class=N>            end<br>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:displayOneFailedTest</span><span class=E>(</span><span class=C> index</span><span class=O>,</span><span class=C> fail</span><span class=E> )<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=C>index</span><span class=E>..</span><span class=B>&#34;</span><span class=F>) </span><span class=B>&#34;</span><span class=E>..</span><span class=C>fail</span><span class=H>.</span><span class=C>testName</span><span class=E> )<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>fail</span><span class=H>.</span><span class=C>msg</span><span class=E> )<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>fail</span><span class=H>.</span><span class=C>stackTrace</span><span class=E> )<br></span><span class=A>        </span><span class=C>print</span><span class=E>()<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:displayErroredTests</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=E> #</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorTests</span><span class=E> ~=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>Tests with errors:</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>------------------</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>            </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorTests</span><span class=E>)</span><span class=N> do<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>displayOneFailedTest</span><span class=E>(</span><span class=C>i</span><span class=O>,</span><span class=C> v</span><span class=E>)<br></span><span class=N>            end<br>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:displayFailedTests</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=E> #</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failedTests</span><span class=E> ~=</span><span class=M> 0</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>Failed tests:</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>-------------</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>            </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failedTests</span><span class=E>)</span><span class=N> do<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>displayOneFailedTest</span><span class=E>(</span><span class=C>i</span><span class=O>,</span><span class=C> v</span><span class=E>)<br></span><span class=N>            end<br>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> TextOutput:endSuite</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>verbosity</span><span class=E> &gt;</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>=========================================================</span><span class=B>&#34;</span><span class=E>)<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>print</span><span class=E>()<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>displayErroredTests</span><span class=E>()<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>displayFailedTests</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>statusLine</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=E> ) )<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount</span><span class=E> ==</span><span class=M> 0</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F>OK</span><span class=B>&#39;</span><span class=E>)<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>-- class TextOutput end<br><br><br>----------------------------------------------------------------<br>--                     class NilOutput<br>----------------------------------------------------------------<br><br></span><span class=K>local function</span><span class=C> nopCallable</span><span class=E>()<br></span><span class=A>    --print(42)<br>    </span><span class=K>return</span><span class=A> </span><span class=C>nopCallable<br></span><span class=K>end<br><br></span><span class=G>local</span><span class=C> NilOutput</span><span class=D> =</span><span class=E> {</span><span class=P> __class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>NilOuptut</span><span class=B>&#39;</span><span class=E> }</span><span class=A> -- class<br></span><span class=G>local</span><span class=C> NilOutput_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> nopCallable</span><span class=E> }</span><span class=A> -- metatable<br><br></span><span class=K>function</span><span class=C> NilOutput.new</span><span class=E>(</span><span class=C>runner</span><span class=E>)<br></span><span class=A>    </span><span class=K>return</span><span class=A> </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=E>{</span><span class=P> __class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>NilOutput</span><span class=B>&#39;</span><span class=E> }</span><span class=O>,</span><span class=C> NilOutput_MT</span><span class=E> )<br></span><span class=K>end<br><br></span><span class=A>----------------------------------------------------------------<br>--<br>--                     class LuaUnit<br>--<br>----------------------------------------------------------------<br><br></span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=D> =</span><span class=E> {<br></span><span class=P>    outputType</span><span class=D> =</span><span class=C> TextOutput</span><span class=O>,<br></span><span class=P>    verbosity</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_DEFAULT</span><span class=O>,<br></span><span class=P>    __class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>LuaUnit</span><span class=B>&#39;</span><span class=O>,<br></span><span class=P>    instances</span><span class=D> =</span><span class=E> {}<br>}<br></span><span class=G>local</span><span class=C> LuaUnit_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=E> }<br><br></span><span class=N>if</span><span class=C> EXPORT_ASSERT_TO_GLOBALS</span><span class=N> then<br></span><span class=A>    </span><span class=C>LuaUnit</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit<br></span><span class=N>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.new</span><span class=E>()<br></span><span class=A>        </span><span class=G>local</span><span class=C> newInstance</span><span class=D> =</span><span class=C> setmetatable</span><span class=E>(</span><span class=A> </span><span class=E>{}</span><span class=O>,</span><span class=C> LuaUnit_MT</span><span class=E> )<br></span><span class=K>        return</span><span class=A> </span><span class=C>newInstance<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    -----------------[[ Utility methods ]]---------------------<br><br>    </span><span class=K>function</span><span class=C> M.LuaUnit.asFunction</span><span class=E>(</span><span class=C>aObject</span><span class=E>)<br></span><span class=A>        -- return &#34;aObject&#34; if it is a function, and nil otherwise<br>        </span><span class=N>if</span><span class=B> &#39;</span><span class=F>function</span><span class=B>&#39;</span><span class=E> ==</span><span class=C> type</span><span class=E>(</span><span class=C>aObject</span><span class=E>)</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>aObject<br></span><span class=R>        </span><span class=N>end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.splitClassMethod</span><span class=E>(</span><span class=C>someName</span><span class=E>)<br></span><span class=A>        --[[<br>        Return a pair of className, methodName strings for a name in the form<br>        &#34;class.method&#34;. If no class part (or separator) is found, will return<br>        nil, someName instead (the latter being unchanged).<br><br>        This convention thus also replaces the older isClassMethod() test:<br>        You just have to check for a non-nil className (return) value.<br>        ]]<br>        </span><span class=G>local</span><span class=C> separator</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>find</span><span class=E>(</span><span class=C>someName</span><span class=O>,</span><span class=B> &#39;</span><span class=F>.</span><span class=B>&#39;</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=L> true</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> separator</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>someName</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>1</span><span class=O>,</span><span class=C> separator</span><span class=E> -</span><span class=M> 1</span><span class=E>)</span><span class=O>,</span><span class=C> someName</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=C>separator</span><span class=E> +</span><span class=M> 1</span><span class=E>)<br></span><span class=R>        </span><span class=N>end<br></span><span class=K>        return</span><span class=A> </span><span class=L>nil</span><span class=O>,</span><span class=C> someName<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.isMethodTestName</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>        -- return true is the name matches the name of a test method<br>        -- default rule is that is starts with &#39;Test&#39; or with &#39;test&#39;<br>        </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>sub</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=M> 4</span><span class=E>)</span><span class=H>:</span><span class=C>lower</span><span class=E>() ==</span><span class=B> &#39;</span><span class=F>test</span><span class=B>&#39;<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.isTestName</span><span class=E>(</span><span class=C> s</span><span class=E> )<br></span><span class=A>        -- return true is the name matches the name of a test<br>        -- default rule is that is starts with &#39;Test&#39; or with &#39;test&#39;<br>        </span><span class=K>return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>sub</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=M> 1</span><span class=O>,</span><span class=M> 4</span><span class=E>)</span><span class=H>:</span><span class=C>lower</span><span class=E>() ==</span><span class=B> &#39;</span><span class=F>test</span><span class=B>&#39;<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.collectTests</span><span class=E>()<br></span><span class=A>        -- return a list of all test names in the global namespace<br>        -- that match LuaUnit.isTestName<br><br>        </span><span class=G>local</span><span class=C> testNames</span><span class=D> =</span><span class=E> {}<br></span><span class=A>        </span><span class=N>for</span><span class=C> k</span><span class=O>,</span><span class=C> _</span><span class=N> in</span><span class=C> pairs</span><span class=E>(</span><span class=C>_G</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>k</span><span class=E>) ==</span><span class=B> &#34;</span><span class=F>string</span><span class=B>&#34;</span><span class=I> and</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>isTestName</span><span class=E>(</span><span class=A> </span><span class=C>k</span><span class=E> )</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>testNames</span><span class=O> ,</span><span class=C> k</span><span class=E> )<br></span><span class=N>            end<br>        end<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>sort</span><span class=E>(</span><span class=A> </span><span class=C>testNames</span><span class=E> )<br></span><span class=K>        return</span><span class=A> </span><span class=C>testNames<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.parseCmdLine</span><span class=E>(</span><span class=C> cmdLine</span><span class=E> )<br></span><span class=A>        -- parse the command line<br>        -- Supported command line parameters:<br>        -- --verbose, -v: increase verbosity<br>        -- --quiet, -q: silence output<br>        -- --error, -e: treat errors as fatal (quit program)<br>        -- --output, -o, + name: select output type<br>        -- --pattern, -p, + pattern: run test matching pattern, may be repeated<br>        -- --exclude, -x, + pattern: run test not matching pattern, may be repeated<br>        -- --shuffle, -s, : shuffle tests before reunning them<br>        -- --name, -n, + fname: name of output file for junit, default to stdout<br>        -- --repeat, -r, + num: number of times to execute each test<br>        -- [testnames, ...]: run selected test names<br>        --<br>        -- Returns a table with the following fields:<br>        -- verbosity: nil, M.VERBOSITY_DEFAULT, M.VERBOSITY_QUIET, M.VERBOSITY_VERBOSE<br>        -- output: nil, &#39;tap&#39;, &#39;junit&#39;, &#39;text&#39;, &#39;nil&#39;<br>        -- testNames: nil or a list of test names to run<br>        -- exeRepeat: num or 1<br>        -- pattern: nil or a list of patterns<br>        -- exclude: nil or a list of patterns<br><br>        </span><span class=G>local</span><span class=C> result</span><span class=O>,</span><span class=C> state</span><span class=D> =</span><span class=E> {}</span><span class=O>,</span><span class=L> nil<br></span><span class=A>        </span><span class=G>local</span><span class=C> SET_OUTPUT</span><span class=D> =</span><span class=M> 1<br></span><span class=A>        </span><span class=G>local</span><span class=C> SET_PATTERN</span><span class=D> =</span><span class=M> 2<br></span><span class=A>        </span><span class=G>local</span><span class=C> SET_EXCLUDE</span><span class=D> =</span><span class=M> 3<br></span><span class=A>        </span><span class=G>local</span><span class=C> SET_FNAME</span><span class=D> =</span><span class=M> 4<br></span><span class=A>        </span><span class=G>local</span><span class=C> SET_REPEAT</span><span class=D> =</span><span class=M> 5<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> cmdLine</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>result<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=A>        </span><span class=K>local function</span><span class=C> parseOption</span><span class=E>(</span><span class=C> option</span><span class=E> )<br></span><span class=A>            </span><span class=N>if</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--help</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-h</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>help</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=L> true<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--version</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>version</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=L> true<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--verbose</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-v</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>verbosity</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_VERBOSE<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--quiet</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-q</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>verbosity</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>VERBOSITY_QUIET<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--error</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-e</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>quitOnError</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=L> true<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--failure</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-f</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>quitOnFailure</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=L> true<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--shuffle</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-s</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>shuffle</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=L> true<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--output</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-o</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=C> SET_OUTPUT<br></span><span class=K>                return</span><span class=A> </span><span class=C>state<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--name</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-n</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=C> SET_FNAME<br></span><span class=K>                return</span><span class=A> </span><span class=C>state<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--repeat</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-r</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=C> SET_REPEAT<br></span><span class=K>                return</span><span class=A> </span><span class=C>state<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--pattern</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-p</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=C> SET_PATTERN<br></span><span class=K>                return</span><span class=A> </span><span class=C>state<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>--exclude</span><span class=B>&#39;</span><span class=J> or</span><span class=C> option</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>-x</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=C> SET_EXCLUDE<br></span><span class=K>                return</span><span class=A> </span><span class=C>state<br></span><span class=R>            </span><span class=N>end<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>Unknown option: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>option</span><span class=O>,</span><span class=M>3</span><span class=E>)<br></span><span class=K>        end<br><br></span><span class=A>        </span><span class=K>local function</span><span class=C> setArg</span><span class=E>(</span><span class=C> cmdArg</span><span class=O>,</span><span class=C> state</span><span class=E> )<br></span><span class=A>            </span><span class=N>if</span><span class=C> state</span><span class=E> ==</span><span class=C> SET_OUTPUT</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>output</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=C> cmdArg<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> state</span><span class=E> ==</span><span class=C> SET_FNAME</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>fname</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=C> cmdArg<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> state</span><span class=E> ==</span><span class=C> SET_REPEAT</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>exeRepeat</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=C> tonumber</span><span class=E>(</span><span class=C>cmdArg</span><span class=E>)<br></span><span class=J>                                     or</span><span class=C> error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>Malformed -r argument: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>cmdArg</span><span class=E>)<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> state</span><span class=E> ==</span><span class=C> SET_PATTERN</span><span class=N> then<br></span><span class=A>                </span><span class=N>if</span><span class=C> result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=N> then<br></span><span class=A>                    </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=O>,</span><span class=C> cmdArg</span><span class=E> )<br></span><span class=N>                else<br></span><span class=A>                    </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=E> {</span><span class=A> </span><span class=C>cmdArg</span><span class=E> }<br></span><span class=N>                end<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>elseif</span><span class=C> state</span><span class=E> ==</span><span class=C> SET_EXCLUDE</span><span class=N> then<br></span><span class=A>                </span><span class=G>local</span><span class=C> notArg</span><span class=D> =</span><span class=B> &#39;</span><span class=F>!</span><span class=B>&#39;</span><span class=E>..</span><span class=C>cmdArg<br></span><span class=A>                </span><span class=N>if</span><span class=C> result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=N> then<br></span><span class=A>                    </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=O>,</span><span class=C>  notArg</span><span class=E> )<br></span><span class=N>                else<br></span><span class=A>                    </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>pattern</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=E> {</span><span class=A> </span><span class=C>notArg</span><span class=E> }<br></span><span class=N>                end<br></span><span class=K>                return<br></span><span class=R>            </span><span class=N>end<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>Unknown parse state: </span><span class=B>&#39;</span><span class=E>..</span><span class=C> state</span><span class=E>)<br></span><span class=K>        end<br><br><br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C> cmdArg</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>cmdLine</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> state</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=C>setArg</span><span class=E>(</span><span class=A> </span><span class=C>cmdArg</span><span class=O>,</span><span class=C> state</span><span class=O>,</span><span class=C> result</span><span class=E> )<br></span><span class=A>                </span><span class=C>state</span><span class=D> =</span><span class=L> nil<br></span><span class=N>            else<br></span><span class=A>                </span><span class=N>if</span><span class=C> cmdArg</span><span class=H>:</span><span class=C>sub</span><span class=E>(</span><span class=M>1</span><span class=O>,</span><span class=M>1</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>-</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                    </span><span class=C>state</span><span class=D> =</span><span class=C> parseOption</span><span class=E>(</span><span class=A> </span><span class=C>cmdArg</span><span class=E> )<br></span><span class=N>                else<br></span><span class=A>                    </span><span class=N>if</span><span class=C> result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>testNames</span><span class=B>&#39;</span><span class=E>]</span><span class=N> then<br></span><span class=A>                        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>testNames</span><span class=B>&#39;</span><span class=E>]</span><span class=O>,</span><span class=C> cmdArg</span><span class=E> )<br></span><span class=N>                    else<br></span><span class=A>                        </span><span class=C>result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>testNames</span><span class=B>&#39;</span><span class=E>]</span><span class=D> =</span><span class=E> {</span><span class=A> </span><span class=C>cmdArg</span><span class=E> }<br></span><span class=N>                    end<br>                end<br>            end<br>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>help</span><span class=B>&#39;</span><span class=E>]</span><span class=N> then<br></span><span class=A>            </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>help</span><span class=E>()<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> result</span><span class=E>[</span><span class=B>&#39;</span><span class=F>version</span><span class=B>&#39;</span><span class=E>]</span><span class=N> then<br></span><span class=A>            </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>version</span><span class=E>()<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> state</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>Missing argument after </span><span class=B>&#39;</span><span class=E>..</span><span class=C>cmdLine</span><span class=E>[ #</span><span class=C>cmdLine</span><span class=E> ]</span><span class=O>,</span><span class=M>2</span><span class=E> )<br></span><span class=N>        end<br><br></span><span class=K>        return</span><span class=A> </span><span class=C>result<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.help</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>USAGE</span><span class=E>)<br></span><span class=A>        </span><span class=C>os</span><span class=H>.</span><span class=C>exit</span><span class=E>(</span><span class=M>0</span><span class=E>)<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.version</span><span class=E>()<br></span><span class=A>        </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F>LuaUnit v</span><span class=B>&#39;</span><span class=E>..</span><span class=C>M</span><span class=H>.</span><span class=C>VERSION</span><span class=E>..</span><span class=B>&#39;</span><span class=F> by Philippe Fremy &lt;phil@freehackers.org&gt;</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>os</span><span class=H>.</span><span class=C>exit</span><span class=E>(</span><span class=M>0</span><span class=E>)<br></span><span class=K>    end<br><br></span><span class=A>----------------------------------------------------------------<br>--                     class NodeStatus<br>----------------------------------------------------------------<br><br>    </span><span class=G>local</span><span class=C> NodeStatus</span><span class=D> =</span><span class=E> {</span><span class=P> __class__</span><span class=D> =</span><span class=B> &#39;</span><span class=F>NodeStatus</span><span class=B>&#39;</span><span class=E> }</span><span class=A> -- class<br>    </span><span class=G>local</span><span class=C> NodeStatus_MT</span><span class=D> =</span><span class=E> {</span><span class=P> __index</span><span class=D> =</span><span class=C> NodeStatus</span><span class=E> }</span><span class=A> -- metatable<br>    </span><span class=C>M</span><span class=H>.</span><span class=C>NodeStatus</span><span class=D> =</span><span class=C> NodeStatus<br><br></span><span class=A>    -- values of status<br>    </span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>SUCCESS</span><span class=D>  =</span><span class=B> &#39;</span><span class=F>SUCCESS</span><span class=B>&#39;<br></span><span class=A>    </span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>SKIP</span><span class=D>     =</span><span class=B> &#39;</span><span class=F>SKIP</span><span class=B>&#39;<br></span><span class=A>    </span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>FAIL</span><span class=D>     =</span><span class=B> &#39;</span><span class=F>FAIL</span><span class=B>&#39;<br></span><span class=A>    </span><span class=C>NodeStatus</span><span class=H>.</span><span class=C>ERROR</span><span class=D>    =</span><span class=B> &#39;</span><span class=F>ERROR</span><span class=B>&#39;<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus.new</span><span class=E>(</span><span class=C> number</span><span class=O>,</span><span class=C> testName</span><span class=O>,</span><span class=C> className</span><span class=E> )<br></span><span class=A>        -- default constructor, test are PASS by default<br>        </span><span class=G>local</span><span class=C> t</span><span class=D> =</span><span class=E> {</span><span class=P> number</span><span class=D> =</span><span class=C> number</span><span class=O>,</span><span class=P> testName</span><span class=D> =</span><span class=C> testName</span><span class=O>,</span><span class=P> className</span><span class=D> =</span><span class=C> className</span><span class=E> }<br></span><span class=A>        </span><span class=C>setmetatable</span><span class=E>(</span><span class=A> </span><span class=C>t</span><span class=O>,</span><span class=C> NodeStatus_MT</span><span class=E> )<br></span><span class=A>        </span><span class=C>t</span><span class=H>:</span><span class=C>success</span><span class=E>()<br></span><span class=K>        return</span><span class=A> </span><span class=C>t<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:success</span><span class=E>()<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>SUCCESS<br></span><span class=A>        -- useless because lua does this for us, but it helps me remembering the relevant field names<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=D> =</span><span class=L> nil<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=D> =</span><span class=L> nil<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:skip</span><span class=E>(</span><span class=C>msg</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>SKIP<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=D> =</span><span class=C> msg<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=D> =</span><span class=L> nil<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:fail</span><span class=E>(</span><span class=C>msg</span><span class=O>,</span><span class=C> stackTrace</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>FAIL<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=D> =</span><span class=C> msg<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=D> =</span><span class=C> stackTrace<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:error</span><span class=E>(</span><span class=C>msg</span><span class=O>,</span><span class=C> stackTrace</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>ERROR<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=D> =</span><span class=C> msg<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=D> =</span><span class=C> stackTrace<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:isSuccess</span><span class=E>()<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SUCCESS<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:isNotSuccess</span><span class=E>()<br></span><span class=A>        -- Return true if node is either failure or error or skip<br>        </span><span class=K>return</span><span class=A> </span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>FAIL</span><span class=J> or</span><span class=C> self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>ERROR</span><span class=J> or</span><span class=C> self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SKIP</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:isSkipped</span><span class=E>()<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SKIP<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:isFailure</span><span class=E>()<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>FAIL<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:isError</span><span class=E>()<br></span><span class=A>        </span><span class=K>return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>ERROR<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> NodeStatus:statusXML</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>:</span><span class=C>isError</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(<br></span><span class=A>                </span><span class=E>{</span><span class=B>&#39;</span><span class=F>            &lt;error type=&#34;</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=C>xmlEscape</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=E>)</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>&#34;&gt;\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=A>                 </span><span class=B>&#39;</span><span class=F>                &lt;![CDATA[</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=C>xmlCDataEscape</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=E>)</span><span class=O>,<br></span><span class=A>                 </span><span class=B>&#39;</span><span class=F>]]&gt;&lt;/error&gt;\n</span><span class=B>&#39;</span><span class=E>})<br></span><span class=R>        </span><span class=N>elseif</span><span class=C> self</span><span class=H>:</span><span class=C>isFailure</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(<br></span><span class=A>                </span><span class=E>{</span><span class=B>&#39;</span><span class=F>            &lt;failure type=&#34;</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=C>xmlEscape</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=E>)</span><span class=O>,</span><span class=A> </span><span class=B>&#39;</span><span class=F>&#34;&gt;\n</span><span class=B>&#39;</span><span class=O>,<br></span><span class=A>                 </span><span class=B>&#39;</span><span class=F>                &lt;![CDATA[</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=C>xmlCDataEscape</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>stackTrace</span><span class=E>)</span><span class=O>,<br></span><span class=A>                 </span><span class=B>&#39;</span><span class=F>]]&gt;&lt;/failure&gt;\n</span><span class=B>&#39;</span><span class=E>})<br></span><span class=R>        </span><span class=N>elseif</span><span class=C> self</span><span class=H>:</span><span class=C>isSkipped</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>({</span><span class=B>&#39;</span><span class=F>            &lt;skipped&gt;</span><span class=B>&#39;</span><span class=O>,</span><span class=A> </span><span class=C>xmlEscape</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>msg</span><span class=E>)</span><span class=O>,</span><span class=B>&#39;</span><span class=F>&lt;/skipped&gt;\n</span><span class=B>&#39;</span><span class=E> } )<br></span><span class=R>        </span><span class=N>end<br></span><span class=K>        return</span><span class=A> </span><span class=B>&#39;</span><span class=F>            &lt;passed/&gt;\n</span><span class=B>&#39;</span><span class=R> -- (not XSD-compliant! normally shouldn&#39;t get here)<br>    </span><span class=K>end<br><br></span><span class=A>    --------------[[ Output methods ]]-------------------------<br><br>    </span><span class=K>local function</span><span class=C> conditional_plural</span><span class=E>(</span><span class=C>number</span><span class=O>,</span><span class=C> singular</span><span class=E>)<br></span><span class=A>        -- returns a grammatically well-formed string &#34;%d &lt;singular/plural&gt;&#34;<br>        </span><span class=G>local</span><span class=C> suffix</span><span class=D> =</span><span class=B> &#39;&#39;<br></span><span class=A>        </span><span class=N>if</span><span class=C> number</span><span class=E> ~=</span><span class=M> 1</span><span class=N> then</span><span class=A> -- use plural<br>            </span><span class=C>suffix</span><span class=D> =</span><span class=E> (</span><span class=C>singular</span><span class=H>:</span><span class=C>sub</span><span class=E>(-</span><span class=M>2</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>ss</span><span class=B>&#39;</span><span class=E>)</span><span class=I> and</span><span class=B> &#39;</span><span class=F>es</span><span class=B>&#39;</span><span class=J> or</span><span class=B> &#39;</span><span class=F>s</span><span class=B>&#39;<br></span><span class=N>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>%d %s%s</span><span class=B>&#39;</span><span class=O>,</span><span class=C> number</span><span class=O>,</span><span class=C> singular</span><span class=O>,</span><span class=C> suffix</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.statusLine</span><span class=E>(</span><span class=C>result</span><span class=E>)<br></span><span class=A>        -- return status line string according to results<br>        </span><span class=G>local</span><span class=C> s</span><span class=D> =</span><span class=E> {<br></span><span class=A>            </span><span class=C>string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#39;</span><span class=F>Ran %d tests in %0.3f seconds</span><span class=B>&#39;</span><span class=O>,<br></span><span class=C>                          result</span><span class=H>.</span><span class=C>runCount</span><span class=O>,</span><span class=C> result</span><span class=H>.</span><span class=C>duration</span><span class=E>)</span><span class=O>,<br></span><span class=A>            </span><span class=C>conditional_plural</span><span class=E>(</span><span class=C>result</span><span class=H>.</span><span class=C>successCount</span><span class=O>,</span><span class=B> &#39;</span><span class=F>success</span><span class=B>&#39;</span><span class=E>)</span><span class=O>,<br></span><span class=E>        }<br></span><span class=A>        </span><span class=N>if</span><span class=C> result</span><span class=H>.</span><span class=C>notSuccessCount</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> result</span><span class=H>.</span><span class=C>failureCount</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> conditional_plural</span><span class=E>(</span><span class=C>result</span><span class=H>.</span><span class=C>failureCount</span><span class=O>,</span><span class=B> &#39;</span><span class=F>failure</span><span class=B>&#39;</span><span class=E>))<br></span><span class=N>            end<br></span><span class=A>            </span><span class=N>if</span><span class=C> result</span><span class=H>.</span><span class=C>errorCount</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> conditional_plural</span><span class=E>(</span><span class=C>result</span><span class=H>.</span><span class=C>errorCount</span><span class=O>,</span><span class=B> &#39;</span><span class=F>error</span><span class=B>&#39;</span><span class=E>))<br></span><span class=N>            end<br>        else<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>0 failures</span><span class=B>&#39;</span><span class=E>)<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=C> result</span><span class=H>.</span><span class=C>skippedCount</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#34;</span><span class=F>%d skipped</span><span class=B>&#34;</span><span class=O>,</span><span class=C> result</span><span class=H>.</span><span class=C>skippedCount</span><span class=E>))<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=C> result</span><span class=H>.</span><span class=C>nonSelectedCount</span><span class=E> &gt;</span><span class=A> </span><span class=M>0</span><span class=N> then<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=C> string</span><span class=H>.</span><span class=C>format</span><span class=E>(</span><span class=B>&#34;</span><span class=F>%d non-selected</span><span class=B>&#34;</span><span class=O>,</span><span class=C> result</span><span class=H>.</span><span class=C>nonSelectedCount</span><span class=E>))<br></span><span class=N>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>table</span><span class=H>.</span><span class=C>concat</span><span class=E>(</span><span class=C>s</span><span class=O>,</span><span class=B> &#39;</span><span class=F>, </span><span class=B>&#39;</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:startSuite</span><span class=E>(</span><span class=C>selectedCount</span><span class=O>,</span><span class=C> nonSelectedCount</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=D> =</span><span class=E> {<br></span><span class=P>            selectedCount</span><span class=D> =</span><span class=C> selectedCount</span><span class=O>,<br></span><span class=P>            nonSelectedCount</span><span class=D> =</span><span class=C> nonSelectedCount</span><span class=O>,<br></span><span class=P>            successCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            runCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            currentTestNumber</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            currentClassName</span><span class=D> =</span><span class=B> &#34;&#34;</span><span class=O>,<br></span><span class=P>            currentNode</span><span class=D> =</span><span class=L> nil</span><span class=O>,<br></span><span class=P>            suiteStarted</span><span class=D> =</span><span class=L> true</span><span class=O>,<br></span><span class=P>            startTime</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>clock</span><span class=E>()</span><span class=O>,<br></span><span class=P>            startDate</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>date</span><span class=E>(</span><span class=C>os</span><span class=H>.</span><span class=C>getenv</span><span class=E>(</span><span class=B>&#39;</span><span class=F>LUAUNIT_DATEFMT</span><span class=B>&#39;</span><span class=E>))</span><span class=O>,<br></span><span class=P>            startIsodate</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>date</span><span class=E>(</span><span class=B>&#39;</span><span class=F>%Y-%m-%dT%H:%M:%S</span><span class=B>&#39;</span><span class=E>)</span><span class=O>,<br></span><span class=P>            patternIncludeFilter</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>patternIncludeFilter</span><span class=O>,<br><br></span><span class=C565662>            -- list of test node status<br></span><span class=P>            allTests</span><span class=D> =</span><span class=E> {}</span><span class=O>,<br></span><span class=P>            failedTests</span><span class=D> =</span><span class=E> {}</span><span class=O>,<br></span><span class=P>            errorTests</span><span class=D> =</span><span class=E> {}</span><span class=O>,<br></span><span class=P>            skippedTests</span><span class=D> =</span><span class=E> {}</span><span class=O>,<br><br></span><span class=P>            failureCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            errorCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            notSuccessCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=P>            skippedCount</span><span class=D> =</span><span class=M> 0</span><span class=O>,<br></span><span class=E>        }<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>outputType</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>outputType</span><span class=J> or</span><span class=C> TextOutput<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>outputType</span><span class=H>.</span><span class=C>new</span><span class=E>(</span><span class=C>self</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>startSuite</span><span class=E>()<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:startClass</span><span class=E>(</span><span class=C> className</span><span class=O>,</span><span class=C> classInstance</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentClassName</span><span class=D> =</span><span class=C> className<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>startClass</span><span class=E>(</span><span class=A> </span><span class=C>className</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>setupClass</span><span class=E>(</span><span class=A> </span><span class=C>className</span><span class=O>,</span><span class=C> classInstance</span><span class=E> )<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:startTest</span><span class=E>(</span><span class=C> testName</span><span class=E>  )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=E> +</span><span class=M> 1<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>runCount</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>runCount</span><span class=E> +</span><span class=M> 1<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode</span><span class=D> =</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>new</span><span class=E>(<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentTestNumber</span><span class=O>,<br></span><span class=C>            testName</span><span class=O>,<br></span><span class=C>            self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentClassName<br></span><span class=E>        )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode</span><span class=H>.</span><span class=C>startTime</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>clock</span><span class=E>()<br></span><span class=A>        </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>allTests</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>startTest</span><span class=E>(</span><span class=A> </span><span class=C>testName</span><span class=E> )<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:updateStatus</span><span class=E>(</span><span class=C> err</span><span class=E> )<br></span><span class=A>        -- &#34;err&#34; is expected to be a table / result from protectedCall()<br>        </span><span class=N>if</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SUCCESS</span><span class=N> then<br></span><span class=A>            </span><span class=K>return<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=A>        </span><span class=G>local</span><span class=C> node</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode<br><br></span><span class=A>        --[[ As a first approach, we will report only one error or one failure for one test.<br><br>        However, we can have the case where the test is in failure, and the teardown is in error.<br>        In such case, it&#39;s a good idea to report both a failure and an error in the test suite. This is<br>        what Python unittest does for example. However, it mixes up counts so need to be handled carefully: for<br>        example, there could be more (failures + errors) count that tests. What happens to the current node ?<br><br>        We will do this more intelligent version later.<br>        ]]<br><br>        -- if the node is already in failure/error, just don&#39;t report the new error (see above)<br>        </span><span class=N>if</span><span class=C> node</span><span class=H>.</span><span class=C>status</span><span class=E> ~=</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SUCCESS</span><span class=N> then<br></span><span class=A>            </span><span class=K>return<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>FAIL</span><span class=N> then<br></span><span class=A>            </span><span class=C>node</span><span class=H>:</span><span class=C>fail</span><span class=E>(</span><span class=A> </span><span class=C>err</span><span class=H>.</span><span class=C>msg</span><span class=O>,</span><span class=C> err</span><span class=H>.</span><span class=C>trace</span><span class=E> )<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failedTests</span><span class=O>,</span><span class=C> node</span><span class=E> )<br></span><span class=N>        elseif</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>ERROR</span><span class=N> then<br></span><span class=A>            </span><span class=C>node</span><span class=H>:</span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=C>err</span><span class=H>.</span><span class=C>msg</span><span class=O>,</span><span class=C> err</span><span class=H>.</span><span class=C>trace</span><span class=E> )<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorTests</span><span class=O>,</span><span class=C> node</span><span class=E> )<br></span><span class=N>        elseif</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SKIP</span><span class=N> then<br></span><span class=A>            </span><span class=C>node</span><span class=H>:</span><span class=C>skip</span><span class=E>(</span><span class=A> </span><span class=C>err</span><span class=H>.</span><span class=C>msg</span><span class=E> )<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>skippedTests</span><span class=O>,</span><span class=C> node</span><span class=E> )<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>No such status: </span><span class=B>&#39;</span><span class=E> ..</span><span class=C> prettystr</span><span class=E>(</span><span class=C>err</span><span class=H>.</span><span class=C>status</span><span class=E>))<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=A> </span><span class=C>node</span><span class=E> )<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:endTest</span><span class=E>()<br></span><span class=A>        </span><span class=G>local</span><span class=C> node</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode<br></span><span class=A>        -- print( &#39;endTest() &#39;..prettystr(node))<br>        -- print( &#39;endTest() &#39;..prettystr(node:isNotSuccess()))<br>        </span><span class=C>node</span><span class=H>.</span><span class=C>duration</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>clock</span><span class=E>() -</span><span class=C> node</span><span class=H>.</span><span class=C>startTime<br></span><span class=A>        </span><span class=C>node</span><span class=H>.</span><span class=C>startTime</span><span class=D> =</span><span class=L> nil<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>endTest</span><span class=E>(</span><span class=A> </span><span class=C>node</span><span class=E> )<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>successCount</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>successCount</span><span class=E> +</span><span class=M> 1<br></span><span class=N>        elseif</span><span class=C> node</span><span class=H>:</span><span class=C>isError</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>quitOnError</span><span class=J> or</span><span class=C> self</span><span class=H>.</span><span class=C>quitOnFailure</span><span class=N> then<br></span><span class=A>                -- Runtime error - abort test execution as requested by<br>                -- &#34;--error&#34; option. This is done by setting a special<br>                -- flag that gets handled in internalRunSuiteByInstances().<br>                </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>\nERROR during LuaUnit test execution:\n</span><span class=B>&#34;</span><span class=E> ..</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=E>)<br></span><span class=A>                </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>aborted</span><span class=D> =</span><span class=L> true<br></span><span class=N>            end<br>        elseif</span><span class=C> node</span><span class=H>:</span><span class=C>isFailure</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>quitOnFailure</span><span class=N> then<br></span><span class=A>                -- Failure - abort test execution as requested by<br>                -- &#34;--failure&#34; option. This is done by setting a special<br>                -- flag that gets handled in internalRunSuiteByInstances().<br>                </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>\nFailure during LuaUnit test execution:\n</span><span class=B>&#34;</span><span class=E> ..</span><span class=C> node</span><span class=H>.</span><span class=C>msg</span><span class=E>)<br></span><span class=A>                </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>aborted</span><span class=D> =</span><span class=L> true<br></span><span class=N>            end<br>        elseif</span><span class=C> node</span><span class=H>:</span><span class=C>isSkipped</span><span class=E>()</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>runCount</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>runCount</span><span class=E> -</span><span class=M> 1<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>No such node status: </span><span class=B>&#39;</span><span class=E> ..</span><span class=C> prettystr</span><span class=E>(</span><span class=C>node</span><span class=H>.</span><span class=C>status</span><span class=E>))<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode</span><span class=D> =</span><span class=L> nil<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:endClass</span><span class=E>()<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>teardownClass</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>lastClassName</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>lastClassInstance</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>endClass</span><span class=E>()<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:endSuite</span><span class=E>()<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>suiteStarted</span><span class=E> ==</span><span class=L> false</span><span class=N> then<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=B>&#39;</span><span class=F>LuaUnit:endSuite() -- suite was already ended</span><span class=B>&#39;</span><span class=E> )<br></span><span class=N>        end<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>duration</span><span class=D> =</span><span class=C> os</span><span class=H>.</span><span class=C>clock</span><span class=E>()-</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>startTime<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>suiteStarted</span><span class=D> =</span><span class=L> false<br><br></span><span class=A>        -- Expose test counts for outputter&#39;s endSuite(). This could be managed<br>        -- internally instead by using the length of the lists of failed tests<br>        -- but unit tests rely on these fields being present.<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failureCount</span><span class=D> =</span><span class=E> #</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failedTests<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorCount</span><span class=D> =</span><span class=E> #</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorTests<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>failureCount</span><span class=E> +</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>errorCount<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>skippedCount</span><span class=D> =</span><span class=E> #</span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>skippedTests<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>endSuite</span><span class=E>()<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:setOutputType</span><span class=E>(</span><span class=C>outputType</span><span class=O>,</span><span class=C> fname</span><span class=E>)<br></span><span class=A>        -- Configures LuaUnit runner output<br>        -- outputType is one of: NIL, TAP, JUNIT, TEXT<br>        -- when outputType is junit, the additional argument fname is used to set the name of junit output file<br>        -- for other formats, fname is ignored<br>        </span><span class=N>if</span><span class=C> outputType</span><span class=H>:</span><span class=C>upper</span><span class=E>() ==</span><span class=B> &#34;</span><span class=F>NIL</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>outputType</span><span class=D> =</span><span class=C> NilOutput<br></span><span class=K>            return<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> outputType</span><span class=H>:</span><span class=C>upper</span><span class=E>() ==</span><span class=B> &#34;</span><span class=F>TAP</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>outputType</span><span class=D> =</span><span class=C> TapOutput<br></span><span class=K>            return<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> outputType</span><span class=H>:</span><span class=C>upper</span><span class=E>() ==</span><span class=B> &#34;</span><span class=F>JUNIT</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>outputType</span><span class=D> =</span><span class=C> JUnitOutput<br></span><span class=A>            </span><span class=N>if</span><span class=C> fname</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>.</span><span class=C>fname</span><span class=D> =</span><span class=C> fname<br></span><span class=N>            end<br></span><span class=K>            return<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=N>if</span><span class=C> outputType</span><span class=H>:</span><span class=C>upper</span><span class=E>() ==</span><span class=B> &#34;</span><span class=F>TEXT</span><span class=B>&#34;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>outputType</span><span class=D> =</span><span class=C> TextOutput<br></span><span class=K>            return<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>No such format: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>outputType</span><span class=O>,</span><span class=M>2</span><span class=E>)<br></span><span class=K>    end<br><br></span><span class=A>    --------------[[ Runner ]]-----------------<br><br>    </span><span class=K>function</span><span class=C> M.LuaUnit:protectedCall</span><span class=E>(</span><span class=C>classInstance</span><span class=O>,</span><span class=C> methodInstance</span><span class=O>,</span><span class=C> prettyFuncName</span><span class=E>)<br></span><span class=A>        -- if classInstance is nil, this is just a function call<br>        -- else, it&#39;s method of a class being called.<br><br>        </span><span class=K>local function</span><span class=C> err_handler</span><span class=E>(</span><span class=C>e</span><span class=E>)<br></span><span class=A>            -- transform error into a table, adding the traceback information<br>            </span><span class=K>return</span><span class=A> </span><span class=E>{<br></span><span class=P>                status</span><span class=D> =</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>ERROR</span><span class=O>,<br></span><span class=P>                msg</span><span class=D> =</span><span class=C> e</span><span class=O>,<br></span><span class=P>                trace</span><span class=D> =</span><span class=C> string</span><span class=H>.</span><span class=C>sub</span><span class=E>(</span><span class=C>debug</span><span class=H>.</span><span class=C>traceback</span><span class=E>(</span><span class=B>&#34;&#34;</span><span class=O>,</span><span class=M> 1</span><span class=E>)</span><span class=O>,</span><span class=M> 2</span><span class=E>)<br>            }<br></span><span class=R>        </span><span class=K>end<br><br></span><span class=A>        </span><span class=G>local</span><span class=C> ok</span><span class=O>,</span><span class=C> err<br></span><span class=A>        </span><span class=N>if</span><span class=C> classInstance</span><span class=N> then<br></span><span class=A>            -- stupid Lua &lt; 5.2 does not allow xpcall with arguments so let&#39;s use a workaround<br>            </span><span class=C>ok</span><span class=O>,</span><span class=C> err</span><span class=D> =</span><span class=C> xpcall</span><span class=E>(</span><span class=A> </span><span class=K>function</span><span class=C> </span><span class=E>()</span><span class=A> </span><span class=C>methodInstance</span><span class=E>(</span><span class=C>classInstance</span><span class=E>)</span><span class=K> end</span><span class=O>,</span><span class=C> err_handler</span><span class=E> )<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>ok</span><span class=O>,</span><span class=C> err</span><span class=D> =</span><span class=C> xpcall</span><span class=E>(</span><span class=A> </span><span class=K>function</span><span class=C> </span><span class=E>()</span><span class=A> </span><span class=C>methodInstance</span><span class=E>()</span><span class=K> end</span><span class=O>,</span><span class=C> err_handler</span><span class=E> )<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=C> ok</span><span class=N> then<br></span><span class=A>            </span><span class=K>return</span><span class=A> </span><span class=E>{</span><span class=P>status</span><span class=D> =</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SUCCESS</span><span class=E>}<br></span><span class=R>        </span><span class=N>end<br></span><span class=A>        -- print(&#39;ok=&#34;&#39;..prettystr(ok)..&#39;&#34; err=&#34;&#39;..prettystr(err)..&#39;&#34;&#39;)<br><br>        </span><span class=G>local</span><span class=C> iter_msg<br></span><span class=A>        </span><span class=C>iter_msg</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>exeRepeat</span><span class=I> and</span><span class=B> &#39;</span><span class=F>iteration </span><span class=B>&#39;</span><span class=E>..</span><span class=C>self</span><span class=H>.</span><span class=C>currentCount<br><br></span><span class=A>        </span><span class=C>err</span><span class=H>.</span><span class=C>msg</span><span class=O>,</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>adjust_err_msg_with_iter</span><span class=E>(</span><span class=A> </span><span class=C>err</span><span class=H>.</span><span class=C>msg</span><span class=O>,</span><span class=C> iter_msg</span><span class=E> )<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SUCCESS</span><span class=J> or</span><span class=C> err</span><span class=H>.</span><span class=C>status</span><span class=E> ==</span><span class=C> NodeStatus</span><span class=H>.</span><span class=C>SKIP</span><span class=N> then<br></span><span class=A>            </span><span class=C>err</span><span class=H>.</span><span class=C>trace</span><span class=D> =</span><span class=L> nil<br></span><span class=K>            return</span><span class=A> </span><span class=C>err<br></span><span class=R>        </span><span class=N>end<br><br></span><span class=A>        -- reformat / improve the stack trace<br>        </span><span class=N>if</span><span class=C> prettyFuncName</span><span class=N> then</span><span class=A> -- we do have the real method name<br>            </span><span class=C>err</span><span class=H>.</span><span class=C>trace</span><span class=D> =</span><span class=C> err</span><span class=H>.</span><span class=C>trace</span><span class=H>:</span><span class=C>gsub</span><span class=E>(</span><span class=B>&#34;</span><span class=F>in (%a+) &#39;methodInstance&#39;</span><span class=B>&#34;</span><span class=O>,</span><span class=B> &#34;</span><span class=F>in %1 &#39;</span><span class=B>&#34;</span><span class=E>..</span><span class=C>prettyFuncName</span><span class=E>..</span><span class=B>&#34;</span><span class=F>&#39;</span><span class=B>&#34;</span><span class=E>)<br></span><span class=N>        end<br></span><span class=A>        </span><span class=N>if</span><span class=C> STRIP_LUAUNIT_FROM_STACKTRACE</span><span class=N> then<br></span><span class=A>            </span><span class=C>err</span><span class=H>.</span><span class=C>trace</span><span class=D> =</span><span class=C> stripLuaunitTrace2</span><span class=E>(</span><span class=C>err</span><span class=H>.</span><span class=C>trace</span><span class=O>,</span><span class=C> err</span><span class=H>.</span><span class=C>msg</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=K>        return</span><span class=A> </span><span class=C>err</span><span class=R> -- return the error &#34;object&#34; (table)<br>    </span><span class=K>end<br><br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:execOneFunction</span><span class=E>(</span><span class=C>className</span><span class=O>,</span><span class=C> methodName</span><span class=O>,</span><span class=C> classInstance</span><span class=O>,</span><span class=C> methodInstance</span><span class=E>)<br></span><span class=A>        -- When executing a test function, className and classInstance must be nil<br>        -- When executing a class method, all parameters must be set<br><br>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>methodInstance</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>function</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>            </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=C>tostring</span><span class=E>(</span><span class=C>methodName</span><span class=E>)..</span><span class=B>&#39;</span><span class=F> must be a function, not </span><span class=B>&#39;</span><span class=E>..</span><span class=C>type</span><span class=E>(</span><span class=C>methodInstance</span><span class=E>))<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=G>local</span><span class=C> prettyFuncName<br></span><span class=A>        </span><span class=N>if</span><span class=C> className</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>className</span><span class=D> =</span><span class=B> &#39;</span><span class=F>[TestFunctions]</span><span class=B>&#39;<br></span><span class=A>            </span><span class=C>prettyFuncName</span><span class=D> =</span><span class=C> methodName<br></span><span class=N>        else<br></span><span class=A>            </span><span class=C>prettyFuncName</span><span class=D> =</span><span class=C> className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.</span><span class=B>&#39;</span><span class=E>..</span><span class=C>methodName<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>lastClassName</span><span class=E> ~=</span><span class=C> className</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>lastClassName</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>endClass</span><span class=E>()<br></span><span class=N>            end<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>startClass</span><span class=E>(</span><span class=A> </span><span class=C>className</span><span class=O>,</span><span class=C> classInstance</span><span class=E> )<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>lastClassName</span><span class=D> =</span><span class=C> className<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>lastClassInstance</span><span class=D> =</span><span class=C> classInstance<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>startTest</span><span class=E>(</span><span class=C>prettyFuncName</span><span class=E>)<br><br></span><span class=A>        </span><span class=G>local</span><span class=C> node</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>currentNode<br></span><span class=A>        </span><span class=N>for</span><span class=C> iter_n</span><span class=D> =</span><span class=M> 1</span><span class=O>,</span><span class=C> self</span><span class=H>.</span><span class=C>exeRepeat</span><span class=J> or</span><span class=M> 1</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isNotSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>                </span><span class=N>break<br>            end<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>currentCount</span><span class=D> =</span><span class=C> iter_n<br><br></span><span class=A>            -- run setUp first (if any)<br>            </span><span class=N>if</span><span class=C> classInstance</span><span class=N> then<br></span><span class=A>                </span><span class=G>local</span><span class=C> func</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>setUp</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>Setup</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>setup</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>SetUp</span><span class=E> )<br></span><span class=A>                </span><span class=N>if</span><span class=C> func</span><span class=N> then<br></span><span class=A>                    </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=C>classInstance</span><span class=O>,</span><span class=C> func</span><span class=O>,</span><span class=C> className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.setUp</span><span class=B>&#39;</span><span class=E>))<br></span><span class=N>                end<br>            end<br><br></span><span class=A>            -- run testMethod()<br>            </span><span class=N>if</span><span class=C> node</span><span class=H>:</span><span class=C>isSuccess</span><span class=E>()</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=C>classInstance</span><span class=O>,</span><span class=C> methodInstance</span><span class=O>,</span><span class=C> prettyFuncName</span><span class=E>))<br></span><span class=N>            end<br><br></span><span class=A>            -- lastly, run tearDown (if any)<br>            </span><span class=N>if</span><span class=C> classInstance</span><span class=N> then<br></span><span class=A>                </span><span class=G>local</span><span class=C> func</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>tearDown</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>TearDown</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>teardown</span><span class=E> )</span><span class=J> or<br></span><span class=C>                             self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>classInstance</span><span class=H>.</span><span class=C>Teardown</span><span class=E> )<br></span><span class=A>                </span><span class=N>if</span><span class=C> func</span><span class=N> then<br></span><span class=A>                    </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=C>classInstance</span><span class=O>,</span><span class=C> func</span><span class=O>,</span><span class=C> className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.tearDown</span><span class=B>&#39;</span><span class=E>))<br></span><span class=N>                end<br>            end<br>        end<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>endTest</span><span class=E>()<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.expandOneClass</span><span class=E>(</span><span class=C> result</span><span class=O>,</span><span class=C> className</span><span class=O>,</span><span class=C> classInstance</span><span class=E> )<br></span><span class=A>        --[[<br>        Input: a list of { name, instance }, a class name, a class instance<br>        Ouptut: modify result to add all test method instance in the form:<br>        { className.methodName, classInstance }<br>        ]]<br>        </span><span class=N>for</span><span class=C> methodName</span><span class=O>,</span><span class=C> methodInstance</span><span class=N> in</span><span class=C> sortedPairs</span><span class=E>(</span><span class=C>classInstance</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=C>methodInstance</span><span class=E>)</span><span class=I> and</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>isMethodTestName</span><span class=E>(</span><span class=A> </span><span class=C>methodName</span><span class=E> )</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=E> {</span><span class=A> </span><span class=C>className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.</span><span class=B>&#39;</span><span class=E>..</span><span class=C>methodName</span><span class=O>,</span><span class=A> </span><span class=C>classInstance</span><span class=E> } )<br></span><span class=N>            end<br>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.expandClasses</span><span class=E>(</span><span class=C> listOfNameAndInst</span><span class=E> )<br></span><span class=A>        --[[<br>        -- expand all classes (provided as {className, classInstance}) to a list of {className.methodName, classInstance}<br>        -- functions and methods remain untouched<br><br>        Input: a list of { name, instance }<br><br>        Output:<br>        * { function name, function instance } : do nothing<br>        * { class.method name, class instance }: do nothing<br>        * { class name, class instance } : add all method names in the form of (className.methodName, classInstance)<br>        ]]<br>        </span><span class=G>local</span><span class=C> result</span><span class=D> =</span><span class=E> {}<br><br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C>v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )</span><span class=N> do<br></span><span class=A>            </span><span class=G>local</span><span class=C> name</span><span class=O>,</span><span class=C> instance</span><span class=D> =</span><span class=C> v</span><span class=E>[</span><span class=M>1</span><span class=E>]</span><span class=O>,</span><span class=C> v</span><span class=E>[</span><span class=M>2</span><span class=E>]<br></span><span class=A>            </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=C>instance</span><span class=E>)</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=E> {</span><span class=A> </span><span class=C>name</span><span class=O>,</span><span class=A> </span><span class=C>instance</span><span class=E> } )<br></span><span class=N>            else<br></span><span class=A>                </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>instance</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                    </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>Instance must be a table or a function, not a </span><span class=B>&#39;</span><span class=E>..</span><span class=C>type</span><span class=E>(</span><span class=C>instance</span><span class=E>)..</span><span class=B>&#39;</span><span class=F> with value </span><span class=B>&#39;</span><span class=E>..</span><span class=C>prettystr</span><span class=E>(</span><span class=C>instance</span><span class=E>))<br></span><span class=N>                end<br></span><span class=A>                </span><span class=G>local</span><span class=C> className</span><span class=O>,</span><span class=C> methodName</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>splitClassMethod</span><span class=E>(</span><span class=A> </span><span class=C>name</span><span class=E> )<br></span><span class=A>                </span><span class=N>if</span><span class=C> className</span><span class=N> then<br></span><span class=A>                    </span><span class=G>local</span><span class=C> methodInstance</span><span class=D> =</span><span class=C> instance</span><span class=E>[</span><span class=C>methodName</span><span class=E>]<br></span><span class=A>                    </span><span class=N>if</span><span class=C> methodInstance</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                        </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>Could not find method in class </span><span class=B>&#34;</span><span class=E>..</span><span class=C>tostring</span><span class=E>(</span><span class=C>className</span><span class=E>)..</span><span class=B>&#34;</span><span class=F> for method </span><span class=B>&#34;</span><span class=E>..</span><span class=C>tostring</span><span class=E>(</span><span class=C>methodName</span><span class=E>) )<br></span><span class=N>                    end<br></span><span class=A>                    </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=E> {</span><span class=A> </span><span class=C>name</span><span class=O>,</span><span class=A> </span><span class=C>instance</span><span class=E> } )<br></span><span class=N>                else<br></span><span class=A>                    </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>expandOneClass</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=O>,</span><span class=C> name</span><span class=O>,</span><span class=C> instance</span><span class=E> )<br></span><span class=N>                end<br>            end<br>        end<br><br></span><span class=K>        return</span><span class=A> </span><span class=C>result<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.applyPatternFilter</span><span class=E>(</span><span class=C> patternIncFilter</span><span class=O>,</span><span class=C> listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=G>local</span><span class=C> included</span><span class=O>,</span><span class=C> excluded</span><span class=D> =</span><span class=E> {}</span><span class=O>,</span><span class=E> {}<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C> v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )</span><span class=N> do<br></span><span class=A>            -- local name, instance = v[1], v[2]<br>            </span><span class=N>if</span><span class=C>  patternFilter</span><span class=E>(</span><span class=A> </span><span class=C>patternIncFilter</span><span class=O>,</span><span class=C> v</span><span class=E>[</span><span class=M>1</span><span class=E>] )</span><span class=N> then<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>included</span><span class=O>,</span><span class=C> v</span><span class=E> )<br></span><span class=N>            else<br></span><span class=A>                </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>excluded</span><span class=O>,</span><span class=C> v</span><span class=E> )<br></span><span class=N>            end<br>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>included</span><span class=O>,</span><span class=C> excluded<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>local function</span><span class=C> getKeyInListWithGlobalFallback</span><span class=E>(</span><span class=C> key</span><span class=O>,</span><span class=C>  listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=G>local</span><span class=C> result</span><span class=D> =</span><span class=L> nil<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C>v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=E>(</span><span class=C>listOfNameAndInst</span><span class=E>[</span><span class=C>i</span><span class=E>][</span><span class=M>1</span><span class=E>] ==</span><span class=C> key</span><span class=E>)</span><span class=N> then<br></span><span class=A>                </span><span class=C>result</span><span class=D> =</span><span class=C> listOfNameAndInst</span><span class=E>[</span><span class=C>i</span><span class=E>][</span><span class=M>2</span><span class=E>]<br></span><span class=A>                </span><span class=N>break<br>            end<br>        end<br></span><span class=A>        </span><span class=N>if</span><span class=E>(not</span><span class=C>  M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>result</span><span class=E> ) )</span><span class=N> then<br></span><span class=A>            </span><span class=C>result</span><span class=D> =</span><span class=C> _G</span><span class=E>[</span><span class=C>key</span><span class=E>]<br></span><span class=N>        end<br></span><span class=K>        return</span><span class=A> </span><span class=C>result<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:setupSuite</span><span class=E>(</span><span class=C> listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=G>local</span><span class=C> setupSuite</span><span class=D> =</span><span class=C> getKeyInListWithGlobalFallback</span><span class=E>(</span><span class=B>&#34;</span><span class=F>setupSuite</span><span class=B>&#34;</span><span class=O>,</span><span class=C> listOfNameAndInst</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C>  self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>setupSuite</span><span class=E> )</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=A> </span><span class=L>nil</span><span class=O>,</span><span class=C> setupSuite</span><span class=O>,</span><span class=B> &#39;</span><span class=F>setupSuite</span><span class=B>&#39;</span><span class=E> ) )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:teardownSuite</span><span class=E>(</span><span class=C>listOfNameAndInst</span><span class=E>)<br></span><span class=A>        </span><span class=G>local</span><span class=C> teardownSuite</span><span class=D> =</span><span class=C> getKeyInListWithGlobalFallback</span><span class=E>(</span><span class=B>&#34;</span><span class=F>teardownSuite</span><span class=B>&#34;</span><span class=O>,</span><span class=C> listOfNameAndInst</span><span class=E>)<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>teardownSuite</span><span class=E> )</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=A> </span><span class=L>nil</span><span class=O>,</span><span class=C> teardownSuite</span><span class=O>,</span><span class=B> &#39;</span><span class=F>teardownSuite</span><span class=B>&#39;</span><span class=E>) )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C>  M.LuaUnit:setupClass</span><span class=E>(</span><span class=C> className</span><span class=O>,</span><span class=C> instance</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=E> ) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=H>.</span><span class=C>setupClass</span><span class=E> )</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=O>,</span><span class=C> instance</span><span class=H>.</span><span class=C>setupClass</span><span class=O>,</span><span class=C> className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.setupClass</span><span class=B>&#39;</span><span class=E> ) )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:teardownClass</span><span class=E>(</span><span class=C> className</span><span class=O>,</span><span class=C> instance</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=E> ) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> self</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=H>.</span><span class=C>teardownClass</span><span class=E> )</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>updateStatus</span><span class=E>(</span><span class=A> </span><span class=C>self</span><span class=H>:</span><span class=C>protectedCall</span><span class=E>(</span><span class=A> </span><span class=C>instance</span><span class=O>,</span><span class=C> instance</span><span class=H>.</span><span class=C>teardownClass</span><span class=O>,</span><span class=C> className</span><span class=E>..</span><span class=B>&#39;</span><span class=F>.teardownClass</span><span class=B>&#39;</span><span class=E> ) )<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:internalRunSuiteByInstances</span><span class=E>(</span><span class=C> listOfNameAndInst</span><span class=E> )<br></span><span class=A>        --[[ Run an explicit list of tests. Each item of the list must be one of:<br>        * { function name, function instance }<br>        * { class name, class instance }<br>        * { class.method name, class instance }<br><br>        This function is internal to LuaUnit. The official API to perform this action is runSuiteByInstances()<br>        ]]<br><br>        </span><span class=G>local</span><span class=C> expandedList</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>expandClasses</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>shuffle</span><span class=N> then<br></span><span class=A>            </span><span class=C>randomizeTable</span><span class=E>(</span><span class=A> </span><span class=C>expandedList</span><span class=E> )<br></span><span class=N>        end<br></span><span class=A>        </span><span class=G>local</span><span class=C> filteredList</span><span class=O>,</span><span class=C> filteredOutList</span><span class=D> =</span><span class=C> self</span><span class=H>.</span><span class=C>applyPatternFilter</span><span class=E>(<br></span><span class=A>            </span><span class=C>self</span><span class=H>.</span><span class=C>patternIncludeFilter</span><span class=O>,</span><span class=C> expandedList</span><span class=E> )<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>startSuite</span><span class=E>(</span><span class=A> </span><span class=E>#</span><span class=C>filteredList</span><span class=O>,</span><span class=E> #</span><span class=C>filteredOutList</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>setupSuite</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )<br><br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C>v</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>filteredList</span><span class=E> )</span><span class=N> do<br></span><span class=A>            </span><span class=G>local</span><span class=C> name</span><span class=O>,</span><span class=C> instance</span><span class=D> =</span><span class=C> v</span><span class=E>[</span><span class=M>1</span><span class=E>]</span><span class=O>,</span><span class=C> v</span><span class=E>[</span><span class=M>2</span><span class=E>]<br></span><span class=A>            </span><span class=N>if</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>asFunction</span><span class=E>(</span><span class=C>instance</span><span class=E>)</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>execOneFunction</span><span class=E>(</span><span class=A> </span><span class=L>nil</span><span class=O>,</span><span class=C> name</span><span class=O>,</span><span class=L> nil</span><span class=O>,</span><span class=C> instance</span><span class=E> )<br></span><span class=N>            else<br></span><span class=A>                -- expandClasses() should have already taken care of sanitizing the input<br>                </span><span class=C>assert</span><span class=E>(</span><span class=A> </span><span class=C>type</span><span class=E>(</span><span class=C>instance</span><span class=E>) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=E> )<br></span><span class=A>                </span><span class=G>local</span><span class=C> className</span><span class=O>,</span><span class=C> methodName</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>splitClassMethod</span><span class=E>(</span><span class=A> </span><span class=C>name</span><span class=E> )<br></span><span class=A>                </span><span class=C>assert</span><span class=E>(</span><span class=A> </span><span class=C>className</span><span class=E> ~=</span><span class=L> nil</span><span class=E> )<br></span><span class=A>                </span><span class=G>local</span><span class=C> methodInstance</span><span class=D> =</span><span class=C> instance</span><span class=E>[</span><span class=C>methodName</span><span class=E>]<br></span><span class=A>                </span><span class=C>assert</span><span class=E>(</span><span class=C>methodInstance</span><span class=E> ~=</span><span class=L> nil</span><span class=E>)<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>execOneFunction</span><span class=E>(</span><span class=A> </span><span class=C>className</span><span class=O>,</span><span class=C> methodName</span><span class=O>,</span><span class=C> instance</span><span class=O>,</span><span class=C> methodInstance</span><span class=E> )<br></span><span class=N>            end<br></span><span class=A>            </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>aborted</span><span class=N> then<br></span><span class=A>                </span><span class=N>break</span><span class=C565662> -- &#34;--error&#34; or &#34;--failure&#34; option triggered<br></span><span class=N>            end<br>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>lastClassName</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>endClass</span><span class=E>()<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>teardownSuite</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>endSuite</span><span class=E>()<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>aborted</span><span class=N> then<br></span><span class=A>            </span><span class=C>print</span><span class=E>(</span><span class=B>&#34;</span><span class=F>LuaUnit ABORTED (as requested by --error or --failure option)</span><span class=B>&#34;</span><span class=E>)<br></span><span class=A>            </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>            </span><span class=C>os</span><span class=H>.</span><span class=C>exit</span><span class=E>(-</span><span class=M>2</span><span class=E>)<br></span><span class=N>        end<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:internalRunSuiteByNames</span><span class=E>(</span><span class=C> listOfName</span><span class=E> )<br></span><span class=A>        --[[ Run LuaUnit with a list of generic names, coming either from command-line or from global<br>            namespace analysis. Convert the list into a list of (name, valid instances (table or function))<br>            and calls internalRunSuiteByInstances.<br>        ]]<br><br>        </span><span class=G>local</span><span class=C> instanceName</span><span class=O>,</span><span class=C> instance<br></span><span class=A>        </span><span class=G>local</span><span class=C> listOfNameAndInst</span><span class=D> =</span><span class=E> {}<br><br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C>name</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=A> </span><span class=C>listOfName</span><span class=E> )</span><span class=N> do<br></span><span class=A>            </span><span class=G>local</span><span class=C> className</span><span class=O>,</span><span class=C> methodName</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>splitClassMethod</span><span class=E>(</span><span class=A> </span><span class=C>name</span><span class=E> )<br></span><span class=A>            </span><span class=N>if</span><span class=C> className</span><span class=N> then<br></span><span class=A>                </span><span class=C>instanceName</span><span class=D> =</span><span class=C> className<br></span><span class=A>                </span><span class=C>instance</span><span class=D> =</span><span class=C> _G</span><span class=E>[</span><span class=C>instanceName</span><span class=E>]<br><br></span><span class=A>                </span><span class=N>if</span><span class=C> instance</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                    </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>                    </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>No such name in global space: </span><span class=B>&#34;</span><span class=E>..</span><span class=C>instanceName</span><span class=E> )<br></span><span class=N>                end<br><br></span><span class=A>                </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>instance</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>                    </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>                    </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>Instance of </span><span class=B>&#39;</span><span class=E>..</span><span class=C>instanceName</span><span class=E>..</span><span class=B>&#39;</span><span class=F> must be a table, not </span><span class=B>&#39;</span><span class=E>..</span><span class=C>type</span><span class=E>(</span><span class=C>instance</span><span class=E>))<br></span><span class=N>                end<br><br></span><span class=A>                </span><span class=G>local</span><span class=C> methodInstance</span><span class=D> =</span><span class=C> instance</span><span class=E>[</span><span class=C>methodName</span><span class=E>]<br></span><span class=A>                </span><span class=N>if</span><span class=C> methodInstance</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                    </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>                    </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>Could not find method in class </span><span class=B>&#34;</span><span class=E>..</span><span class=C>tostring</span><span class=E>(</span><span class=C>className</span><span class=E>)..</span><span class=B>&#34;</span><span class=F> for method </span><span class=B>&#34;</span><span class=E>..</span><span class=C>tostring</span><span class=E>(</span><span class=C>methodName</span><span class=E>) )<br></span><span class=N>                end<br><br>            else<br></span><span class=A>                -- for functions and classes<br>                </span><span class=C>instanceName</span><span class=D> =</span><span class=C> name<br></span><span class=A>                </span><span class=C>instance</span><span class=D> =</span><span class=C> _G</span><span class=E>[</span><span class=C>instanceName</span><span class=E>]<br></span><span class=N>            end<br><br></span><span class=A>            </span><span class=N>if</span><span class=C> instance</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>                </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#34;</span><span class=F>No such name in global space: </span><span class=B>&#34;</span><span class=E>..</span><span class=C>instanceName</span><span class=E> )<br></span><span class=N>            end<br><br></span><span class=A>            </span><span class=N>if</span><span class=E> (</span><span class=C>type</span><span class=E>(</span><span class=C>instance</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> type</span><span class=E>(</span><span class=C>instance</span><span class=E>) ~=</span><span class=B> &#39;</span><span class=F>function</span><span class=B>&#39;</span><span class=E>)</span><span class=N> then<br></span><span class=A>                </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=A>                </span><span class=C>error</span><span class=E>(</span><span class=A> </span><span class=B>&#39;</span><span class=F>Name must match a function or a table: </span><span class=B>&#39;</span><span class=E>..</span><span class=C>instanceName</span><span class=E> )<br></span><span class=N>            end<br><br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>insert</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=O>,</span><span class=E> {</span><span class=A> </span><span class=C>name</span><span class=O>,</span><span class=A> </span><span class=C>instance</span><span class=E> } )<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>internalRunSuiteByInstances</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit.run</span><span class=E>(</span><span class=O>...</span><span class=E>)<br></span><span class=A>        -- Run some specific test classes.<br>        -- If no arguments are passed, run the class names specified on the<br>        -- command line. If no class name is specified on the command line<br>        -- run all classes whose name starts with &#39;Test&#39;<br>        --<br>        -- If arguments are passed, they must be strings of the class names<br>        -- that you want to run or generic command line arguments (-o, -p, -v, ...)<br>        </span><span class=G>local</span><span class=C> runner</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>new</span><span class=E>()<br></span><span class=K>        return</span><span class=A> </span><span class=C>runner</span><span class=H>:</span><span class=C>runSuite</span><span class=E>(</span><span class=O>...</span><span class=E>)<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:registerSuite</span><span class=E>()<br></span><span class=A>        -- register the current instance into our global array of instances<br>        -- print(&#39;-&gt; Register suite&#39;)<br>        </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=E>[ #</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=E>+</span><span class=M>1</span><span class=E> ]</span><span class=D> =</span><span class=C> self<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.unregisterCurrentSuite</span><span class=E>()<br></span><span class=A>        -- force unregister the last registered suite<br>        </span><span class=C>table</span><span class=H>.</span><span class=C>remove</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=O>,</span><span class=E> #</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=E>)<br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:unregisterSuite</span><span class=E>()<br></span><span class=A>        -- print(&#39;&lt;- Unregister suite&#39;)<br>        -- remove our current instqances from the global array of instances<br>        </span><span class=G>local</span><span class=C> instanceIdx</span><span class=D> =</span><span class=L> nil<br></span><span class=A>        </span><span class=N>for</span><span class=C> i</span><span class=O>,</span><span class=C> instance</span><span class=N> in</span><span class=C> ipairs</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=E>)</span><span class=N> do<br></span><span class=A>            </span><span class=N>if</span><span class=C> instance</span><span class=E> ==</span><span class=C> self</span><span class=N> then<br></span><span class=A>                </span><span class=C>instanceIdx</span><span class=D> =</span><span class=C> i<br></span><span class=A>                </span><span class=N>break<br>            end<br>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> instanceIdx</span><span class=E> ~=</span><span class=L> nil</span><span class=N> then<br></span><span class=A>            </span><span class=C>table</span><span class=H>.</span><span class=C>remove</span><span class=E>(</span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>instances</span><span class=O>,</span><span class=C> instanceIdx</span><span class=E>)<br></span><span class=C565662>            -- print(&#39;Unregister done&#39;)<br></span><span class=N>        end<br><br></span><span class=K>    end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:initFromArguments</span><span class=E>(</span><span class=O> ...</span><span class=E> )<br></span><span class=A>        --[[Parses all arguments from either command-line or direct call and set internal<br>        flags of LuaUnit runner according to it.<br><br>        Return the list of names which were possibly passed on the command-line or as arguments<br>        ]]<br>        </span><span class=G>local</span><span class=C> args</span><span class=D> =</span><span class=E> {</span><span class=O>...</span><span class=E>}<br></span><span class=A>        </span><span class=N>if</span><span class=C> type</span><span class=E>(</span><span class=C>args</span><span class=E>[</span><span class=M>1</span><span class=E>]) ==</span><span class=B> &#39;</span><span class=F>table</span><span class=B>&#39;</span><span class=I> and</span><span class=C> args</span><span class=E>[</span><span class=M>1</span><span class=E>]</span><span class=H>.</span><span class=C>__class__</span><span class=E> ==</span><span class=B> &#39;</span><span class=F>LuaUnit</span><span class=B>&#39;</span><span class=N> then<br></span><span class=A>            -- run was called with the syntax M.LuaUnit:runSuite()<br>            -- we support both M.LuaUnit.run() and M.LuaUnit:run()<br>            -- strip out the first argument self to make it a command-line argument list<br>            </span><span class=C>table</span><span class=H>.</span><span class=C>remove</span><span class=E>(</span><span class=C>args</span><span class=O>,</span><span class=M>1</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=N>if</span><span class=E> #</span><span class=C>args</span><span class=E> ==</span><span class=M> 0</span><span class=N> then<br></span><span class=A>            </span><span class=C>args</span><span class=D> =</span><span class=C> cmdline_argv<br></span><span class=N>        end<br><br></span><span class=A>        </span><span class=G>local</span><span class=C> options</span><span class=D> =</span><span class=C> pcall_or_abort</span><span class=E>(</span><span class=A> </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>parseCmdLine</span><span class=O>,</span><span class=C> args</span><span class=E> )<br><br></span><span class=A>        -- We expect these option fields to be either `nil` or contain<br>        -- valid values, so it&#39;s safe to always copy them directly.<br>        </span><span class=C>self</span><span class=H>.</span><span class=C>verbosity</span><span class=D>     =</span><span class=C> options</span><span class=H>.</span><span class=C>verbosity<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>quitOnError</span><span class=D>   =</span><span class=C> options</span><span class=H>.</span><span class=C>quitOnError<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>quitOnFailure</span><span class=D> =</span><span class=C> options</span><span class=H>.</span><span class=C>quitOnFailure<br><br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>exeRepeat</span><span class=D>            =</span><span class=C> options</span><span class=H>.</span><span class=C>exeRepeat<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>patternIncludeFilter</span><span class=D> =</span><span class=C> options</span><span class=H>.</span><span class=C>pattern<br></span><span class=A>        </span><span class=C>self</span><span class=H>.</span><span class=C>shuffle</span><span class=D>              =</span><span class=C> options</span><span class=H>.</span><span class=C>shuffle<br><br></span><span class=A>        </span><span class=C>options</span><span class=H>.</span><span class=C>output</span><span class=D>     =</span><span class=C> options</span><span class=H>.</span><span class=C>output</span><span class=J> or</span><span class=C> os</span><span class=H>.</span><span class=C>getenv</span><span class=E>(</span><span class=B>&#39;</span><span class=F>LUAUNIT_OUTPUT</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>        </span><span class=C>options</span><span class=H>.</span><span class=C>fname</span><span class=D>      =</span><span class=C> options</span><span class=H>.</span><span class=C>fname</span><span class=J>  or</span><span class=C> os</span><span class=H>.</span><span class=C>getenv</span><span class=E>(</span><span class=B>&#39;</span><span class=F>LUAUNIT_JUNIT_FNAME</span><span class=B>&#39;</span><span class=E>)<br><br></span><span class=A>        </span><span class=N>if</span><span class=C> options</span><span class=H>.</span><span class=C>output</span><span class=N> then<br></span><span class=A>            </span><span class=N>if</span><span class=C> options</span><span class=H>.</span><span class=C>output</span><span class=H>:</span><span class=C>lower</span><span class=E>() ==</span><span class=B> &#39;</span><span class=F>junit</span><span class=B>&#39;</span><span class=I> and</span><span class=C> options</span><span class=H>.</span><span class=C>fname</span><span class=E> ==</span><span class=L> nil</span><span class=N> then<br></span><span class=A>                </span><span class=C>print</span><span class=E>(</span><span class=B>&#39;</span><span class=F>With junit output, a filename must be supplied with -n or --name</span><span class=B>&#39;</span><span class=E>)<br></span><span class=A>                </span><span class=C>os</span><span class=H>.</span><span class=C>exit</span><span class=E>(-</span><span class=M>1</span><span class=E>)<br></span><span class=N>            end<br></span><span class=A>            </span><span class=C>pcall_or_abort</span><span class=E>(</span><span class=C>self</span><span class=H>.</span><span class=C>setOutputType</span><span class=O>,</span><span class=C> self</span><span class=O>,</span><span class=C> options</span><span class=H>.</span><span class=C>output</span><span class=O>,</span><span class=C> options</span><span class=H>.</span><span class=C>fname</span><span class=E>)<br></span><span class=N>        end<br><br></span><span class=K>        return</span><span class=A> </span><span class=C>options</span><span class=H>.</span><span class=C>testNames<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:runSuite</span><span class=E>(</span><span class=O> ...</span><span class=E> )<br></span><span class=A>        </span><span class=G>local</span><span class=C> testNames</span><span class=D> =</span><span class=C> self</span><span class=H>:</span><span class=C>initFromArguments</span><span class=E>(</span><span class=O>...</span><span class=E>)<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>registerSuite</span><span class=E>()<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>internalRunSuiteByNames</span><span class=E>(</span><span class=A> </span><span class=C>testNames</span><span class=J> or</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>collectTests</span><span class=E>() )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=K>        return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount<br></span><span class=R>    </span><span class=K>end<br><br></span><span class=A>    </span><span class=K>function</span><span class=C> M.LuaUnit:runSuiteByInstances</span><span class=E>(</span><span class=C> listOfNameAndInst</span><span class=O>,</span><span class=C> commandLineArguments</span><span class=E> )<br></span><span class=A>        --[[<br>        Run all test functions or tables provided as input.<br><br>        Input: a list of { name, instance }<br>            instance can either be a function or a table containing test functions starting with the prefix &#34;test&#34;<br><br>        return the number of failures and errors, 0 meaning success<br>        ]]<br>        -- parse the command-line arguments<br>        </span><span class=G>local</span><span class=C> testNames</span><span class=D> =</span><span class=C> self</span><span class=H>:</span><span class=C>initFromArguments</span><span class=E>(</span><span class=A> </span><span class=C>commandLineArguments</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>registerSuite</span><span class=E>()<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>internalRunSuiteByInstances</span><span class=E>(</span><span class=A> </span><span class=C>listOfNameAndInst</span><span class=E> )<br></span><span class=A>        </span><span class=C>self</span><span class=H>:</span><span class=C>unregisterSuite</span><span class=E>()<br></span><span class=K>        return</span><span class=A> </span><span class=C>self</span><span class=H>.</span><span class=C>result</span><span class=H>.</span><span class=C>notSuccessCount<br></span><span class=R>    </span><span class=K>end<br><br><br><br></span><span class=A>-- class LuaUnit<br><br>-- For compatbility with LuaUnit v2<br></span><span class=C>M</span><span class=H>.</span><span class=C>run</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>run<br>M</span><span class=H>.</span><span class=C>Run</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>run<br><br></span><span class=K>function</span><span class=C> M:setVerbosity</span><span class=E>(</span><span class=C> verbosity</span><span class=E> )<br></span><span class=A>    -- set the verbosity value (as integer)<br>    </span><span class=C>M</span><span class=H>.</span><span class=C>LuaUnit</span><span class=H>.</span><span class=C>verbosity</span><span class=D> =</span><span class=C> verbosity<br></span><span class=K>end<br></span><span class=C>M</span><span class=H>.</span><span class=C>set_verbosity</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>setVerbosity<br>M</span><span class=H>.</span><span class=C>SetVerbosity</span><span class=D> =</span><span class=C> M</span><span class=H>.</span><span class=C>setVerbosity<br><br><br></span><span class=K>return</span><span class=A> </span><span class=C>M<br><br></span></code></div></div></body></html>