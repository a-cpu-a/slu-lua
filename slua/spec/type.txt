#
# Dependencies: Lua
#

New Syntax {

	Type ::= ["?"] typeItem { "|" typeItem }
	TypeList ::= Type {"," Type}
	TableTupleType ::= "{" TypeList "}"

	typeItem ::= specType | "(" Type ")" {typeSpecifierSuffix}
	specType ::= typeObj {typeSpecifierSuffix}
	
	typeObj ::= Name | TableTupleType
	

	typeSpecifierSuffix ::= "[" [UnsignedIntegral] "]" | "{" "}"
}

New Keywords {
	void
	bool
	int
	num
	ptrdata
	Any
	string
	Table
	Func
	Userdata
	Thread
	
	i8
	i16
	i32
	i64
	i128
	isize
	
	u8
	u16
	u32
	u64
	u128
	usize
}

Official Types {

	(names starting with a capital are complex types)

	void {
		Nothing, no type is allowed.
		Variables and function arguments cant have this type.
		Only allowed as function return type.
	}
	bool {
		A lua boolean
	}
	int {
		A 32, 64, or 53 bit integer
		53 bit integers are only for luajit.
		--[[
			Should old lua use 53 bit aswell?
			What about 32bit old lua? 24 bit ints?
		]]
	}
	num {
		A 32 or 64 bit float, might also be a integer
	}
	ptrdata {
		Lightdata passed from C
	}
	
	Any {
		Any type is allowed (even void)
	}
	String {
		A lua string, immutable
	}
	Table {
		A lua table, can have fields and indices
	}
	Func {
		Any function C, lua, etc
	}
	Userdata {
		Things passed from C
	}
	Thread {
		The coroutines
	}
	
	i8,i16,i32,i64,i128 {
		Optimized 8,16,32 or 64 bit signed integers.
		i64 may be emulated on platforms like luajit, or 32bit versions of lua.
		i128 is always emulated.
	}
	u8,u16,u32,u64,u128 {
		Optimized 8,16,32 or 64 bit unsigned integers.
		u64 may be emulated on platforms like luajit, or 32bit versions of lua.
		u64 multiplication, division, modulo, exp are all emulated on normal lua, but are optimized on slua runtimes (luajit might be optimized when possible too).
		u128 is always emulated.
	}
	isize {
		Currently the same as i64, but may change to "i128" in the far future (2160?)
	}
	usize {
		Currently the same as u64, but may change to "u128" in the far future (2160?)
	}
}

Type Specifiers {
	
	Table Array {
		Format: X "{" "}"
		
		Just a array of X, can have negative, 0, positive integer indices
		Cant have string fields
		
		Since this is a table, indices start at 1
		
		Note: string fields might not be checked at runtime
	}
	Array {
		Format: X "[" [UnsignedIntegral] "]"
		UnsignedIntegral must be a positive integer (non zero), or nothing at all
		
		Unlike table arrays, negative indices will error
		Unlike table arrays, this starts at 0, since it offsets, instead of indexes
		
		if ... is a integer, then the size is fixed, and cant be changed
		
		Implementation: accessing elements through normal lua code is not supported
	}
	Optional {
		Format: "?" X
		
		Applied after any array thingies, so "?X[]" is nil, or a array of X
		To get the opposite, just do "(?X)[]"
		
		Its basicly just a shortcut for " nil | "
		
		Allows X to be nil
	}
}