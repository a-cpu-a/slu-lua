#
# Dependencies: Lua, comptime
#

New Syntax {

	annotations ::= {annotation}
	
	annotation ::= "@" comptimeVar [tableconstructor]
	
	
	stat @::= annotations stat
	exp @::= annotations exp
}

Annotation {
	
	Allows adding info to stuff, for reflection, or compilation.
	
	There are some annotations that can change how code is compiled,
	or how code is exported, etc.
	Some annotations soft-error, when put on the wrong things, and thus are removed.
	
	The constructor arguments to annotations are optional, but in some cases you will need them, as not having them would conflict with other table constructors
	
	Any type can be used as a annotation, as long as it is marked with @Annotation.
	Using a type that isnt marked with @Annotation is a soft-error, and @Annotation is added for you.
	
	Annotations only exist at compile-time, so you cant access them from run-time code.
}

New Annotations {
	@Annotation{} - Marks a type as a annotation.
	
	Example:
	```slua
	@Annotation
	struct FuncMarker end
	
	@FuncMarker
	function myFn() end
	```
	
	
	@Builtin{info=string} - Allows for referencing some builtin value, type, etc.
	The string is a namespaced path to something. 
	A soft-error is produced, if the builtin doesnt exist, and the annotation is ignored.
	
	Example:
	```slua
	ex type Expr = @Builtin{"base::type/exp"}void;
	```
	
	
	@Cfg{onlyIf=bool} - Allows for conditional compilation based on a compile-time boolean expression.
	
	If the condition evaluates to `true`, the annotated code is included in the compilation.
	If the condition evaluates to `false`, the annotated code is **entirely omitted** from the compiled output.
	
	Example:
	```slua
	comptime let isDebug = true;
	
	@Cfg{onlyIf=isDebug}
	function debugPrint(msg)
		print("[DEBUG] " .. msg);
	end
	
	@Cfg{not isDebug}
	function debugPrint(msg)
		-- Debugging disabled, function is omitted at compile time
	end
	
	debugPrint("This will only exist if isDebug is true!");
	```
}