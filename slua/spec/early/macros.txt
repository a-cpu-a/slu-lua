#
# Dependencies: Lua, type, exportPrefix, comptime, library(TODO), annotation, rawVar, fnStatment
#

--TODO: a way to splice out keywords, like "mut", "ex" and "comptime"

"std::macros" Module {
	
	--These are only available at comptime and macros
	
	ex type Block = @Builtin("base::type/block")void;
	ex type Stat = @Builtin("base::type/stat")void;
	ex type Var = @Builtin("base::type/var")void;
	ex type Expr = @Builtin("base::type/exp")void;
	ex type ExprList = @Builtin("base::type/explist")void;
	ex type Name = @Builtin("base::type/Name")void;
	ex type NameList = @Builtin("base::type/namelist")void;
	ex type Type = @Builtin("base::type/type")void;
	ex type TypeList = @Builtin("base::type/typelist")void;
	
	--these exist for macro args, are actually converted to expressions.
	ex type Numeral = @Builtin("base::type/Numeral")void;
	ex type SignedNumeral = @Builtin("base::type/SignedNumeral")void;
	ex type Integral = @Builtin("base::type/Integral")void;
	ex type SignedIntegral = @Builtin("base::type/SignedIntegral")void;
	ex type LiteralString = @Builtin("base::type/LiteralString")void;
	
	--These return the tokens raw, without splicing them
	
	@Builtin("base::macro/tok") ex macro fn Block	 {macro Block _}	->Block		end
	@Builtin("base::macro/tok") ex macro fn Stat	 {macro Stat _}		->Stat		end
	@Builtin("base::macro/tok") ex macro fn Var		 {macro Var _}		->Var		end
	@Builtin("base::macro/tok") ex macro fn Expr	 {macro Expr _}		->Expr		end
	@Builtin("base::macro/tok") ex macro fn ExprList {macro ExprList _}	->ExprList	end
	@Builtin("base::macro/tok") ex macro fn Name	 {macro Name _}		->Name		end
	@Builtin("base::macro/tok") ex macro fn NameList {macro NameList _}	->NameList	end
	@Builtin("base::macro/tok") ex macro fn Type	 {macro Type _}		->Type		end
	@Builtin("base::macro/tok") ex macro fn TypeList {macro TypeList _}	->TypeList	end
	
	--[[
	--TODO: move this elsewhere
		fn prefixUpperify(str prefix,mut str s) -> str
			if #s == 0 then return s end
			s[1] = s[1].upper()
			return prefix..s;
		end
	]]
	
	--[[
	
	--
	-- This is a example, for how to create a macro that instantly splices what you pass to it
	--
	-- (addType${u8}) -> (u8)
	--
	-- You can also call it like a normal function (you also need to use "()", or the other calling forms),
	-- and it will return what you called it with, and nothing will change.
	--
	-- assert(addType($Type{u8}) == $Type{u8}, "These are equal");
	--
	
	macro fn implAdd(macro NameList ns) -> Vec<Stat>
		
		let Vec<Stat> r;
		
		for k,v in ns do
			let name = ("add"..(v as str)) as Name;
			r:push(
				$Stat{
					ex macro fn $name{macro $(v as Type) val }
						return val
					end
				}
			);
		end
		
		return r;
	end
	
	$implAdd(
		Block,
		Stat,
		Var,
		Expr,
		ExprList,
		Name,
		NameList,
		Type,
		TypeList
	);
	]]
	
	Implementation {
		The types may be implemented as "Userdata" or "ptrdata", with extra data
		
		Using them outside of comptime or macros must produce a compile-time error
	}
	
}


New Syntax {

	macroSplice ::= "$(" exp ")"
	macroInvoke ::= (rawVar "$" ProgrammableArgs)
	macroVar ::= "$"RawName
	macroInvSpl ::= macroInvoke | macroSplice | macroVar
	
	stat @::= | macroInvSpl
	exp @::= | macroInvSpl
	var @::= | macroInvSpl
	Name @::= | macroInvSpl
	type @::= | macroInvSpl
	OptExportPrefix @::= | macroInvSpl
	
	macroParamsBlock ::= ("(" macroParamList ")")
		| ("[" macroParamList "]")
		| ("{" macroParamList "}") 
		| ("!>" macroParamList "<!")
	
	PreMacro ::=
	
	stat @::= | OptExportPrefix PreMacro "macro" "fn" Name macroParamsBlock ["->" type] block "end"
	
}

New Keywords {
	macro
}

Macro {
	
	Creates a new global or local macro with a name 'Name', that cant be modified.
	
	Macro's must return one of the macro types (or a simple container of them), if you need to return something else, use a comptime function.
	
	macroSplice -> splices the token sequence(s) resulting from a expresion
	macroVar -> shortcut for macroSplice, only works for token typed local variables.
	macroInvoke -> run a macro & splice it.
	The !> <! args mean that there is nothing surrounding the args.
	"macro" functions are implicitly comptime.
	
	macroInvoke gets turned from 
	```
	macroWithArgs_Name_Stat$(myNameArg,local x = 44)
	```
	into 
	```
	$(macroWithArgs_Name_Stat($Name{myNameArg},$Stat{local x = 44}))
	```
	macroVar gets turned from `$myVar` into `$(myVar)`
	
	Adding "macro" before a argument, makes it modify parsing behaviour, when
	using "macroInvoke", if there is no macro, then you need to pass it by value.
	
	$$ is converted to $.
	
	Implementation {
		Only exists inside slua land.
		
		Is programable syntax.
	}
}