#
# Dependencies: Lua, type, exportPrefix, comptime, library(TODO), annotation, rawVar
#

"Macro" Library Module {
	
	--These are only available at comptime and macros
	
	ex type Block = @Builtin("base::type/block")void;
	ex type Stat = @Builtin("base::type/stat")void;
	ex type Var = @Builtin("base::type/var")void;
	ex type Expr = @Builtin("base::type/exp")void;
	ex type ExprList = @Builtin("base::type/explist")void;
	ex type Name = @Builtin("base::type/Name")void;
	ex type NameList = @Builtin("base::type/namelist")void;
	ex type Type = @Builtin("base::type/type")void;
	ex type TypeList = @Builtin("base::type/typelist")void;
	
	ex type MacroExpr = @Builtin("base::type/macroExp")void;
	ex type MacroStat = @Builtin("base::type/macroStat")void;
	ex type MacroVar @Builtin("base::type/macroVar")void;
	
	--these exist for macro args, are actually converted to expressions.
	ex type Numeral = @Builtin("base::type/Numeral")void;
	ex type SignedNumeral = @Builtin("base::type/SignedNumeral")void;
	ex type Integral = @Builtin("base::type/Integral")void;
	ex type SignedIntegral = @Builtin("base::type/SignedIntegral")void;
	ex type LiteralString = @Builtin("base::type/LiteralString")void;
	
	@Builtin("base::macro/tok") ex $macro_rules Block{Block _}end
	@Builtin("base::macro/tok") ex $macro_rules Stat{Stat _}end
	@Builtin("base::macro/tok") ex $macro_rules Var{Var _}end
	@Builtin("base::macro/tok") ex $macro_rules Expr{Expr _}end
	@Builtin("base::macro/tok") ex $macro_rules ExprList{ExprList _}end
	@Builtin("base::macro/tok") ex $macro_rules Name{Name _}end
	@Builtin("base::macro/tok") ex $macro_rules NameList{NameList _}end
	@Builtin("base::macro/tok") ex $macro_rules Type{Type _}end
	@Builtin("base::macro/tok") ex $macro_rules TypeList{TypeList _}end
	
	@Builtin("base::macro/tok") ex $macro_rules MacroExpr{MacroExpr _}end
	@Builtin("base::macro/tok") ex $macro_rules MacroStat{MacroStat _}end
	@Builtin("base::macro/tok") ex $macro_rules MacroVar{MacroVar _}end
	
	--[[
		fn prefixUpperify(str prefix,mut str s) -> str
			if #s == 0 then return s end
			s[1] = s[1].upper()
			return prefix..s;
		end
	]]
	
	$macro_rules implAdd(name_list $ns) -> [stat]
		for $i,$n in $ns do
			$($stat{
				ex $$macro_rules $(lib::prefixUpperify("add",$n as str) as name)($($n as ty) $$v)
					$$($$v)
				end
			});
		end
	end
	
	$implAdd(
		Block,
		Stat,
		Var,
		Expr,
		ExprList,
		Name,
		NameList,
		Type,
		TypeList,

		MacroExpr,
		MacroStat,
		MacroVar
	);
	
	Implementation {
		The types may be implemented as "Userdata" or "ptrdata", with extra data
		
		Using them outside of comptime or macros must produce a compile-time error
	}
	
}


New Syntax {
	
	macroInvoke ::= ("$" rawVar ProgrammableArgs)
	macroInvSpl ::= macroInvoke | macroSplice | macroVar
	
	stat @::= | macroInvSpl
	exp @::= | macroInvSpl
	var @::= | macroInvSpl
	Name @::= | macroInvSpl
	type @::= | macroInvSpl
	OptExportPrefix @::= | macroInvSpl
	
	macroVar ::= "$"RawName
	
	macroExpRaw ::= false | true | Numeral | LiteralString 
		| macroVar | macroInvoke | macroExp "as" type | macroFunccall
	macroExpInternal ::= {unop} macroExpRaw
	macroExp ::= macroExpInternal {binop macroExpInternal}
	
	macroStat ::= ";"
		| "if" macroExp "then" macroBlock {"elseif" macroExp "then" macroBlock} [ "else" macroBlock ] "end"
		| "for" macroVar "," macroVar "in" macroExp "do" macroBlock "end"
		| "for" macroVar "=" macroExp "," macroExp ["," macroExp] "do" macroBlock "end"
		| "break"
		| macroInvoke
		| macroSplice
	
	macroFunccall ::= rawVar "(" macroExp {"," macroExp} ")"
	
	macroBlock ::= {macroStat}
	
	macroType ::= rawVar
	macroParam ::= macroType macroVar
	
	macroParams ::= [macroParam {"," macroParam}]
	macroParamsBlock ::= ("(" macroParams ")") | ("[" macroParams "]") | ("{" macroParams "}") | ("!>" macroParams "<!")
	
	stat @::= | OptExportPrefix "$macro_rules" Name macroParamsBlock ["->" macroType] macroBlock "end"
	
	macroSplice ::= "$(" macroExp ")"
}

New Keywords {
	macro_rules
	macro
}

Macro {
	
	Creates a new global or local macro with a name 'Name', that cant be modified.
	
	Implementation {
		Only exists inside slua land.
		
		Is programable syntax.
		
		You cant define a macro inside a macro argument that is stat/block.
		
		Cant use a macro to choose a name of another macro.
		
		($$m()(1,2,3)) -> error, raw var cant start with $
	}
}