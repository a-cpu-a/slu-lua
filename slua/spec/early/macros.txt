#
# Dependencies: Lua, type, exportPrefix, comptime, library(TODO), annotation, fnStatment
#

--TODO: a way to splice out keywords, like "mut", "ex" and "comptime"

"std::macros" Module {
	
	--These are only available at comptime and macros
	
	ex type Block = @Builtin("base::type/block")void;
	ex type Stat = @Builtin("base::type/stat")void;
	
	ex type Var = @Builtin("base::type/var")void;
	ex type Expr = @Builtin("base::type/exp")void;
	ex type Name = @Builtin("base::type/Name")void;
	ex type Type = @Builtin("base::type/type")void;
	
	--these exist for macro args, are actually converted to expressions.
	ex type Numeral = @Builtin("base::type/Numeral")void;
	ex type SignedNumeral = @Builtin("base::type/SignedNumeral")void;
	ex type Integral = @Builtin("base::type/Integral")void;
	ex type SignedIntegral = @Builtin("base::type/SignedIntegral")void;
	ex type LiteralString = @Builtin("base::type/LiteralString")void;
	
	--
	--wrap around one of the above things, to allow a list of someting
	--note: only works for: (Name,Type,Expr,Var,*Numeral,*Integral,LiteralString)
	--
	ex type CommaList = @Builtin("base::type/comma_sep")void;
	--semicollon seperators also allow statments
	ex type SemicolList = @Builtin("base::type/semicol_sep")void;
	
	--These return the tokens raw, without splicing them
	
	--Do NOT use @Builtin("base::no_splice") on your own code, as it is only defined here.
	--The $ after the name, makes it so it doesnt conflict with the types.
	--It also means you cant call these in function-form
	@Builtin("base::no_splice") ex macro fn Block${macro Block v}->Block return v;end
	
	--You are not allowed to use semicolon statments with this!
	@Builtin("base::no_splice") ex macro fn Stat ${macro Stat  v}->Stat  return v;end
	
	@Builtin("base::no_splice") ex macro fn Var  ${macro Var   v}->Var   return v;end
	@Builtin("base::no_splice") ex macro fn Expr ${macro Expr  v}->Expr  return v;end
	@Builtin("base::no_splice") ex macro fn Name ${macro Name  v}->Name  return v;end
	@Builtin("base::no_splice") ex macro fn Type ${macro Type  v}->Type  return v;end
	
	--Statments cant be seperated by commas
	@Builtin("base::no_splice") ex macro fn CommaList<Var> ${macro CommaList<Var>  v}->CommaList<Var>  return v;end
	@Builtin("base::no_splice") ex macro fn CommaList<Expr>${macro CommaList<Expr> v}->CommaList<Expr> return v;end
	@Builtin("base::no_splice") ex macro fn CommaList<Name>${macro CommaList<Name> v}->CommaList<Name> return v;end
	@Builtin("base::no_splice") ex macro fn CommaList<Type>${macro CommaList<Type> v}->CommaList<Type> return v;end
	
	@Builtin("base::no_splice") ex macro fn SemicolList<Stat>${macro SemicolList<Stat> v}->SemicolList<Stat> return v;end
	@Builtin("base::no_splice") ex macro fn SemicolList<Var> ${macro SemicolList<Var>  v}->SemicolList<Var>  return v;end
	@Builtin("base::no_splice") ex macro fn SemicolList<Expr>${macro SemicolList<Expr> v}->SemicolList<Expr> return v;end
	@Builtin("base::no_splice") ex macro fn SemicolList<Name>${macro SemicolList<Name> v}->SemicolList<Name> return v;end
	@Builtin("base::no_splice") ex macro fn SemicolList<Type>${macro SemicolList<Type> v}->SemicolList<Type> return v;end
	
	--[[
	--TODO: move this elsewhere
		fn prefixUpperify(str prefix,mut str s) -> str
			if #s == 0 then return s end
			s[1] = s[1].upper()
			return prefix..s;
		end
	]]
	
	--[[
	
	--
	-- This is a example, for how to create a macro that instantly splices what you pass to it
	--
	-- (addType${u8}) -> (u8)
	--
	-- You can also call it like a normal function (semicolon seperators use commas, and you also need to use "()", or the other calling forms),
	-- and it will return what you called it with, and nothing will change.
	--
	-- assert(addType(Type${u8}) == Type${u8}, "These are equal");
	--
	
	macro fn implAdd(macro CommaList<Name> ns) -> Vec<Stat>
		
		let Vec<Stat> r;
		
		for k,v in ns do
			let name = ("add"..(v as str)) as Name;
			r:push(
				Stat${
					ex macro fn $name{macro $(v as Type) val }
						return val
					end
				}
			);
		end
		
		return r;
	end
	
	implAdd$(
		Block,
		Stat,
		
		Var,
		Expr,
		Name,
		Type,
		
		CommaList<Var>,
		CommaList<Expr>,
		CommaList<Name>,
		CommaList<Type>,
		
		SemicolList<Stat>,
		
		--you cant splice these into code.
		--SemicolList<Var>,
		--SemicolList<Expr>,
		--SemicolList<Name>,
		--SemicolList<Type>,
	);
	]]
	
	Implementation {
		The types may be implemented as "Userdata" or "ptrdata", with extra data
		
		Using them outside of comptime or macros must produce a compile-time error
	}
	
}


New Syntax {

	macroSplice ::= "$(" comptimeExp ")"
	macroInvoke ::= (comptimeVar"$" ProgrammableArgs)
	macroVar ::= "$"comptimeVar
	macroInvSpl ::= macroInvoke | macroSplice | macroVar
	
	stat @::= | macroInvSpl
	exp @::= | macroInvSpl
	var @::= | macroInvSpl
	Name @::= | macroInvSpl
	type @::= | macroInvSpl
	OptExportPrefix @::= | macroInvSpl
	comptimeVar @::= | macroInvSpl
	
	macroParamsBlock ::= ("(" macroParamList ")")
		| ("[" macroParamList "]")
		| ("{" macroParamList "}") 
		| ("!>" macroParamList "<!")
	
	PreMacro ::=
	
	stat @::= | OptExportPrefix PreMacro "macro" "fn" Name ["$"] macroParamsBlock ["->" type] block "end"
	
}

New Keywords {
	macro
}

Macro {
	
	Creates a new global or local macro with a name 'Name', that cant be modified.
	
	Macro's must return one of the macro types (or a simple container of them), if you need to return something else, use a comptime function.
	
	macroSplice -> splices the token sequence(s) resulting from a expresion
	macroVar -> shortcut for macroSplice, only works for token typed local variables.
	macroInvoke -> run a macro & splice it.
	The !> <! args mean that there is nothing surrounding the args.
	"macro" functions are implicitly comptime.
	
	macroInvoke gets turned from 
	```
	macroWithArgs_Name_Stat$(myNameArg,local x = 44)
	```
	into 
	```
	$(macroWithArgs_Name_Stat(Name${myNameArg},Stat${local x = 44}))
	```
	macroVar gets turned from `$myVar` into `$(myVar)`
	
	Adding "macro" before a argument, makes it modify parsing behaviour, when
		using "macroInvoke", if there is no macro, then you need to pass it by value.
	
	You can call macro-functions like normal comptime functions.
	When doing that, semicolon seperators use commas, and you also need to use "()", or the other calling forms.
	
	When using "!> <!", you cant have more than 1 argument, and it cant be a list.
	
	Right after a CommaList, you are not allowed to use a comma seperator.
	Right after a SemicolList, you are not allowed to use a semicolon seperator.
	
	Certain kinds of macro overloading are allowed.
	Macro Overloading Rules {
		
		() is always allowed.
		
		All references to lists, allow both the list types, and also just manual 
		list inlining, that means: `CommaList<T>` -> `T` or `T,T` or `T,T,T` ...
		
		T,T2,T3 ... can all be the same, cuz overloading doesnt care about the types, only the seperators.
		
		Overloading complicates calling macros in the function style.
		--TODO: should "overload resolution" happen?
		
		(T;anyList<T2>)					+ (commaList<T>)
		(T,anyList<T2>)					+ (semicolList<T>)
		(T;anyList<T2>)					+ (T,commaList<T>;anyList<T3>)
		(T,anyList<T2>)					+ (T;semicolList<T>,anyList<T3>)
		(T;semicolList<T2>,anyList<T3>)	+ (commaList<T>)
		(T,commaList<T2>;anyList<T3>)	+ (semicolList<T>)
		(T;semicolList<T2>,anyList<T3>)	+ (T,commaList<T>;anyList<T4>)
		(T,commaList<T2>;anyList<T3>)	+ (T;semicolList<T>,anyList<T4>)
		
		
		Examples {
			() + (T;T) + (CommaList<T>)
			Valid as it is: (T;anyList<T2>) + (commaList<T>)
		}
	}
	
	Stat doesnt allow semicolon statments.
	
	adding a $ after the name of a macro def, makes it so it doesnt
	conflict with existing symbols,	it also means you cant call them in function-form
	
	$$ is converted to $.
	
	Implementation {
		Only exists inside slua land.
		
		Is programable syntax.
	}
}