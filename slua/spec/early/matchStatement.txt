#
# Dependencies: Lua, type, comptime
#

New Syntax {
	--Note that this 'var' only supports basic args, and cant be a deref
	--Also, type expr is prefered of func call / var, so if they return types, then they are treated as types.
	--Note: unop cant be deref, ref, ptr, other type ones
	--Note: binop doesnt allow 'or' and 'and'
	matchPatItem ::= "(" comptimeExp ")"
		| Numeral
		| StringLiteral
		| var
		| functioncallBasicArgs
		| matchPatItem binop matchPatItem
		| arrayMultiplyConstruct
		| basicTypeExp
		| {unop} matchPatItem {postunop}
		| "..."
	
	matchPatBinOp ::= "or"
	sPat ::= matchPatItem {matchPatBinOp matchPatItem}
	
	
	destrSpec ::= basicTypeOrTypePrefix | ("as" typeExp)
	destrSpecMut ::= basicTypeOrTypePrefixMut | ("as" typeExpMut)
	
	extraFieldSignifier ::= "," ".."
	
	
	destrField ::= "|" tupleableName "|" pat
	destrFieldList ::= destrField {"," destrField} [extraFieldSignifier]
	destrPatFieldList ::= pat {"," pat} [extraFieldSignifier]
	
	dPat ::= destrSpec "{" destrFieldList "}" 
		| destrSpecMut "{" destrFieldList "}"  Name
		| destrSpec "{" destrPatFieldList "}"
		| destrSpecMut "{" destrPatFieldList "}" Name
		
		| destrSpecMut Name ["=" ndPat] 
		| "_"
	
	
	destrFieldUncond ::= "|" tupleableName "|" uncondDestrPat
	uncondDestrFieldList ::= destrFieldUncond {"," destrFieldUncond} [extraFieldSignifier]
	uncondDestrPatFieldList ::= uncondDestrPat {"," uncondDestrPat} [extraFieldSignifier]
	
	uncondDestrPat ::= destrSpec "{" uncondDestrFieldList "}"
		| destrSpecMut "{" uncondDestrFieldList "}" Name
		| destrSpec "{" uncondDestrPatFieldList "}"
		| destrSpecMut "{" uncondDestrPatFieldList "}" Name
		
		| destrSpecMut Name
		| "_"
	
	
	ndPat ::= sPat
	pat ::= sPat | dPat
	
	matchItem ::= pat ["if" exp] "=>" explist
	matchElseItem ::= "else" ["if" exp] "=>" explist
	matchStat ::= matchItem | matchElseItem | ";"
	
	matchExp ::= "match" "(" exp ")" ["->" typeExp] "{" {matchStat} "}"
	
	exp @::= | matchExp
	stat @::= | matchExp
}

New Keywords {
	match
	case
	as
}

Match Statement {
	
	Lets you match on a expressions result.
	
	The return type is assigned automatically, if missing.
	
	First matching pattern will be used. (top to bottom)
	The order inside the patterns is undefined.
	
	Match statments must always handle all inputs.
	If some inputs wouldnt match, then a soft-error occurs, and a " else => panic$(); " is inserted.
	It is an soft-error to have multiple cases that are identical, without any if checks.
	
	
	"extraFieldSignifier" is required, when a field / array element is ignored, or when matching on dynamicaly-sized arrays.
	
	Implementation {
		May be a jump table, if else chain, etc.
	}
}